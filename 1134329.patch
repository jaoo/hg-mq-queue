# HG changeset patch
# User Jose Antonio Olivera Ortega <jaoo@jaoo.es>
# Parent  f384789a29dcfd514d25d4a16a97ec5309612d78
Bug 1134329 - Service worker install and activate events not fired when updating the service worker javascript file. r=nsm,ochameau

diff --git a/browser/app/profile/firefox.js b/browser/app/profile/firefox.js
--- a/browser/app/profile/firefox.js
+++ b/browser/app/profile/firefox.js
@@ -1464,16 +1464,19 @@ pref("devtools.performance.ui.experiment
 #endif
 
 // The default cache UI setting
 pref("devtools.cache.disabled", false);
 
 // The default service workers UI setting
 pref("devtools.serviceWorkers.testing.enabled", false);
 
+// Force update service worker on registration flag.
+pref("devtools.serviceWorkers.forceUpdateOnRegistration", false);
+
 // Enable the Network Monitor
 pref("devtools.netmonitor.enabled", true);
 
 // The default Network Monitor UI settings
 pref("devtools.netmonitor.panes-network-details-width", 550);
 pref("devtools.netmonitor.panes-network-details-height", 450);
 pref("devtools.netmonitor.statistics", true);
 pref("devtools.netmonitor.filters", "[\"all\"]");
diff --git a/browser/devtools/framework/test/browser.ini b/browser/devtools/framework/test/browser.ini
--- a/browser/devtools/framework/test/browser.ini
+++ b/browser/devtools/framework/test/browser.ini
@@ -7,19 +7,19 @@ support-files =
   browser_toolbox_options_disable_cache.sjs
   browser_toolbox_sidebar_tool.xul
   code_math.js
   head.js
   shared-head.js
   helper_disable_cache.js
   doc_theme.css
   doc_viewsource.html
-  browser_toolbox_options_enable_serviceworkers_testing_frame_script.js
-  browser_toolbox_options_enable_serviceworkers_testing.html
-  serviceworker.js
+  browser_toolbox_options_serviceworkers_frame_script.js
+  browser_toolbox_options_serviceworkers.html
+  serviceworker.sjs
 
 [browser_devtools_api.js]
 [browser_devtools_api_destroy.js]
 [browser_dynamic_tool_enabling.js]
 [browser_ignore_toolbox_network_requests.js]
 [browser_keybindings_01.js]
 [browser_keybindings_02.js]
 [browser_keybindings_03.js]
@@ -64,14 +64,14 @@ skip-if = e10s # Bug 1069044 - destroyIn
 [browser_toolbox_view_source_04.js]
 [browser_toolbox_window_reload_target.js]
 [browser_toolbox_window_shortcuts.js]
 skip-if = os == "mac" && os_version == "10.8" || os == "win" && os_version == "5.1" # Bug 851129 - Re-enable browser_toolbox_window_shortcuts.js test after leaks are fixed
 [browser_toolbox_window_title_changes.js]
 [browser_toolbox_zoom.js]
 [browser_toolbox_custom_host.js]
 [browser_toolbox_theme_registration.js]
-[browser_toolbox_options_enable_serviceworkers_testing.js]
+[browser_toolbox_options_serviceworkers.js]
 [browser_toolbox_selected_tool_unavailable.js]
 
 # We want this test to run for mochitest-dt as well, so we include it here:
 [../../../base/content/test/general/browser_parsable_css.js]
 
diff --git a/browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing.html b/browser/devtools/framework/test/browser_toolbox_options_serviceworkers.html
rename from browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing.html
rename to browser/devtools/framework/test/browser_toolbox_options_serviceworkers.html
diff --git a/browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing.js b/browser/devtools/framework/test/browser_toolbox_options_serviceworkers.js
rename from browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing.js
rename to browser/devtools/framework/test/browser_toolbox_options_serviceworkers.js
--- a/browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing.js
+++ b/browser/devtools/framework/test/browser_toolbox_options_serviceworkers.js
@@ -1,25 +1,27 @@
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
-// Test that enabling Service Workers testing option enables the
-// mServiceWorkersTestingEnabled attribute added to nsPIDOMWindow.
+// mServiceWorkersTestingEnabled attribute added to nsPIDOMWindow. It also
+// tests that toggling on the force service worker update on registration
+// checkbox the service worker is always updated on registration.
 
 const COMMON_FRAME_SCRIPT_URL =
   "chrome://browser/content/devtools/frame-script-utils.js";
 const ROOT_TEST_DIR =
   getRootDirectory(gTestPath);
 const FRAME_SCRIPT_URL =
   ROOT_TEST_DIR +
-  "browser_toolbox_options_enable_serviceworkers_testing_frame_script.js";
+  "browser_toolbox_options_serviceworkers_frame_script.js";
 const TEST_URI = URL_ROOT +
-                 "browser_toolbox_options_enable_serviceworkers_testing.html";
+                 "browser_toolbox_options_serviceworkers.html";
 
-const ELEMENT_ID = "devtools-enable-serviceWorkersTesting";
+const TESTING_ELEMENT_ID = "devtools-enable-serviceWorkersTesting";
+const FORCE_UPDATE_ELEMENT_ID = "devtools-serviceWorkers-forceUpdateOnRegistration";
 
 let toolbox;
 
 function test() {
   // Note: Pref dom.serviceWorkers.testing.enabled is false since we are testing
   // the same capabilities are enabled with the devtool pref.
   SpecialPowers.pushPrefEnv({"set": [
     ["dom.serviceWorkers.exemptFromPerDomainMax", true],
@@ -49,42 +51,68 @@ function testSelectTool(aToolbox) {
   toolbox.once("options-selected", start);
   toolbox.selectTool("options");
 }
 
 function register() {
   return executeInContent("devtools:sw-test:register");
 }
 
-function unregister(swr) {
+function forceUpdate() {
+  return executeInContent("devtools:sw-test:forceUpdate");
+}
+
+function unregister() {
   return executeInContent("devtools:sw-test:unregister");
 }
 
 function testRegisterFails(data) {
   is(data.success, false, "Register should fail with security error");
   return promise.resolve();
 }
 
+function testForceUpdate(data) {
+  is(data.success, true, "Force update should success");
+  return promise.resolve();
+}
+
 function toggleServiceWorkersTestingCheckbox() {
   let panel = toolbox.getCurrentPanel();
-  let cbx = panel.panelDoc.getElementById(ELEMENT_ID);
+  let cbx = panel.panelDoc.getElementById(TESTING_ELEMENT_ID);
 
   cbx.scrollIntoView();
 
   if (cbx.checked) {
     info("Clearing checkbox to disable service workers testing");
   } else {
     info("Checking checkbox to enable service workers testing");
   }
 
   cbx.click();
 
   return promise.resolve();
 }
 
+function toggleServiceWorkersForceUpdateCheckbox() {
+  let panel = toolbox.getCurrentPanel();
+  let cbx = panel.panelDoc.getElementById(FORCE_UPDATE_ELEMENT_ID);
+
+  cbx.scrollIntoView();
+
+  if (cbx.checked) {
+    info("Clearing checkbox to disable force update service workers");
+  } else {
+    info("Checking checkbox to enable force update service workers");
+  }
+
+  cbx.click();
+
+  return promise.resolve();
+}
+
 function reload() {
   let deferred = promise.defer();
 
   gBrowser.selectedBrowser.addEventListener("load", function onLoad(evt) {
     gBrowser.selectedBrowser.removeEventListener(evt.type, onLoad, true);
     deferred.resolve();
   }, true);
 
@@ -99,16 +127,20 @@ function testRegisterSuccesses(data) {
 
 function start() {
   register()
     .then(testRegisterFails)
     .then(toggleServiceWorkersTestingCheckbox)
     .then(reload)
     .then(register)
     .then(testRegisterSuccesses)
+    .then(toggleServiceWorkersForceUpdateCheckbox)
+    .then(reload)
+    .then(forceUpdate)
+    .then(testForceUpdate)
     .then(unregister)
     // Workers should be turned back off when we closes the toolbox
     .then(toolbox.destroy.bind(toolbox))
     .then(reload)
     .then(register)
     .then(testRegisterFails)
     .catch(function(e) {
       ok(false, "Some test failed with error " + e);
diff --git a/browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing_frame_script.js b/browser/devtools/framework/test/browser_toolbox_options_serviceworkers_frame_script.js
rename from browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing_frame_script.js
rename to browser/devtools/framework/test/browser_toolbox_options_serviceworkers_frame_script.js
--- a/browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing_frame_script.js
+++ b/browser/devtools/framework/test/browser_toolbox_options_serviceworkers_frame_script.js
@@ -1,24 +1,38 @@
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // A helper frame-script for browser/devtools/framework service worker tests.
 
 "use strict";
 
 addMessageListener("devtools:sw-test:register", function(msg) {
-  content.navigator.serviceWorker.register("serviceworker.js")
+  content.navigator.serviceWorker.register("serviceworker.sjs")
     .then(swr => {
       sendAsyncMessage("devtools:sw-test:register", {success: true});
     }, error => {
       sendAsyncMessage("devtools:sw-test:register", {success: false});
     });
 });
 
+addMessageListener("devtools:sw-test:forceUpdate", function(msg) {
+  content.navigator.serviceWorker.getRegistration().then(swr => {
+    swr.addEventListener('updatefound', function onUpdateFound() {
+      swr.removeEventListener('updatefound', onUpdateFound);
+      sendAsyncMessage("devtools:sw-test:forceUpdate", {success: true});
+    });
+  });
+
+  content.navigator.serviceWorker.register("serviceworker.sjs")
+    .catch(error => {
+      sendAsyncMessage("devtools:sw-test:forceUpdate", {success: false});
+    });
+});
+
 addMessageListener("devtools:sw-test:unregister", function(msg) {
   content.navigator.serviceWorker.getRegistration().then(swr => {
     swr.unregister().then(result => {
       sendAsyncMessage("devtools:sw-test:unregister",
                        {success: result ? true : false});
     });
   });
 });
diff --git a/browser/devtools/framework/test/serviceworker.js b/browser/devtools/framework/test/serviceworker.sjs
rename from browser/devtools/framework/test/serviceworker.js
rename to browser/devtools/framework/test/serviceworker.sjs
--- a/browser/devtools/framework/test/serviceworker.js
+++ b/browser/devtools/framework/test/serviceworker.sjs
@@ -1,1 +1,32 @@
-// empty service worker, always succeed!
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+// For bug 1134329 we need to test that several calls to
+// navigator.serviceWorker.register() with the same script URL with the
+// devtools 'force update' pref set, skip [[Register]] step 4.2.2.1 and the
+// update is done. Byte-for-byte equal scripts will abort the update so this
+// server-side JavaScript file will return slightly different 'service worker
+// scripts' on each call.
+
+function handleRequest(request, response) {
+  // These are the different service worker scripts we will return. The order
+  // does not really matter but the comment in them gives us an idea about what
+  // script will be use for each test. The goal is the script we return differs
+  // byte-for-byte from the previously script returned.
+  let serviceWorkers = [
+    "// empty service worker for testing register function works",
+    "// empty service worker for testing force update flag works",
+  ];
+  let index = parseInt(getState("index")) || 0;
+
+  // This server-side JavaScript file might be requested to return more service
+  // worker scritps than the ones we defined above. Let's respond with a 500
+  // error code rather than empty service worker.
+  if (index < serviceWorkers.length) {
+    response.write(serviceWorkers[index]);
+    index++;
+    setState("index", index.toString());
+  } else {
+    response.setStatusLine(request.httpVersion, 500, "K0");
+  }
+}
diff --git a/browser/devtools/framework/toolbox-options.xul b/browser/devtools/framework/toolbox-options.xul
--- a/browser/devtools/framework/toolbox-options.xul
+++ b/browser/devtools/framework/toolbox-options.xul
@@ -142,16 +142,20 @@
                     data-pref="devtools.cache.disabled"/>
           <checkbox id="devtools-disable-javascript"
                     label="&options.disableJavaScript.label;"
                     tooltiptext="&options.disableJavaScript.tooltip;"/>
           <checkbox id="devtools-enable-serviceWorkersTesting"
                     label="&options.enableServiceWorkersHTTP.label;"
                     tooltiptext="&options.enableServiceWorkersHTTP.tooltip;"
                     data-pref="devtools.serviceWorkers.testing.enabled"/>
+          <checkbox id="devtools-serviceWorkers-forceUpdateOnRegistration"
+                    label="&options.serviceWorkersForceUpdateOnRegistration.label;"
+                    tooltiptext="&options.serviceWorkersForceUpdateOnRegistration.tooltip;"
+                    data-pref="devtools.serviceWorkers.forceUpdateOnRegistration"/>
           <hbox class="hidden-labels-box">
             <checkbox label="&options.enableChrome.label5;"
                       tooltiptext="&options.enableChrome.tooltip3;"
                       data-pref="devtools.chrome.enabled"/>
           </hbox>
           <hbox class="hidden-labels-box">
             <checkbox label="&options.enableRemote.label3;"
                       tooltiptext="&options.enableRemote.tooltip;"
diff --git a/browser/devtools/framework/toolbox.js b/browser/devtools/framework/toolbox.js
--- a/browser/devtools/framework/toolbox.js
+++ b/browser/devtools/framework/toolbox.js
@@ -363,16 +363,17 @@ Toolbox.prototype = {
       this.textboxContextMenuPopup.addEventListener("popupshowing",
         this._updateTextboxMenuItems, true);
 
       this._buildDockButtons();
       this._buildOptions();
       this._buildTabs();
       this._applyCacheSettings();
       this._applyServiceWorkersTestingSettings();
+      this._applyServiceWorkersForceUpdateOnRegistrationFlag();
       this._addKeysToWindow();
       this._addReloadKeys();
       this._addHostListeners();
       this._registerOverlays();
       if (this._hostOptions && this._hostOptions.zoom === false) {
         this._disableZoomKeys();
       } else {
         this._addZoomKeys();
@@ -448,16 +449,19 @@ Toolbox.prototype = {
   _prefChanged: function(event, data) {
     switch (data.pref) {
       case "devtools.cache.disabled":
         this._applyCacheSettings();
         break;
       case "devtools.serviceWorkers.testing.enabled":
         this._applyServiceWorkersTestingSettings();
         break;
+      case "devtools.serviceWorkers.forceUpdateOnRegistration":
+        this._applyServiceWorkersForceUpdateOnRegistrationFlag();
+        break;
     }
   },
 
   _buildOptions: function() {
     let key = this.doc.getElementById("toolbox-options-key");
     key.addEventListener("command", () => {
       this.selectTool("options");
     }, true);
@@ -895,16 +899,33 @@ Toolbox.prototype = {
 
     if (this.target.activeTab) {
       this.target.activeTab.reconfigure({
         "serviceWorkersTestingEnabled": serviceWorkersTestingEnabled
       });
     }
   },
 
+   /**
+   * Apply the current force service worker update on registration flag from
+   * devtools.serviceWorkers.forceUpdateOnRegistration to this toolbox's tab.
+   */
+  _applyServiceWorkersForceUpdateOnRegistrationFlag: function() {
+    let pref = "devtools.serviceWorkers.forceUpdateOnRegistration";
+    let forceServiceWorkersUpdateOnRegistration =
+      Services.prefs.getBoolPref(pref) || false;
+
+    if (this.target.activeTab) {
+      this.target.activeTab.reconfigure({
+        "forceServiceWorkersUpdateOnRegistration":
+        forceServiceWorkersUpdateOnRegistration
+      });
+    }
+  },
+
   /**
    * Setter for the checked state of the picker button in the toolbar
    * @param {Boolean} isChecked
    */
   set pickerButtonChecked(isChecked) {
     if (isChecked) {
       this._pickerButton.setAttribute("checked", "true");
     } else {
diff --git a/browser/locales/en-US/chrome/browser/devtools/toolbox.dtd b/browser/locales/en-US/chrome/browser/devtools/toolbox.dtd
--- a/browser/locales/en-US/chrome/browser/devtools/toolbox.dtd
+++ b/browser/locales/en-US/chrome/browser/devtools/toolbox.dtd
@@ -111,16 +111,22 @@
 <!ENTITY options.disableCache.tooltip2   "Turning this option on will disable the cache for all tabs that have the toolbox open.">
 
 <!-- LOCALIZATION NOTE (options.enableServiceWorkersHTTP.label,
   -  options.enableServiceWorkersHTTP.tooltip): This is the options panel label and
   -  tooltip for the checkbox that toggles the service workers testing features on or off. This option enables service workers over HTTP. -->
 <!ENTITY options.enableServiceWorkersHTTP.label     "Enable Service Workers over HTTP (when toolbox is open)">
 <!ENTITY options.enableServiceWorkersHTTP.tooltip   "Turning this option on will enable the service workers over HTTP for all tabs that have the toolbox open.">
 
+<!-- LOCALIZATION NOTE (options.serviceWorkersForceUpdateOnRegistration.label,
+  -  options.serviceWorkersForceUpdateOnRegistration.tooltip): This is the options panel label and
+  -  tooltip for the checkbox that toggles on or off the force update on registration flag for service workers. -->
+<!ENTITY options.serviceWorkersForceUpdateOnRegistration.label     "Force Service Workers to be updated on registration (when toolbox is open)">
+<!ENTITY options.serviceWorkersForceUpdateOnRegistration.tooltip   "Turning this option on will force the update of the service workers on registration for all tabs that have the toolbox open.">
+
 <!-- LOCALIZATION NOTE (options.selectDefaultTools.label): This is the label for
   -  the heading of group of checkboxes corresponding to the default developer
   -  tools. -->
 <!ENTITY options.selectDefaultTools.label     "Default Firefox Developer Tools">
 
 <!-- LOCALIZATION NOTE (options.selectAdditionalTools.label): This is the label for
   -  the heading of group of checkboxes corresponding to the developer tools
   -  added by add-ons. This heading is hidden when there is no developer tool
diff --git a/dom/base/nsDOMWindowUtils.cpp b/dom/base/nsDOMWindowUtils.cpp
--- a/dom/base/nsDOMWindowUtils.cpp
+++ b/dom/base/nsDOMWindowUtils.cpp
@@ -3899,16 +3899,42 @@ nsDOMWindowUtils::GetServiceWorkersTesti
   NS_ENSURE_STATE(window);
 
   *aEnabled = window->GetServiceWorkersTestingEnabled();
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
+nsDOMWindowUtils::SetForceServiceWorkerUpdateOnRegistration(bool aEnabled)
+{
+  MOZ_RELEASE_ASSERT(nsContentUtils::IsCallerChrome());
+
+  nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
+  NS_ENSURE_STATE(window);
+
+  window->SetForceServiceWorkerUpdateOnRegistration(aEnabled);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsDOMWindowUtils::GetForceServiceWorkerUpdateOnRegistration(bool *aEnabled)
+{
+  MOZ_RELEASE_ASSERT(nsContentUtils::IsCallerChrome());
+
+  nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
+  NS_ENSURE_STATE(window);
+
+  *aEnabled = window->GetForceServiceWorkerUpdateOnRegistration();
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 nsDOMWindowUtils::EnterChaosMode()
 {
   MOZ_RELEASE_ASSERT(nsContentUtils::IsCallerChrome());
   ChaosMode::enterChaosMode();
   return NS_OK;
 }
 
 NS_IMETHODIMP
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -564,17 +564,18 @@ nsPIDOMWindow::nsPIDOMWindow(nsPIDOMWind
   mMayHavePointerEnterLeaveEventListener(false),
   mIsModalContentWindow(false),
   mIsActive(false), mIsBackground(false),
   mAudioMuted(false), mAudioVolume(1.0), mAudioCaptured(false),
   mDesktopModeViewport(false), mInnerWindow(nullptr),
   mOuterWindow(aOuterWindow),
   // Make sure no actual window ends up with mWindowID == 0
   mWindowID(NextWindowID()), mHasNotifiedGlobalCreated(false),
-  mMarkedCCGeneration(0), mServiceWorkersTestingEnabled(false)
+  mMarkedCCGeneration(0), mServiceWorkersTestingEnabled(false),
+  mForceServiceWorkerUpdateOnRegistration(false)
  {}
 
 nsPIDOMWindow::~nsPIDOMWindow() {}
 
 // DialogValueHolder CC goop.
 NS_IMPL_CYCLE_COLLECTION(DialogValueHolder, mValue)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(DialogValueHolder)
diff --git a/dom/base/nsPIDOMWindow.h b/dom/base/nsPIDOMWindow.h
--- a/dom/base/nsPIDOMWindow.h
+++ b/dom/base/nsPIDOMWindow.h
@@ -195,16 +195,28 @@ public:
   }
 
   bool GetServiceWorkersTestingEnabled()
   {
     MOZ_ASSERT(IsOuterWindow());
     return mServiceWorkersTestingEnabled;
   }
 
+  virtual void SetForceServiceWorkerUpdateOnRegistration(bool aEnabled)
+  {
+    MOZ_ASSERT(IsOuterWindow());
+    mForceServiceWorkerUpdateOnRegistration = aEnabled;
+  }
+
+  bool GetForceServiceWorkerUpdateOnRegistration()
+  {
+    MOZ_ASSERT(IsOuterWindow());
+    return mForceServiceWorkerUpdateOnRegistration;
+  }
+
 protected:
   // Lazily instantiate an about:blank document if necessary, and if
   // we have what it takes to do so.
   void MaybeCreateDoc();
 
   float GetAudioGlobalVolumeInternal(float aVolume);
   void RefreshMediaElements();
 
@@ -853,16 +865,20 @@ protected:
   // the (chrome|content)-document-global-created notification.
   bool mHasNotifiedGlobalCreated;
 
   uint32_t mMarkedCCGeneration;
 
   // Let the service workers plumbing know that some feature are enabled while
   // testing.
   bool mServiceWorkersTestingEnabled;
+
+  // Flag that let the service workers plumbing know service workers will be
+  // always updated on registration.
+  bool mForceServiceWorkerUpdateOnRegistration;
 };
 
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsPIDOMWindow, NS_PIDOMWINDOW_IID)
 
 #ifdef MOZILLA_INTERNAL_API
 PopupControlState
 PushPopupControlState(PopupControlState aState, bool aForce);
diff --git a/dom/interfaces/base/nsIDOMWindowUtils.idl b/dom/interfaces/base/nsIDOMWindowUtils.idl
--- a/dom/interfaces/base/nsIDOMWindowUtils.idl
+++ b/dom/interfaces/base/nsIDOMWindowUtils.idl
@@ -44,17 +44,17 @@ interface nsIDOMClientRect;
 interface nsIURI;
 interface nsIDOMEventTarget;
 interface nsIRunnable;
 interface nsITranslationNodeList;
 interface nsIJSRAIIHelper;
 interface nsIContentPermissionRequest;
 interface nsIObserver;
 
-[scriptable, uuid(47fa312b-2ad1-4b80-8a0a-c9822e2d1ec9)]
+[scriptable, uuid(e97634c8-9abf-4a54-ac72-5c09ef130207)]
 interface nsIDOMWindowUtils : nsISupports {
 
   /**
    * Image animation mode of the window. When this attribute's value
    * is changed, the implementation should set all images in the window
    * to the given value. That is, when set to kDontAnimMode, all images
    * will stop animating. The attribute's value must be one of the
    * animationMode values from imgIContainer.
@@ -1814,16 +1814,22 @@ interface nsIDOMWindowUtils : nsISupport
                        in int32_t aLeft);
 
   /**
    * Enable some service workers testing features.
    */
   attribute boolean serviceWorkersTestingEnabled;
 
   /**
+   * Flag that let the service workers plumbing know service workers will be
+   * always updated on registration.
+   */
+  attribute boolean forceServiceWorkerUpdateOnRegistration;
+
+  /**
    * Returns a JSObject which contains a list of frame uniformities
    * when the pref gfx.vsync.collect-scroll-data is enabled.
    * Every result contains a layer address and a frame uniformity for that layer.
    * A negative frame uniformity value indicates an invalid frame uniformity and an error has occured.
    */
   [implicit_jscontext] jsval getFrameUniformityTestData();
 
   /*
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -881,16 +881,17 @@ class ServiceWorkerRegisterJob final : p
 
   nsCString mScope;
   nsCString mScriptSpec;
   nsRefPtr<ServiceWorkerRegistrationInfo> mRegistration;
   nsRefPtr<ServiceWorkerUpdateFinishCallback> mCallback;
   nsCOMPtr<nsIPrincipal> mPrincipal;
   nsRefPtr<ServiceWorkerInfo> mUpdateAndInstallInfo;
   nsCOMPtr<nsILoadGroup> mLoadGroup;
+  bool mForceUpdate;
 
   ~ServiceWorkerRegisterJob()
   { }
 
   enum
   {
     REGISTER_JOB = 0,
     UPDATE_JOB = 1,
@@ -902,23 +903,25 @@ public:
   NS_DECL_ISUPPORTS_INHERITED
 
   // [[Register]]
   ServiceWorkerRegisterJob(ServiceWorkerJobQueue* aQueue,
                            const nsCString& aScope,
                            const nsCString& aScriptSpec,
                            ServiceWorkerUpdateFinishCallback* aCallback,
                            nsIPrincipal* aPrincipal,
-                           nsILoadGroup* aLoadGroup)
+                           nsILoadGroup* aLoadGroup,
+                           bool aForceUpdate)
     : ServiceWorkerJob(aQueue)
     , mScope(aScope)
     , mScriptSpec(aScriptSpec)
     , mCallback(aCallback)
     , mPrincipal(aPrincipal)
     , mLoadGroup(aLoadGroup)
+    , mForceUpdate(aForceUpdate)
     , mJobType(REGISTER_JOB)
     , mCanceled(false)
   {
     MOZ_ASSERT(mLoadGroup);
   }
 
   // [[Update]]
   ServiceWorkerRegisterJob(ServiceWorkerJobQueue* aQueue,
@@ -958,17 +961,18 @@ public:
       return;
     }
 
     if (mJobType == REGISTER_JOB) {
       mRegistration = swm->GetRegistration(mPrincipal, mScope);
 
       if (mRegistration) {
         nsRefPtr<ServiceWorkerInfo> newest = mRegistration->Newest();
-        if (newest && mScriptSpec.Equals(newest->ScriptSpec()) &&
+        if (!mForceUpdate && newest &&
+            mScriptSpec.Equals(newest->ScriptSpec()) &&
             mScriptSpec.Equals(mRegistration->mScriptSpec)) {
           mRegistration->mPendingUninstall = false;
           swm->StoreRegistration(mPrincipal, mRegistration);
           Succeed();
 
           // Done() must always be called async from Start()
           nsCOMPtr<nsIRunnable> runnable =
             NS_NewRunnableMethodWithArg<nsresult>(
@@ -1509,16 +1513,18 @@ ServiceWorkerManager::Register(nsIDOMWin
 
   // Don't allow service workers to register when the *document* is chrome for
   // now.
   MOZ_ASSERT(!nsContentUtils::IsSystemPrincipal(doc->NodePrincipal()));
 
   nsCOMPtr<nsPIDOMWindow> outerWindow = window->GetOuterWindow();
   bool serviceWorkersTestingEnabled =
     outerWindow->GetServiceWorkersTestingEnabled();
+  bool forceServiceWorkerUpdateOnRegistration =
+    outerWindow->GetForceServiceWorkerUpdateOnRegistration();
 
   bool authenticatedOrigin;
   if (Preferences::GetBool("dom.serviceWorkers.testing.enabled") ||
       serviceWorkersTestingEnabled) {
     authenticatedOrigin = true;
   } else {
     authenticatedOrigin = IsFromAuthenticatedOrigin(doc);
   }
@@ -1582,17 +1588,23 @@ ServiceWorkerManager::Register(nsIDOMWin
   // Create a load group that is separate from, yet related to, the document's load group.
   // This allows checks for interfaces like nsILoadContext to yield the values used by the
   // the document, yet will not cancel the update job if the document's load group is cancelled.
   nsCOMPtr<nsILoadGroup> loadGroup = do_CreateInstance(NS_LOADGROUP_CONTRACTID);
   rv = loadGroup->SetNotificationCallbacks(ir);
   MOZ_ALWAYS_TRUE(NS_SUCCEEDED(rv));
 
   nsRefPtr<ServiceWorkerRegisterJob> job =
-    new ServiceWorkerRegisterJob(queue, cleanedScope, spec, cb, documentPrincipal, loadGroup);
+    new ServiceWorkerRegisterJob(queue,
+                                 cleanedScope,
+                                 spec,
+                                 cb,
+                                 documentPrincipal,
+                                 loadGroup,
+                                 forceServiceWorkerUpdateOnRegistration);
   queue->Append(job);
 
   AssertIsOnMainThread();
   Telemetry::Accumulate(Telemetry::SERVICE_WORKER_REGISTRATIONS, 1);
 
   promise.forget(aPromise);
   return NS_OK;
 }
diff --git a/toolkit/devtools/server/actors/webbrowser.js b/toolkit/devtools/server/actors/webbrowser.js
--- a/toolkit/devtools/server/actors/webbrowser.js
+++ b/toolkit/devtools/server/actors/webbrowser.js
@@ -1431,16 +1431,23 @@ TabActor.prototype = {
     }
     if ((typeof options.serviceWorkersTestingEnabled !== "undefined") &&
         (options.serviceWorkersTestingEnabled !==
          this._getServiceWorkersTestingEnabled())) {
       this._setServiceWorkersTestingEnabled(
         options.serviceWorkersTestingEnabled
       );
     }
+    if ((typeof options.forceServiceWorkersUpdateOnRegistration !== "undefined") &&
+        (options.forceServiceWorkersUpdateOnRegistration !==
+         this._getForceServiceWorkersUpdateOnRegistration())) {
+      this._setForceServiceWorkersUpdateOnRegistration(
+        options.forceServiceWorkersUpdateOnRegistration
+      );
+    }
 
     // Reload if:
     //  - there's an explicit `performReload` flag and it's true
     //  - there's no `performReload` flag, but it makes sense to do so
     let hasExplicitReloadFlag = "performReload" in options;
     if ((hasExplicitReloadFlag && options.performReload) ||
        (!hasExplicitReloadFlag && reload)) {
       this.onReload();
@@ -1450,16 +1457,17 @@ TabActor.prototype = {
   /**
    * Opposite of the _toggleDevToolsSettings method, that reset document state
    * when closing the toolbox.
    */
   _restoreDocumentSettings: function () {
     this._restoreJavascript();
     this._setCacheDisabled(false);
     this._setServiceWorkersTestingEnabled(false);
+    this._setForceServiceWorkersUpdateOnRegistration(false);
   },
 
   /**
    * Disable or enable the cache via docShell.
    */
   _setCacheDisabled: function(disabled) {
     let enable =  Ci.nsIRequest.LOAD_NORMAL;
     let disable = Ci.nsIRequest.LOAD_BYPASS_CACHE |
@@ -1506,16 +1514,26 @@ TabActor.prototype = {
    */
   _setServiceWorkersTestingEnabled: function(enabled) {
     let windowUtils = this.window.QueryInterface(Ci.nsIInterfaceRequestor)
                                  .getInterface(Ci.nsIDOMWindowUtils);
     windowUtils.serviceWorkersTestingEnabled = enabled;
   },
 
   /**
+   * Disable or enable to force always the update of service workers on
+   * registration.
+   */
+  _setForceServiceWorkersUpdateOnRegistration: function(enabled) {
+    let windowUtils = this.window.QueryInterface(Ci.nsIInterfaceRequestor)
+                                  .getInterface(Ci.nsIDOMWindowUtils);
+    windowUtils.forceServiceWorkerUpdateOnRegistration = enabled;
+  },
+
+  /**
    * Return cache allowed status.
    */
   _getCacheDisabled: function() {
     if (!this.docShell) {
       // The tab is already closed.
       return null;
     }
 
@@ -1534,16 +1552,31 @@ TabActor.prototype = {
     }
 
     let windowUtils = this.window.QueryInterface(Ci.nsIInterfaceRequestor)
                                  .getInterface(Ci.nsIDOMWindowUtils);
     return windowUtils.serviceWorkersTestingEnabled;
   },
 
   /**
+   * Return whether service workers are being force to always update on
+   * registration.
+   */
+  _getForceServiceWorkersUpdateOnRegistration: function() {
+    if (!this.docShell) {
+      // The tab is already closed.
+      return null;
+    }
+
+    let windowUtils = this.window.QueryInterface(Ci.nsIInterfaceRequestor)
+                                 .getInterface(Ci.nsIDOMWindowUtils);
+    return windowUtils.forceServiceWorkerUpdateOnRegistration;
+  },
+
+  /**
    * Prepare to enter a nested event loop by disabling debuggee events.
    */
   preNest: function BTA_preNest() {
     if (!this.window) {
       // The tab is already closed.
       return;
     }
     let windowUtils = this.window
