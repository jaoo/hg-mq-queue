# HG changeset patch
# Parent c3f8fae88426c58614e9d5aa1182f773ea897115
# User Jose Antonio Olivera Ortega <josea.olivera@gmail.com>
Bug 1134329 - Service worker install and activate events not fired when updating the service worker javascript file. r=nsm

diff --git a/browser/app/profile/firefox.js b/browser/app/profile/firefox.js
--- a/browser/app/profile/firefox.js
+++ b/browser/app/profile/firefox.js
@@ -1463,16 +1463,19 @@ pref("devtools.performance.ui.flatten-tr
 pref("devtools.performance.ui.show-platform-data", false);
 pref("devtools.performance.ui.show-idle-blocks", true);
 pref("devtools.performance.ui.enable-memory", false);
 pref("devtools.performance.ui.enable-framerate", true);
 
 // The default cache UI setting
 pref("devtools.cache.disabled", false);
 
+// The default service workers UI setting
+pref("devtools.serviceWorkers.testing.enabled", false);
+
 // Enable the Network Monitor
 pref("devtools.netmonitor.enabled", true);
 
 // The default Network Monitor UI settings
 pref("devtools.netmonitor.panes-network-details-width", 550);
 pref("devtools.netmonitor.panes-network-details-height", 450);
 pref("devtools.netmonitor.statistics", true);
 pref("devtools.netmonitor.filters", "[\"all\"]");
diff --git a/browser/devtools/framework/test/browser.ini b/browser/devtools/framework/test/browser.ini
--- a/browser/devtools/framework/test/browser.ini
+++ b/browser/devtools/framework/test/browser.ini
@@ -26,16 +26,18 @@ support-files =
 [browser_toolbox_options_devedition.js]
 [browser_toolbox_options_disable_buttons.js]
 [browser_toolbox_options_disable_cache-01.js]
 skip-if = e10s # Bug 1030318
 [browser_toolbox_options_disable_cache-02.js]
 skip-if = e10s # Bug 1030318
 [browser_toolbox_options_disable_js.js]
 skip-if = e10s # Bug 1030318
+[browser_toolbox_options_enable_serviceworkers_testing.js]
+skip-if = e10s # Bug 1030318
 # [browser_toolbox_raise.js] # Bug 962258
 # skip-if = os == "win"
 [browser_toolbox_ready.js]
 [browser_toolbox_select_event.js]
 skip-if = e10s # Bug 1069044 - destroyInspector may hang during shutdown
 [browser_toolbox_sidebar.js]
 [browser_toolbox_sidebar_events.js]
 [browser_toolbox_sidebar_existing_tabs.js]
diff --git a/browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing.js b/browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing.js
@@ -0,0 +1,82 @@
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+// Test that enabling Service Workers testing option enables the
+// mServiceWorkersTestingEnabled attribute added to nsPIDOMWindow.
+
+const ELEMENT_ID = "devtools-enable-serviceWorkersTesting";
+
+let target;
+let toolbox;
+
+function test() {
+  gBrowser.selectedTab = gBrowser.addTab();
+  target = TargetFactory.forTab(gBrowser.selectedTab);
+
+  gBrowser.selectedBrowser.addEventListener("load", function onLoad(evt) {
+    gBrowser.selectedBrowser.removeEventListener(evt.type, onLoad, true);
+    gDevTools.showToolbox(target).then(testSelectTool);
+  }, true);
+}
+
+function testSelectTool(aToolbox) {
+  toolbox = aToolbox;
+  toolbox.once("options-selected", testServiceWorkersTestingStatus);
+  toolbox.selectTool("options");
+}
+
+function testServiceWorkersTestingStatus(event, tool, secondPass) {
+  info("Testing service workers testing status");
+
+  let panel = toolbox.getCurrentPanel();
+  let cbx = panel.panelDoc.getElementById(ELEMENT_ID);
+  let windowUtils = target.window.QueryInterface(Ci.nsIInterfaceRequestor)
+                                 .getInterface(Ci.nsIDOMWindowUtils);
+
+  is(cbx.checked,
+     windowUtils.serviceWorkersTestingEnabled,
+     "Checkbox status matches service workers testing flag");
+
+  if (secondPass) {
+    finishUp();
+  } else {
+    toggleServiceWorkersTestingCheckbox().then(function() {
+      testServiceWorkersTestingStatus(null, null, true);
+    });
+  }
+}
+
+function toggleServiceWorkersTestingCheckbox() {
+  let deferred = promise.defer();
+
+  let panel = toolbox.getCurrentPanel();
+  let cbx = panel.panelDoc.getElementById(ELEMENT_ID);
+
+  cbx.scrollIntoView();
+
+  if (cbx.checked) {
+    info("Clearing checkbox to disable service workers testing");
+  } else {
+    info("Checking checkbox to enable service workers testing");
+  }
+
+  gBrowser.selectedBrowser.addEventListener("load", function onLoad(evt) {
+    gBrowser.selectedBrowser.removeEventListener(evt.type, onLoad, true);
+    deferred.resolve();
+  }, true);
+
+  cbx.click();
+
+  let mm = getFrameScript();
+  mm.sendAsyncMessage("devtools:test:reload");
+
+  return deferred.promise;
+}
+
+function finishUp() {
+  toolbox.destroy().then(function() {
+    gBrowser.removeCurrentTab();
+    target = toolbox = null;
+    finish();
+  });
+}
diff --git a/browser/devtools/framework/toolbox-options.js b/browser/devtools/framework/toolbox-options.js
--- a/browser/devtools/framework/toolbox-options.js
+++ b/browser/devtools/framework/toolbox-options.js
@@ -365,17 +365,17 @@ OptionsPanel.prototype = {
       menulist.addEventListener("command", function() {
         setPrefAndEmit(this.getAttribute("data-pref"), this.value);
       }.bind(menulist));
     }
 
     if (this.target.activeTab) {
       this.target.client.attachTab(this.target.activeTab._actor, (response) => {
         this._origJavascriptEnabled = response.javascriptEnabled;
-        this.disableJSNode.checked = !this._origJavascriptEnabled
+        this.disableJSNode.checked = !this._origJavascriptEnabled;
         this.disableJSNode.addEventListener("click", this._disableJSClicked, false);
       });
     } else {
       this.disableJSNode.hidden = true;
     }
   },
 
   updateDefaultTheme: function() {
diff --git a/browser/devtools/framework/toolbox-options.xul b/browser/devtools/framework/toolbox-options.xul
--- a/browser/devtools/framework/toolbox-options.xul
+++ b/browser/devtools/framework/toolbox-options.xul
@@ -143,16 +143,20 @@
         <vbox id="context-options" class="options-groupbox">
           <checkbox id="devtools-disable-cache"
                     label="&options.disableCache.label2;"
                     tooltiptext="&options.disableCache.tooltip2;"
                     data-pref="devtools.cache.disabled"/>
           <checkbox id="devtools-disable-javascript"
                     label="&options.disableJavaScript.label;"
                     tooltiptext="&options.disableJavaScript.tooltip;"/>
+          <checkbox id="devtools-enable-serviceWorkersTesting"
+                    label="&options.enableServiceWorkersTesting.label;"
+                    tooltiptext="&options.enableServiceWorkersTesting.tooltip;"
+                    data-pref="devtools.serviceWorkers.testing.enabled"/>
           <hbox class="hidden-labels-box">
             <checkbox label="&options.enableChrome.label5;"
                       tooltiptext="&options.enableChrome.tooltip3;"
                       data-pref="devtools.chrome.enabled"/>
           </hbox>
           <hbox class="hidden-labels-box">
             <checkbox label="&options.enableRemote.label3;"
                       tooltiptext="&options.enableRemote.tooltip;"
diff --git a/browser/devtools/framework/toolbox.js b/browser/devtools/framework/toolbox.js
--- a/browser/devtools/framework/toolbox.js
+++ b/browser/devtools/framework/toolbox.js
@@ -311,16 +311,17 @@ Toolbox.prototype = {
 
         let framesMenu = this.doc.getElementById("command-button-frames");
         framesMenu.addEventListener("command", this.selectFrame, true);
 
         this._buildDockButtons();
         this._buildOptions();
         this._buildTabs();
         this._applyCacheSettings();
+        this._applyServiceWorkersTestingSettings();
         this._addKeysToWindow();
         this._addReloadKeys();
         this._addHostListeners();
         if (this._hostOptions && this._hostOptions.zoom === false) {
           this._disableZoomKeys();
         } else {
           this._addZoomKeys();
           this._loadInitialZoom();
@@ -354,17 +355,17 @@ Toolbox.prototype = {
             deferred.resolve();
           }, deferred.reject);
         });
       };
 
       // Load the toolbox-level actor fronts and utilities now
       this._target.makeRemote().then(() => {
         iframe.setAttribute("src", this._URL);
-        iframe.setAttribute("aria-label", toolboxStrings("toolbox.label"))
+        iframe.setAttribute("aria-label", toolboxStrings("toolbox.label"));
         let domHelper = new DOMHelpers(iframe.contentWindow);
         domHelper.onceDOMReady(domReady);
       });
 
       return deferred.promise;
     }).then(null, console.error.bind(console));
   },
 
@@ -376,18 +377,23 @@ Toolbox.prototype = {
    * @param  {Object} data
    *         {
    *           newValue: The new value
    *           oldValue:  The old value
    *           pref: The name of the preference that has changed
    *         }
    */
   _prefChanged: function(event, data) {
-    if (data.pref === "devtools.cache.disabled") {
+    switch(data.pref) {
+    case "devtools.cache.disabled":
       this._applyCacheSettings();
+      break;
+    case "devtools.serviceWorkers.testing.enabled":
+      this._applyServiceWorkersTestingSettings();
+      break;
     }
   },
 
   _buildOptions: function() {
     let key = this.doc.getElementById("toolbox-options-key");
     key.addEventListener("command", () => {
       this.selectTool("options");
     }, true);
@@ -717,16 +723,32 @@ Toolbox.prototype = {
     let cacheDisabled = Services.prefs.getBoolPref(pref);
 
     if (this.target.activeTab) {
       this.target.activeTab.reconfigure({"cacheDisabled": cacheDisabled});
     }
   },
 
   /**
+   * Apply the current service workers testing setting from
+   * devtools.serviceWorkers.testing.enabled to this toolbox's tab.
+   */
+  _applyServiceWorkersTestingSettings: function() {
+    let pref = "devtools.serviceWorkers.testing.enabled";
+    let serviceWorkersTestingEnabled =
+      Services.prefs.getBoolPref(pref) || false;
+
+    if (this.target.activeTab) {
+      this.target.activeTab.reconfigure({
+        "serviceWorkersTestingEnabled": serviceWorkersTestingEnabled
+      });
+    }
+  },
+
+  /**
    * Setter for the checked state of the picker button in the toolbar
    * @param {Boolean} isChecked
    */
   set pickerButtonChecked(isChecked) {
     if (isChecked) {
       this._pickerButton.setAttribute("checked", "true");
     } else {
       this._pickerButton.removeAttribute("checked");
@@ -1628,20 +1650,23 @@ Toolbox.prototype = {
 
         outstanding.push(panel.destroy());
       } catch (e) {
         // We don't want to stop here if any panel fail to close.
         console.error("Panel " + id + ":", e);
       }
     }
 
-    // Now that we are closing the toolbox we can re-enable JavaScript for the
-    // current tab.
+    // Now that we are closing the toolbox we can re-enable the cache settings
+    // and disable the service workers testing settings for the current tab.
     if (this.target.activeTab) {
-      this.target.activeTab.reconfigure({"cacheDisabled": false});
+      this.target.activeTab.reconfigure({
+        "cacheDisabled": false,
+        "serviceWorkersTestingEnabled": false
+      });
     }
 
     // Destroying the walker and inspector fronts
     outstanding.push(this.destroyInspector().then(() => {
       // Removing buttons
       if (this._pickerButton) {
         this._pickerButton.removeEventListener("command", this._togglePicker, false);
         this._pickerButton = null;
diff --git a/browser/locales/en-US/chrome/browser/devtools/toolbox.dtd b/browser/locales/en-US/chrome/browser/devtools/toolbox.dtd
--- a/browser/locales/en-US/chrome/browser/devtools/toolbox.dtd
+++ b/browser/locales/en-US/chrome/browser/devtools/toolbox.dtd
@@ -88,16 +88,22 @@
 <!ENTITY options.disableJavaScript.tooltip   "Turning this option on will disable JavaScript for the current tab. If the tab or the toolbox is closed then this setting will be forgotten.">
 
 <!-- LOCALIZATION NOTE (options.disableCache.label2,
   -  options.disableCache.tooltip2): This is the options panel label and
   -  tooltip for the checkbox that toggles the cache on or off. -->
 <!ENTITY options.disableCache.label2     "Disable Cache (when toolbox is open)">
 <!ENTITY options.disableCache.tooltip2   "Turning this option on will disable the cache for all tabs that have the toolbox open.">
 
+<!-- LOCALIZATION NOTE (options.enableServiceWorkersTesting.label,
+  -  options.enableServiceWorkersTesting.tooltip): This is the options panel label and
+  -  tooltip for the checkbox that toggles the service workers testing features on or off. -->
+<!ENTITY options.enableServiceWorkersTesting.label     "Enable Service Workes testing features (when toolbox is open)">
+<!ENTITY options.enableServiceWorkersTesting.tooltip   "Turning this option on will enable the service workers testing features for all tabs that have the toolbox open.">
+
 <!-- LOCALIZATION NOTE (options.selectDefaultTools.label): This is the label for
   -  the heading of group of checkboxes corresponding to the default developer
   -  tools. -->
 <!ENTITY options.selectDefaultTools.label     "Default Firefox Developer Tools">
 
 <!-- LOCALIZATION NOTE (options.selectAdditionalTools.label): This is the label for
   -  the heading of group of checkboxes corresponding to the developer tools
   -  added by add-ons. This heading is hidden when there is no developer tool
diff --git a/dom/base/nsDOMWindowUtils.cpp b/dom/base/nsDOMWindowUtils.cpp
--- a/dom/base/nsDOMWindowUtils.cpp
+++ b/dom/base/nsDOMWindowUtils.cpp
@@ -3919,16 +3919,42 @@ nsDOMWindowUtils::GetFramesReflowed(uint
   if (!presContext) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   *aResult = presContext->FramesReflowedCount();
   return NS_OK;
 }
 
+NS_IMETHODIMP
+nsDOMWindowUtils::SetServiceWorkersTestingEnabled(bool aEnabled)
+{
+  MOZ_RELEASE_ASSERT(nsContentUtils::IsCallerChrome());
+
+  nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
+  NS_ENSURE_STATE(window);
+
+  window->SetServiceWorkersTestingEnabled(aEnabled);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsDOMWindowUtils::GetServiceWorkersTestingEnabled(bool *aEnabled)
+{
+  MOZ_RELEASE_ASSERT(nsContentUtils::IsCallerChrome());
+
+  nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
+  NS_ENSURE_STATE(window);
+
+  *aEnabled = window->GetServiceWorkersTestingEnabled();
+
+  return NS_OK;
+}
+
 NS_INTERFACE_MAP_BEGIN(nsTranslationNodeList)
   NS_INTERFACE_MAP_ENTRY(nsISupports)
   NS_INTERFACE_MAP_ENTRY(nsITranslationNodeList)
 NS_INTERFACE_MAP_END
 
 NS_IMPL_ADDREF(nsTranslationNodeList)
 NS_IMPL_RELEASE(nsTranslationNodeList)
 
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -580,17 +580,17 @@ nsPIDOMWindow::nsPIDOMWindow(nsPIDOMWind
   mMayHaveMouseEnterLeaveEventListener(false),
   mMayHavePointerEnterLeaveEventListener(false),
   mIsModalContentWindow(false),
   mIsActive(false), mIsBackground(false),
   mAudioMuted(false), mAudioVolume(1.0),
   mInnerWindow(nullptr), mOuterWindow(aOuterWindow),
   // Make sure no actual window ends up with mWindowID == 0
   mWindowID(NextWindowID()), mHasNotifiedGlobalCreated(false),
-  mMarkedCCGeneration(0)
+  mMarkedCCGeneration(0), mServiceWorkersTestingEnabled(false)
  {}
 
 nsPIDOMWindow::~nsPIDOMWindow() {}
 
 // DialogValueHolder CC goop.
 NS_IMPL_CYCLE_COLLECTION(DialogValueHolder, mValue)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(DialogValueHolder)
diff --git a/dom/base/nsPIDOMWindow.h b/dom/base/nsPIDOMWindow.h
--- a/dom/base/nsPIDOMWindow.h
+++ b/dom/base/nsPIDOMWindow.h
@@ -173,16 +173,28 @@ public:
   bool GetAudioMuted() const;
   void SetAudioMuted(bool aMuted);
 
   float GetAudioVolume() const;
   nsresult SetAudioVolume(float aVolume);
 
   float GetAudioGlobalVolume();
 
+  virtual void SetServiceWorkersTestingEnabled(bool aEnabled)
+  {
+    MOZ_ASSERT(IsOuterWindow());
+    mServiceWorkersTestingEnabled = aEnabled;
+  }
+
+  bool GetServiceWorkersTestingEnabled()
+  {
+    MOZ_ASSERT(IsOuterWindow());
+    return mServiceWorkersTestingEnabled;
+  }
+
 protected:
   // Lazily instantiate an about:blank document if necessary, and if
   // we have what it takes to do so.
   void MaybeCreateDoc();
 
   float GetAudioGlobalVolumeInternal(float aVolume);
   void RefreshMediaElements();
 
@@ -838,16 +850,20 @@ protected:
   // this window.
   uint64_t mWindowID;
 
   // This is only used by the inner window. Set to true once we've sent
   // the (chrome|content)-document-global-created notification.
   bool mHasNotifiedGlobalCreated;
 
   uint32_t mMarkedCCGeneration;
+
+  // Let the service workers plumbing know that some feature are enabled while
+  // testing.
+  bool mServiceWorkersTestingEnabled;
 };
 
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsPIDOMWindow, NS_PIDOMWINDOW_IID)
 
 #ifdef MOZILLA_INTERNAL_API
 PopupControlState
 PushPopupControlState(PopupControlState aState, bool aForce);
diff --git a/dom/interfaces/base/nsIDOMWindowUtils.idl b/dom/interfaces/base/nsIDOMWindowUtils.idl
--- a/dom/interfaces/base/nsIDOMWindowUtils.idl
+++ b/dom/interfaces/base/nsIDOMWindowUtils.idl
@@ -45,17 +45,17 @@ interface nsIFile;
 interface nsIDOMClientRect;
 interface nsIURI;
 interface nsIDOMEventTarget;
 interface nsIRunnable;
 interface nsITranslationNodeList;
 interface nsIJSRAIIHelper;
 interface nsIContentPermissionRequest;
 
-[scriptable, uuid(6eaf87a1-b252-4c4e-a2fc-318120680335)]
+[scriptable, uuid(7f2f44ab-2857-4cc2-8c9d-3d9816f5a4d6)]
 interface nsIDOMWindowUtils : nsISupports {
 
   /**
    * Image animation mode of the window. When this attribute's value
    * is changed, the implementation should set all images in the window
    * to the given value. That is, when set to kDontAnimMode, all images
    * will stop animating. The attribute's value must be one of the
    * animationMode values from imgIContainer.
@@ -1736,16 +1736,21 @@ interface nsIDOMWindowUtils : nsISupport
    * Controls the amount of chrome that should be visible on each side of
    * the window. Works like the chromemargin xul:window attribute.
    * This should only be used with non-XUL windows.
    */
   void setChromeMargin(in int32_t aTop,
                        in int32_t aRight,
                        in int32_t aBottom,
                        in int32_t aLeft);
+
+  /**
+   * Enable some service workers testing features.
+   */
+  attribute boolean serviceWorkersTestingEnabled;
 };
 
 [scriptable, uuid(c694e359-7227-4392-a138-33c0cc1f15a6)]
 interface nsITranslationNodeList : nsISupports {
   readonly attribute unsigned long length;
   nsIDOMNode item(in unsigned long index);
 
   // A translation root is a block element, or an inline element
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -447,16 +447,17 @@ class ServiceWorkerRegisterJob MOZ_FINAL
 {
   friend class ContinueInstallTask;
 
   nsCString mScope;
   nsCString mScriptSpec;
   nsRefPtr<ServiceWorkerRegistrationInfo> mRegistration;
   nsRefPtr<ServiceWorkerUpdateFinishCallback> mCallback;
   nsCOMPtr<nsIPrincipal> mPrincipal;
+  bool mAlwaysUpdate;
 
   ~ServiceWorkerRegisterJob()
   { }
 
   enum
   {
     REGISTER_JOB = 0,
     UPDATE_JOB = 1,
@@ -465,22 +466,24 @@ class ServiceWorkerRegisterJob MOZ_FINAL
 public:
   NS_DECL_ISUPPORTS
 
   // [[Register]]
   ServiceWorkerRegisterJob(ServiceWorkerJobQueue* aQueue,
                            const nsCString& aScope,
                            const nsCString& aScriptSpec,
                            ServiceWorkerUpdateFinishCallback* aCallback,
-                           nsIPrincipal* aPrincipal)
+                           nsIPrincipal* aPrincipal,
+                           bool aAlwaysUpdate)
     : ServiceWorkerJob(aQueue)
     , mScope(aScope)
     , mScriptSpec(aScriptSpec)
     , mCallback(aCallback)
     , mPrincipal(aPrincipal)
+    , mAlwaysUpdate(aAlwaysUpdate)
     , mJobType(REGISTER_JOB)
   { }
 
   // [[Update]]
   ServiceWorkerRegisterJob(ServiceWorkerJobQueue* aQueue,
                            ServiceWorkerRegistrationInfo* aRegistration,
                            ServiceWorkerUpdateFinishCallback* aCallback)
     : ServiceWorkerJob(aQueue)
@@ -501,18 +504,25 @@ public:
       swm->AppendPendingOperation(runnable);
       return;
     }
 
     if (mJobType == REGISTER_JOB) {
       mRegistration = swm->GetRegistration(mScope);
 
       if (mRegistration) {
+        bool alwaysUpdate = false;
+        if (mAlwaysUpdate ||
+	    Preferences::GetBool("dom.serviceWorkers.testing.enabled")) {
+          alwaysUpdate = true;
+        }
+
         nsRefPtr<ServiceWorkerInfo> newest = mRegistration->Newest();
-        if (newest && mScriptSpec.Equals(newest->ScriptSpec()) &&
+        if (!alwaysUpdate && newest &&
+            mScriptSpec.Equals(newest->ScriptSpec()) &&
             mScriptSpec.Equals(mRegistration->mScriptSpec)) {
           mRegistration->mPendingUninstall = false;
           Succeed();
           Done(NS_OK);
           return;
         }
       } else {
         mRegistration = swm->CreateNewRegistration(mScope, mPrincipal);
@@ -827,16 +837,20 @@ ServiceWorkerManager::Register(nsIDOMWin
 
   nsCOMPtr<nsIDocument> doc = window->GetExtantDoc();
   if (!doc) {
     return NS_ERROR_FAILURE;
   }
 
   nsCOMPtr<nsIURI> documentURI = doc->GetBaseURI();
 
+  nsCOMPtr<nsPIDOMWindow> outerWindow = window->GetOuterWindow();
+  bool serviceWorkersTestingEnabled =
+    outerWindow->GetServiceWorkersTestingEnabled();
+  
   bool authenticatedOrigin = false;
   // FIXME(nsm): Bug 1003991. Disable check when devtools are open.
   if (Preferences::GetBool("dom.serviceWorkers.testing.enabled")) {
     authenticatedOrigin = true;
   }
 
   nsresult rv;
   if (!authenticatedOrigin) {
@@ -932,17 +946,22 @@ ServiceWorkerManager::Register(nsIDOMWin
 
   ServiceWorkerJobQueue* queue = GetOrCreateJobQueue(cleanedScope);
   MOZ_ASSERT(queue);
 
   nsRefPtr<ServiceWorkerResolveWindowPromiseOnUpdateCallback> cb =
     new ServiceWorkerResolveWindowPromiseOnUpdateCallback(window, promise);
 
   nsRefPtr<ServiceWorkerRegisterJob> job =
-    new ServiceWorkerRegisterJob(queue, cleanedScope, spec, cb, documentPrincipal);
+    new ServiceWorkerRegisterJob(queue,
+                                 cleanedScope,
+                                 spec,
+                                 cb,
+                                 documentPrincipal,
+                                 serviceWorkersTestingEnabled);
   queue->Append(job);
 
   promise.forget(aPromise);
   return NS_OK;
 }
 
 void
 ServiceWorkerManager::AppendPendingOperation(ServiceWorkerJobQueue* aQueue,
diff --git a/modules/libpref/init/all.js b/modules/libpref/init/all.js
--- a/modules/libpref/init/all.js
+++ b/modules/libpref/init/all.js
@@ -133,16 +133,19 @@ pref("dom.workers.maxPerDomain", 20);
 pref("dom.workers.sharedWorkers.enabled", true);
 
 // WebSocket in workers are disabled by default.
 pref("dom.workers.websocket.enabled", true);
 
 // Service workers
 pref("dom.serviceWorkers.enabled", false);
 
+// Service workers testing
+pref("dom.serviceWorkers.testing.enabled", false);
+
 // Whether nonzero values can be returned from performance.timing.*
 pref("dom.enable_performance", true);
 
 // Whether resource timing will be gathered and returned by performance.GetEntries*
 pref("dom.enable_resource_timing", true);
 
 // Enable high-resolution timing markers for users
 pref("dom.enable_user_timing", true);
diff --git a/toolkit/devtools/server/actors/webbrowser.js b/toolkit/devtools/server/actors/webbrowser.js
--- a/toolkit/devtools/server/actors/webbrowser.js
+++ b/toolkit/devtools/server/actors/webbrowser.js
@@ -1219,37 +1219,44 @@ TabActor.prototype = {
   },
 
   /**
    * Reconfigure options.
    */
   onReconfigure: function (aRequest) {
     let options = aRequest.options || {};
 
-    this._toggleJsOrCache(options);
+    this._toggleDevtoolsSettings(options);
     return {};
   },
 
   /**
-   * Handle logic to enable/disable JS/cache.
+   * Handle logic to enable/disable JS/cache/Service Worker testing.
    */
-  _toggleJsOrCache: function(options) {
+  _toggleDevtoolsSettings: function(options) {
     // Wait a tick so that the response packet can be dispatched before the
     // subsequent navigation event packet.
     let reload = false;
 
     if (typeof options.javascriptEnabled !== "undefined" &&
         options.javascriptEnabled !== this._getJavascriptEnabled()) {
       this._setJavascriptEnabled(options.javascriptEnabled);
       reload = true;
     }
     if (typeof options.cacheDisabled !== "undefined" &&
         options.cacheDisabled !== this._getCacheDisabled()) {
       this._setCacheDisabled(options.cacheDisabled);
     }
+    if ((typeof options.serviceWorkersTestingEnabled !== "undefined") &&
+        (options.serviceWorkersTestingEnabled !==
+         this._getServiceWorkersTestingEnabled())) {
+      this._setServiceWorkersTestingEnabled(
+        options.serviceWorkersTestingEnabled
+      );
+    }
 
     // Reload if:
     //  - there's an explicit `performReload` flag and it's true
     //  - there's no `performReload` flag, but it makes sense to do so
     let hasExplicitReloadFlag = "performReload" in options;
     if ((hasExplicitReloadFlag && options.performReload) ||
        (!hasExplicitReloadFlag && reload)) {
       this.onReload();
@@ -1274,16 +1281,30 @@ TabActor.prototype = {
    */
   _setJavascriptEnabled: function(allow) {
     if (this.docShell) {
       this.docShell.allowJavascript = allow;
     }
   },
 
   /**
+   * Disable or enable the service workers testing features.
+   */
+  _setServiceWorkersTestingEnabled: function(enabled) {
+    if (!this.docShell) {
+      // The tab is already closed.
+      return null;
+    }
+
+    let windowUtils = this.window.QueryInterface(Ci.nsIInterfaceRequestor)
+                                 .getInterface(Ci.nsIDOMWindowUtils);
+    windowUtils.serviceWorkersTestingEnabled = enabled;
+  },
+
+  /**
    * Return cache allowed status.
    */
   _getCacheDisabled: function() {
     if (!this.docShell) {
       // The tab is already closed.
       return null;
     }
 
@@ -1300,16 +1321,30 @@ TabActor.prototype = {
       // The tab is already closed.
       return null;
     }
 
     return this.docShell.allowJavascript;
   },
 
   /**
+   * Return service workers testing allowed status.
+   */
+  _getServiceWorkersTestingEnabled: function() {
+    if (!this.docShell) {
+      // The tab is already closed.
+      return null;
+    }
+
+    let windowUtils = this.window.QueryInterface(Ci.nsIInterfaceRequestor)
+                                 .getInterface(Ci.nsIDOMWindowUtils);
+    return windowUtils.serviceWorkersTestingEnabled;
+  },
+  
+  /**
    * Prepare to enter a nested event loop by disabling debuggee events.
    */
   preNest: function BTA_preNest() {
     if (!this.window) {
       // The tab is already closed.
       return;
     }
     let windowUtils = this.window
