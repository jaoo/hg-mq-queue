# HG changeset patch
# Parent ab0490972e1e47a356c3fc2f9e749a2d77a9739b
# User Jose Antonio Olivera Ortega <josea.olivera@gmail.com>
Bug 1134329 - Service worker install and activate events not fired when updating the service worker javascript file. r=nsm,miker

diff --git a/browser/app/profile/firefox.js b/browser/app/profile/firefox.js
--- a/browser/app/profile/firefox.js
+++ b/browser/app/profile/firefox.js
@@ -1448,16 +1448,19 @@ pref("devtools.performance.ui.enable-fra
 pref("devtools.performance.ui.show-jit-optimizations", false);
 
 // The default cache UI setting
 pref("devtools.cache.disabled", false);
 
 // The default service workers UI setting
 pref("devtools.serviceWorkers.testing.enabled", false);
 
+// Force update service worker on registration flag.
+pref("devtools.serviceWorkers.forceUpdateOnRegistration", false);
+
 // Enable the Network Monitor
 pref("devtools.netmonitor.enabled", true);
 
 // The default Network Monitor UI settings
 pref("devtools.netmonitor.panes-network-details-width", 550);
 pref("devtools.netmonitor.panes-network-details-height", 450);
 pref("devtools.netmonitor.statistics", true);
 pref("devtools.netmonitor.filters", "[\"all\"]");
diff --git a/browser/devtools/framework/test/browser.ini b/browser/devtools/framework/test/browser.ini
--- a/browser/devtools/framework/test/browser.ini
+++ b/browser/devtools/framework/test/browser.ini
@@ -4,18 +4,18 @@ subsuite = devtools
 support-files =
   browser_toolbox_options_disable_js.html
   browser_toolbox_options_disable_js_iframe.html
   browser_toolbox_options_disable_cache.sjs
   browser_toolbox_sidebar_tool.xul
   head.js
   helper_disable_cache.js
   doc_theme.css
-  browser_toolbox_options_enable_serviceworkers_testing.html
-  serviceworker.js
+  browser_toolbox_options_serviceworkers.html
+  serviceworker.sjs
 
 [browser_devtools_api.js]
 [browser_devtools_api_destroy.js]
 [browser_dynamic_tool_enabling.js]
 [browser_keybindings.js]
 [browser_new_activation_workflow.js]
 [browser_target_events.js]
 [browser_target_remote.js]
@@ -49,14 +49,14 @@ skip-if = e10s # Bug 1069044 - destroyIn
 [browser_toolbox_transport_events.js]
 [browser_toolbox_window_reload_target.js]
 [browser_toolbox_window_shortcuts.js]
 skip-if = os == "mac" && os_version == "10.8" || os == "win" && os_version == "5.1" # Bug 851129 - Re-enable browser_toolbox_window_shortcuts.js test after leaks are fixed
 [browser_toolbox_window_title_changes.js]
 [browser_toolbox_zoom.js]
 [browser_toolbox_custom_host.js]
 [browser_toolbox_theme_registration.js]
-[browser_toolbox_options_enable_serviceworkers_testing.js]
+[browser_toolbox_options_serviceworkers.js]
 skip-if = e10s # Bug 1030318
 
 # We want this test to run for mochitest-dt as well, so we include it here:
 [../../../base/content/test/general/browser_parsable_css.js]
 
diff --git a/browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing.html b/browser/devtools/framework/test/browser_toolbox_options_serviceworkers.html
rename from browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing.html
rename to browser/devtools/framework/test/browser_toolbox_options_serviceworkers.html
--- a/browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing.html
+++ b/browser/devtools/framework/test/browser_toolbox_options_serviceworkers.html
@@ -17,17 +17,17 @@
     </style>
     <script type="application/javascript;version=1.8">
       function log(msg) {
         var output = document.getElementById("output");
 
         output.innerHTML = msg;
       }
 
-      navigator.serviceWorker.register("serviceworker.js").then(
+      navigator.serviceWorker.register("serviceworker.sjs").then(
         swr => {
           var msg = "";
           var button = document.getElementById("button");
           if (swr.installing) {
             msg += "Installing worker/";
           }
           if (swr.waiting) {
             msg += "Waiting worker/";
diff --git a/browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing.js b/browser/devtools/framework/test/browser_toolbox_options_serviceworkers.js
rename from browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing.js
rename to browser/devtools/framework/test/browser_toolbox_options_serviceworkers.js
--- a/browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing.js
+++ b/browser/devtools/framework/test/browser_toolbox_options_serviceworkers.js
@@ -1,18 +1,23 @@
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Test that enabling Service Workers testing option enables the
-// mServiceWorkersTestingEnabled attribute added to nsPIDOMWindow.
+// mServiceWorkersTestingEnabled attribute added to nsPIDOMWindow. It also
+// tests that toggling on the force service worker update on registration
+// checkbox the service worker is always updated on registration.
 
 const TEST_URI = URL_ROOT +
-                 "browser_toolbox_options_enable_serviceworkers_testing.html";
+                 "browser_toolbox_options_serviceworkers.html";
 
-const ELEMENT_ID = "devtools-enable-serviceWorkersTesting";
+const TESTING_ELEMENT_ID =
+  "devtools-enable-serviceWorkersTesting";
+const FORCEUPDATE_ELEMENT_ID =
+  "devtools-serviceWorkers-forceUpdateOnRegistration";
 
 let toolbox;
 let doc;
 
 function test() {
   // Note: Pref dom.serviceWorkers.testing.enabled is false since we are testing
   // the same capabilities are enabled with the devtool pref.
   SpecialPowers.pushPrefEnv({"set": [
@@ -59,66 +64,132 @@ function testRegisterFails() {
 
   button.addEventListener('click', function onClick() {
     button.removeEventListener('click', onClick);
     doTheCheck();
   });
 }
 
 function testRegisterInstallingWorker() {
-  toggleServiceWorkersTestingCheckbox().then(() => {
+  toggleCheckbox(TESTING_ELEMENT_ID).then(() => {
     let output = doc.getElementById("output");
     let button = doc.getElementById("button");
 
     function doTheCheck() {
       info("Testing it registers correctly and there is an installing worker");
       is(output.textContent,
          "Installing worker/",
          "Installing worker expected");
-      toggleServiceWorkersTestingCheckbox().then(finishUp);
+      testRegisterActiveWorker();
     }
 
     if (output.textContent !== "No output") {
       doTheCheck();
     }
 
     button.addEventListener('click', function onClick() {
       button.removeEventListener('click', onClick);
       doTheCheck();
     });
   });
 }
 
-function toggleServiceWorkersTestingCheckbox() {
+function testRegisterActiveWorker() {
+  toggleCheckbox(FORCEUPDATE_ELEMENT_ID).then(() => {
+    let output = doc.getElementById("output");
+    let button = doc.getElementById("button");
+
+    function doTheCheck() {
+      info("Testing it registers correctly and there are both an installing " +
+           "and an active worker");
+      is(output.textContent,
+         "Installing worker/Active worker/",
+         "Installing and active worker expected");
+      testRegisterWaitingWorker();
+    }
+
+    if (output.textContent !== "No output") {
+      doTheCheck();
+    }
+    button.addEventListener('click', function onClick() {
+      button.addEventListener('click', onClick);
+      doTheCheck();
+    });
+  });
+}
+
+function testRegisterWaitingWorker() {
+  reload().then(() => {
+    let output = doc.getElementById("output");
+    let button = doc.getElementById("button");
+
+    function doTheCheck() {
+      info("Testing it registers correctly and there are three worker: an " +
+           " installing, a waiting and active worker");
+      is(output.textContent,
+         "Installing worker/Waiting worker/Active worker/",
+         "Installing, waiting and active worker expected");
+      toggleCheckbox(FORCEUPDATE_ELEMENT_ID).then(() => {
+        toggleCheckbox(TESTING_ELEMENT_ID).then(finishUp);
+      });
+    }
+
+    if (output.textContent !== "No output") {
+      doTheCheck();
+    }
+
+    button.addEventListener('click', function onClick() {
+      button.addEventListener('click', onClick);
+      doTheCheck();
+    });
+  });
+}
+
+function toggleCheckbox(elementId) {
   let deferred = promise.defer();
 
   let panel = toolbox.getCurrentPanel();
-  let cbx = panel.panelDoc.getElementById(ELEMENT_ID);
+  let cbx = panel.panelDoc.getElementById(elementId);
 
   cbx.scrollIntoView();
 
   if (cbx.checked) {
-    info("Clearing checkbox to disable service workers testing");
+    info("Clearing " + elementId + " checkbox");
   } else {
-    info("Checking checkbox to enable service workers testing");
+    info("Checking " + elementId + " checkbox");
   }
 
   gBrowser.selectedBrowser.addEventListener("load", function onLoad(evt) {
     gBrowser.selectedBrowser.removeEventListener(evt.type, onLoad, true);
     doc = content.document;
     deferred.resolve();
   }, true);
 
   cbx.click();
 
   let mm = getFrameScript();
   mm.sendAsyncMessage("devtools:test:reload");
 
   return deferred.promise;
 }
 
+function reload() {
+  let deferred = promise.defer();
+
+  gBrowser.selectedBrowser.addEventListener("load", function onLoad(evt) {
+    gBrowser.selectedBrowser.removeEventListener(evt.type, onLoad, true);
+    doc = content.document;
+    deferred.resolve();
+  }, true);
+
+  let mm = getFrameScript();
+  mm.sendAsyncMessage("devtools:test:reload");
+
+  return deferred.promise;
+}
+
 function finishUp() {
   toolbox.destroy().then(function() {
     gBrowser.removeCurrentTab();
     toolbox = doc = null;
     finish();
   });
 }
diff --git a/browser/devtools/framework/test/serviceworker.js b/browser/devtools/framework/test/serviceworker.sjs
rename from browser/devtools/framework/test/serviceworker.js
rename to browser/devtools/framework/test/serviceworker.sjs
--- a/browser/devtools/framework/test/serviceworker.js
+++ b/browser/devtools/framework/test/serviceworker.sjs
@@ -1,1 +1,41 @@
-// empty service worker, always succeed!
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+// For bug 1134329 we need to test that several calls to
+// navigator.serviceWorker.register() with the same script URL with the
+// devtools 'force update' pref set, skip [[Register]] step 4.2.2.1 and the
+// update is done. Byte-for-byte equal scripts will abort the update so this
+// server-side JavaScript file will return slightly different 'service worker
+// scripts' on each call.
+
+function handleRequest(request, response) {
+  // These are the different service worker scripts we will return. The order
+  // does not really matter but the comment in them gives us an idea about what
+  // script will be use for each test. The goal is the script we return differs
+  // byte-for-byte from the previously script returned.
+  let serviceWorkers = [
+    "// empty service worker for testing https only restriction",
+    "// empty service worker for testing https only restriction",
+    "// empty service worker for testing installing worker",
+    "// empty service worker for testing installing worker",
+    "// empty service worker for testing active worker",
+    "// empty service worker for testing active worker",
+    "// empty service worker for testing waiting worker",
+    "// empty service worker for testing waiting worker"
+  ];
+  let index = parseInt(getState("index")) || 0;
+
+  // This server-side JavaScript file will be requested to return more service
+  // worker scritps than the ones we defined above. This is because while
+  // clearing the pref in the devtool option panel the tab is reloaded. So let's
+  // respond with a 500 error code rather than empty service worker.
+  if (index < serviceWorkers.length) {
+    response.write(serviceWorkers[index]);
+    dump('Returns ' + serviceWorkers[index] + '\n');
+    index++;
+    setState("index", index.toString());
+  } else {
+    dump('Returns error 500 KO\n');
+    response.setStatusLine(request.httpVersion, 500, "K0");
+  }
+}
diff --git a/browser/devtools/framework/toolbox-options.xul b/browser/devtools/framework/toolbox-options.xul
--- a/browser/devtools/framework/toolbox-options.xul
+++ b/browser/devtools/framework/toolbox-options.xul
@@ -144,16 +144,20 @@
                     data-pref="devtools.cache.disabled"/>
           <checkbox id="devtools-disable-javascript"
                     label="&options.disableJavaScript.label;"
                     tooltiptext="&options.disableJavaScript.tooltip;"/>
           <checkbox id="devtools-enable-serviceWorkersTesting"
                     label="&options.enableServiceWorkersTesting.label;"
                     tooltiptext="&options.enableServiceWorkersTesting.tooltip;"
                     data-pref="devtools.serviceWorkers.testing.enabled"/>
+          <checkbox id="devtools-serviceWorkers-forceUpdateOnRegistration"
+                    label="&options.serviceWorkersForceUpdateOnRegistration.label;"
+                    tooltiptext="&options.serviceWorkersForceUpdateOnRegistration.tooltip;"
+                    data-pref="devtools.serviceWorkers.forceUpdateOnRegistration"/>
           <hbox class="hidden-labels-box">
             <checkbox label="&options.enableChrome.label5;"
                       tooltiptext="&options.enableChrome.tooltip3;"
                       data-pref="devtools.chrome.enabled"/>
           </hbox>
           <hbox class="hidden-labels-box">
             <checkbox label="&options.enableRemote.label3;"
                       tooltiptext="&options.enableRemote.tooltip;"
diff --git a/browser/devtools/framework/toolbox.js b/browser/devtools/framework/toolbox.js
--- a/browser/devtools/framework/toolbox.js
+++ b/browser/devtools/framework/toolbox.js
@@ -329,16 +329,17 @@ Toolbox.prototype = {
         let framesMenu = this.doc.getElementById("command-button-frames");
         framesMenu.addEventListener("command", this.selectFrame, true);
 
         this._buildDockButtons();
         this._buildOptions();
         this._buildTabs();
         this._applyCacheSettings();
         this._applyServiceWorkersTestingSettings();
+        this._applyServiceWorkersForceUpdateOnRegistrationFlag();
         this._addKeysToWindow();
         this._addReloadKeys();
         this._addHostListeners();
         if (this._hostOptions && this._hostOptions.zoom === false) {
           this._disableZoomKeys();
         } else {
           this._addZoomKeys();
           this._loadInitialZoom();
@@ -411,16 +412,19 @@ Toolbox.prototype = {
   _prefChanged: function(event, data) {
     switch(data.pref) {
     case "devtools.cache.disabled":
       this._applyCacheSettings();
       break;
     case "devtools.serviceWorkers.testing.enabled":
       this._applyServiceWorkersTestingSettings();
       break;
+    case "devtools.serviceWorkers.forceUpdateOnRegistration":
+      this._applyServiceWorkersForceUpdateOnRegistrationFlag();
+      break;
     }
   },
 
   _buildOptions: function() {
     let key = this.doc.getElementById("toolbox-options-key");
     key.addEventListener("command", () => {
       this.selectTool("options");
     }, true);
@@ -766,16 +770,33 @@ Toolbox.prototype = {
     if (this.target.activeTab) {
       this.target.activeTab.reconfigure({
         "serviceWorkersTestingEnabled": serviceWorkersTestingEnabled
       });
     }
   },
 
   /**
+   * Apply the current force service worker update on registration flag from
+   * devtools.serviceWorkers.forceUpdateOnRegistration to this toolbox's tab.
+   */
+  _applyServiceWorkersForceUpdateOnRegistrationFlag: function() {
+    let pref = "devtools.serviceWorkers.forceUpdateOnRegistration";
+    let forceServiceWorkersUpdateOnRegistration =
+      Services.prefs.getBoolPref(pref) || false;
+
+    if (this.target.activeTab) {
+      this.target.activeTab.reconfigure({
+        "forceServiceWorkersUpdateOnRegistration":
+        forceServiceWorkersUpdateOnRegistration
+      });
+    }
+  },
+
+  /**
    * Setter for the checked state of the picker button in the toolbar
    * @param {Boolean} isChecked
    */
   set pickerButtonChecked(isChecked) {
     if (isChecked) {
       this._pickerButton.setAttribute("checked", "true");
     } else {
       this._pickerButton.removeAttribute("checked");
@@ -1717,17 +1738,18 @@ Toolbox.prototype = {
       }
     }
 
     // Now that we are closing the toolbox we can re-enable the cache settings
     // and disable the service workers testing settings for the current tab.
     if (this.target.activeTab) {
       this.target.activeTab.reconfigure({
         "cacheDisabled": false,
-        "serviceWorkersTestingEnabled": false
+        "serviceWorkersTestingEnabled": false,
+        "forceServiceWorkersUpdateOnRegistration": false
       });
     }
 
     // Destroying the walker and inspector fronts
     outstanding.push(this.destroyInspector().then(() => {
       // Removing buttons
       if (this._pickerButton) {
         this._pickerButton.removeEventListener("command", this._togglePicker, false);
diff --git a/browser/locales/en-US/chrome/browser/devtools/toolbox.dtd b/browser/locales/en-US/chrome/browser/devtools/toolbox.dtd
--- a/browser/locales/en-US/chrome/browser/devtools/toolbox.dtd
+++ b/browser/locales/en-US/chrome/browser/devtools/toolbox.dtd
@@ -98,16 +98,22 @@
 <!ENTITY options.disableCache.tooltip2   "Turning this option on will disable the cache for all tabs that have the toolbox open.">
 
 <!-- LOCALIZATION NOTE (options.enableServiceWorkersTesting.label,
   -  options.enableServiceWorkersTesting.tooltip): This is the options panel label and
   -  tooltip for the checkbox that toggles the service workers testing features on or off. -->
 <!ENTITY options.enableServiceWorkersTesting.label     "Enable Service Workers testing features (when toolbox is open)">
 <!ENTITY options.enableServiceWorkersTesting.tooltip   "Turning this option on will enable the service workers testing features for all tabs that have the toolbox open.">
 
+<!-- LOCALIZATION NOTE (options.serviceWorkersForceUpdateOnRegistration.label,
+  -  options.serviceWorkersForceUpdateOnRegistration.tooltip): This is the options panel label and
+  -  tooltip for the checkbox that toggles on or off the force update on registration flag for service workers. -->
+<!ENTITY options.serviceWorkersForceUpdateOnRegistration.label     "Force service workers to be update on registration (when toolbox is open)">
+<!ENTITY options.serviceWorkersForceUpdateOnRegistration.tooltip   "Turning this option on will force the update of the service workers on registration for all tabs that have the toolbox open.">
+
 <!-- LOCALIZATION NOTE (options.selectDefaultTools.label): This is the label for
   -  the heading of group of checkboxes corresponding to the default developer
   -  tools. -->
 <!ENTITY options.selectDefaultTools.label     "Default Firefox Developer Tools">
 
 <!-- LOCALIZATION NOTE (options.selectAdditionalTools.label): This is the label for
   -  the heading of group of checkboxes corresponding to the developer tools
   -  added by add-ons. This heading is hidden when there is no developer tool
diff --git a/dom/base/nsDOMWindowUtils.cpp b/dom/base/nsDOMWindowUtils.cpp
--- a/dom/base/nsDOMWindowUtils.cpp
+++ b/dom/base/nsDOMWindowUtils.cpp
@@ -4006,16 +4006,42 @@ nsDOMWindowUtils::GetServiceWorkersTesti
   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
   NS_ENSURE_STATE(window);
 
   *aEnabled = window->GetServiceWorkersTestingEnabled();
 
   return NS_OK;
 }
 
+NS_IMETHODIMP
+nsDOMWindowUtils::SetForceServiceWorkerUpdateOnRegistration(bool aEnabled)
+{
+  MOZ_RELEASE_ASSERT(nsContentUtils::IsCallerChrome());
+
+  nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
+  NS_ENSURE_STATE(window);
+
+  window->SetForceServiceWorkerUpdateOnRegistration(aEnabled);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsDOMWindowUtils::GetForceServiceWorkerUpdateOnRegistration(bool *aEnabled)
+{
+  MOZ_RELEASE_ASSERT(nsContentUtils::IsCallerChrome());
+
+  nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
+  NS_ENSURE_STATE(window);
+
+  *aEnabled = window->GetForceServiceWorkerUpdateOnRegistration();
+
+  return NS_OK;
+}
+
 NS_INTERFACE_MAP_BEGIN(nsTranslationNodeList)
   NS_INTERFACE_MAP_ENTRY(nsISupports)
   NS_INTERFACE_MAP_ENTRY(nsITranslationNodeList)
 NS_INTERFACE_MAP_END
 
 NS_IMPL_ADDREF(nsTranslationNodeList)
 NS_IMPL_RELEASE(nsTranslationNodeList)
 
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -579,17 +579,18 @@ nsPIDOMWindow::nsPIDOMWindow(nsPIDOMWind
   mMayHavePointerEnterLeaveEventListener(false),
   mIsModalContentWindow(false),
   mIsActive(false), mIsBackground(false),
   mAudioMuted(false), mAudioVolume(1.0),
   mDesktopModeViewport(false), mInnerWindow(nullptr),
   mOuterWindow(aOuterWindow),
   // Make sure no actual window ends up with mWindowID == 0
   mWindowID(NextWindowID()), mHasNotifiedGlobalCreated(false),
-  mMarkedCCGeneration(0), mServiceWorkersTestingEnabled(false)
+  mMarkedCCGeneration(0), mServiceWorkersTestingEnabled(false),
+  mForceServiceWorkerUpdateOnRegistration(false)
  {}
 
 nsPIDOMWindow::~nsPIDOMWindow() {}
 
 // DialogValueHolder CC goop.
 NS_IMPL_CYCLE_COLLECTION(DialogValueHolder, mValue)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(DialogValueHolder)
diff --git a/dom/base/nsPIDOMWindow.h b/dom/base/nsPIDOMWindow.h
--- a/dom/base/nsPIDOMWindow.h
+++ b/dom/base/nsPIDOMWindow.h
@@ -195,16 +195,28 @@ public:
   }
 
   bool GetServiceWorkersTestingEnabled()
   {
     MOZ_ASSERT(IsOuterWindow());
     return mServiceWorkersTestingEnabled;
   }
 
+  virtual void SetForceServiceWorkerUpdateOnRegistration(bool aEnabled)
+  {
+    MOZ_ASSERT(IsOuterWindow());
+    mForceServiceWorkerUpdateOnRegistration = aEnabled;
+  }
+
+  bool GetForceServiceWorkerUpdateOnRegistration()
+  {
+    MOZ_ASSERT(IsOuterWindow());
+    return mForceServiceWorkerUpdateOnRegistration;
+  }
+
 protected:
   // Lazily instantiate an about:blank document if necessary, and if
   // we have what it takes to do so.
   void MaybeCreateDoc();
 
   float GetAudioGlobalVolumeInternal(float aVolume);
   void RefreshMediaElements();
 
@@ -824,16 +836,20 @@ protected:
   // the (chrome|content)-document-global-created notification.
   bool mHasNotifiedGlobalCreated;
 
   uint32_t mMarkedCCGeneration;
 
   // Let the service workers plumbing know that some feature are enabled while
   // testing.
   bool mServiceWorkersTestingEnabled;
+
+  // Flag that let the service workers plumbing know service workers will be
+  // always updated on registration.
+  bool mForceServiceWorkerUpdateOnRegistration;
 };
 
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsPIDOMWindow, NS_PIDOMWINDOW_IID)
 
 #ifdef MOZILLA_INTERNAL_API
 PopupControlState
 PushPopupControlState(PopupControlState aState, bool aForce);
diff --git a/dom/interfaces/base/nsIDOMWindowUtils.idl b/dom/interfaces/base/nsIDOMWindowUtils.idl
--- a/dom/interfaces/base/nsIDOMWindowUtils.idl
+++ b/dom/interfaces/base/nsIDOMWindowUtils.idl
@@ -45,17 +45,17 @@ interface nsIFile;
 interface nsIDOMClientRect;
 interface nsIURI;
 interface nsIDOMEventTarget;
 interface nsIRunnable;
 interface nsITranslationNodeList;
 interface nsIJSRAIIHelper;
 interface nsIContentPermissionRequest;
 
-[scriptable, uuid(7f2f44ab-2857-4cc2-8c9d-3d9816f5a4d6)]
+[scriptable, uuid(e97634c8-9abf-4a54-ac72-5c09ef130207)]
 interface nsIDOMWindowUtils : nsISupports {
 
   /**
    * Image animation mode of the window. When this attribute's value
    * is changed, the implementation should set all images in the window
    * to the given value. That is, when set to kDontAnimMode, all images
    * will stop animating. The attribute's value must be one of the
    * animationMode values from imgIContainer.
@@ -1757,16 +1757,22 @@ interface nsIDOMWindowUtils : nsISupport
                        in int32_t aRight,
                        in int32_t aBottom,
                        in int32_t aLeft);
 
   /**
    * Enable some service workers testing features.
    */
   attribute boolean serviceWorkersTestingEnabled;
+
+  /**
+   * Flag that let the service workers plumbing know service workers will be
+   * always updated on registration.
+   */
+  attribute boolean forceServiceWorkerUpdateOnRegistration;
 };
 
 [scriptable, uuid(c694e359-7227-4392-a138-33c0cc1f15a6)]
 interface nsITranslationNodeList : nsISupports {
   readonly attribute unsigned long length;
   nsIDOMNode item(in unsigned long index);
 
   // A translation root is a block element, or an inline element
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -510,16 +510,17 @@ class ServiceWorkerRegisterJob final : p
   friend class ContinueInstallTask;
 
   nsCString mScope;
   nsCString mScriptSpec;
   nsRefPtr<ServiceWorkerRegistrationInfo> mRegistration;
   nsRefPtr<ServiceWorkerUpdateFinishCallback> mCallback;
   nsCOMPtr<nsIPrincipal> mPrincipal;
   nsRefPtr<ServiceWorkerInfo> mUpdateAndInstallInfo;
+  bool mForceUpdate;
 
   ~ServiceWorkerRegisterJob()
   { }
 
   enum
   {
     REGISTER_JOB = 0,
     UPDATE_JOB = 1,
@@ -528,22 +529,24 @@ class ServiceWorkerRegisterJob final : p
 public:
   NS_DECL_ISUPPORTS_INHERITED
 
   // [[Register]]
   ServiceWorkerRegisterJob(ServiceWorkerJobQueue* aQueue,
                            const nsCString& aScope,
                            const nsCString& aScriptSpec,
                            ServiceWorkerUpdateFinishCallback* aCallback,
-                           nsIPrincipal* aPrincipal)
+                           nsIPrincipal* aPrincipal,
+                           bool aForceUpdate)
     : ServiceWorkerJob(aQueue)
     , mScope(aScope)
     , mScriptSpec(aScriptSpec)
     , mCallback(aCallback)
     , mPrincipal(aPrincipal)
+    , mForceUpdate(aForceUpdate)
     , mJobType(REGISTER_JOB)
   { }
 
   // [[Update]]
   ServiceWorkerRegisterJob(ServiceWorkerJobQueue* aQueue,
                            ServiceWorkerRegistrationInfo* aRegistration,
                            ServiceWorkerUpdateFinishCallback* aCallback)
     : ServiceWorkerJob(aQueue)
@@ -565,17 +568,18 @@ public:
       return;
     }
 
     if (mJobType == REGISTER_JOB) {
       mRegistration = swm->GetRegistration(mScope);
 
       if (mRegistration) {
         nsRefPtr<ServiceWorkerInfo> newest = mRegistration->Newest();
-        if (newest && mScriptSpec.Equals(newest->ScriptSpec()) &&
+        if (!mForceUpdate && newest &&
+            mScriptSpec.Equals(newest->ScriptSpec()) &&
             mScriptSpec.Equals(mRegistration->mScriptSpec)) {
           mRegistration->mPendingUninstall = false;
           Succeed();
           Done(NS_OK);
           return;
         }
       } else {
         mRegistration = swm->CreateNewRegistration(mScope, mPrincipal);
@@ -890,16 +894,18 @@ ServiceWorkerManager::Register(nsIDOMWin
   // ServiceWorkers.
   MOZ_ASSERT(!nsContentUtils::IsCallerChrome());
 
   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(aWindow);
 
   nsCOMPtr<nsPIDOMWindow> outerWindow = window->GetOuterWindow();
   bool serviceWorkersTestingEnabled =
     outerWindow->GetServiceWorkersTestingEnabled();
+  bool forceServiceWorkerUpdateOnRegistration =
+    outerWindow->GetForceServiceWorkerUpdateOnRegistration();
 
   nsCOMPtr<nsIDocument> doc = window->GetExtantDoc();
   if (!doc) {
     return NS_ERROR_FAILURE;
   }
 
   nsCOMPtr<nsIURI> documentURI = doc->GetBaseURI();
 
@@ -991,17 +997,22 @@ ServiceWorkerManager::Register(nsIDOMWin
 
   ServiceWorkerJobQueue* queue = GetOrCreateJobQueue(cleanedScope);
   MOZ_ASSERT(queue);
 
   nsRefPtr<ServiceWorkerResolveWindowPromiseOnUpdateCallback> cb =
     new ServiceWorkerResolveWindowPromiseOnUpdateCallback(window, promise);
 
   nsRefPtr<ServiceWorkerRegisterJob> job =
-    new ServiceWorkerRegisterJob(queue, cleanedScope, spec, cb, documentPrincipal);
+    new ServiceWorkerRegisterJob(queue,
+                                 cleanedScope,
+                                 spec,
+                                 cb,
+                                 documentPrincipal,
+                                 forceServiceWorkerUpdateOnRegistration);
   queue->Append(job);
 
   promise.forget(aPromise);
   return NS_OK;
 }
 
 void
 ServiceWorkerManager::AppendPendingOperation(ServiceWorkerJobQueue* aQueue,
diff --git a/toolkit/devtools/server/actors/webbrowser.js b/toolkit/devtools/server/actors/webbrowser.js
--- a/toolkit/devtools/server/actors/webbrowser.js
+++ b/toolkit/devtools/server/actors/webbrowser.js
@@ -1316,16 +1316,23 @@ TabActor.prototype = {
     }
     if ((typeof options.serviceWorkersTestingEnabled !== "undefined") &&
         (options.serviceWorkersTestingEnabled !==
          this._getServiceWorkersTestingEnabled())) {
       this._setServiceWorkersTestingEnabled(
         options.serviceWorkersTestingEnabled
       );
     }
+    if ((typeof options.forceServiceWorkersUpdateOnRegistration !== "undefined") &&
+        (options.forceServiceWorkersUpdateOnRegistration !==
+         this._getForceServiceWorkersUpdateOnRegistration())) {
+      this._setForceServiceWorkersUpdateOnRegistration(
+        options.forceServiceWorkersUpdateOnRegistration
+      );
+    }
 
     // Reload if:
     //  - there's an explicit `performReload` flag and it's true
     //  - there's no `performReload` flag, but it makes sense to do so
     let hasExplicitReloadFlag = "performReload" in options;
     if ((hasExplicitReloadFlag && options.performReload) ||
        (!hasExplicitReloadFlag && reload)) {
       this.onReload();
@@ -1364,16 +1371,31 @@ TabActor.prototype = {
     }
 
     let windowUtils = this.window.QueryInterface(Ci.nsIInterfaceRequestor)
                                  .getInterface(Ci.nsIDOMWindowUtils);
     windowUtils.serviceWorkersTestingEnabled = enabled;
   },
 
   /**
+   * Disable or enable to force always the update of service workers on
+   * registration.
+   */
+  _setForceServiceWorkersUpdateOnRegistration: function(enabled) {
+    if (!this.docShell) {
+      // The tab is already closed.
+      return null;
+    }
+
+    let windowUtils = this.window.QueryInterface(Ci.nsIInterfaceRequestor)
+                          .getInterface(Ci.nsIDOMWindowUtils);
+    windowUtils.forceServiceWorkerUpdateOnRegistration = enabled;
+  },
+
+  /**
    * Return cache allowed status.
    */
   _getCacheDisabled: function() {
     if (!this.docShell) {
       // The tab is already closed.
       return null;
     }
 
@@ -1404,16 +1426,31 @@ TabActor.prototype = {
     }
 
     let windowUtils = this.window.QueryInterface(Ci.nsIInterfaceRequestor)
                                  .getInterface(Ci.nsIDOMWindowUtils);
     return windowUtils.serviceWorkersTestingEnabled;
   },
 
   /**
+   * Return whether service workers are being force to always update on
+   * registration.
+   */
+  _getForceServiceWorkersUpdateOnRegistration: function() {
+    if (!this.docShell) {
+      // The tab is already closed.
+      return null;
+    }
+
+    let windowUtils = this.window.QueryInterface(Ci.nsIInterfaceRequestor)
+          .getInterface(Ci.nsIDOMWindowUtils);
+    return windowUtils.forceServiceWorkerUpdateOnRegistration;
+  },
+
+  /**
    * Prepare to enter a nested event loop by disabling debuggee events.
    */
   preNest: function BTA_preNest() {
     if (!this.window) {
       // The tab is already closed.
       return;
     }
     let windowUtils = this.window
