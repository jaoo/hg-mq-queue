# HG changeset patch
# Parent 14185c7a4a3554137f6a6954f3c055d418058e6a
# User Jose Antonio Olivera Ortega <jaoo@jaoo.es>
Bug 1131352 - Add ServiceWorkerGlobalScope skipWaiting(). r=nsm

diff --git a/dom/webidl/ServiceWorkerGlobalScope.webidl b/dom/webidl/ServiceWorkerGlobalScope.webidl
--- a/dom/webidl/ServiceWorkerGlobalScope.webidl
+++ b/dom/webidl/ServiceWorkerGlobalScope.webidl
@@ -11,16 +11,19 @@
  */
 
 [Global=(Worker,ServiceWorker),
  Exposed=ServiceWorker]
 interface ServiceWorkerGlobalScope : WorkerGlobalScope {
   readonly attribute Clients clients;
   readonly attribute ServiceWorkerRegistration registration;
 
+  [Throws]
+  Promise<boolean> skipWaiting();
+
   attribute EventHandler oninstall;
   attribute EventHandler onactivate;
   attribute EventHandler onfetch;
   attribute EventHandler onbeforeevicted;
   attribute EventHandler onevicted;
 
   // The event.source of these MessageEvents are instances of Client
   attribute EventHandler onmessage;
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -854,18 +854,21 @@ private:
       }
     }
 
     mRegistration->mWaitingWorker = mRegistration->mInstallingWorker.forget();
     mRegistration->mWaitingWorker->UpdateState(ServiceWorkerState::Installed);
     swm->InvalidateServiceWorkerRegistrationWorker(mRegistration,
                                                    WhichServiceWorker::INSTALLING_WORKER | WhichServiceWorker::WAITING_WORKER);
 
-    // FIXME(nsm): Bug 982711 Deal with activateImmediately.
-    NS_WARN_IF_FALSE(!aActivateImmediately, "Immediate activation using replace() is not supported yet");
+    // "If registration's waiting worker's skip waiting flag is set"
+    if (mRegistration->mWaitingWorker->SkipWaitingFlag()) {
+      mRegistration->PurgeActiveWorker();
+    }
+
     Done(NS_OK);
     // Activate() is invoked out of band of atomic.
     mRegistration->TryToActivate();
   }
 };
 
 NS_IMPL_ISUPPORTS_INHERITED0(ServiceWorkerRegisterJob, ServiceWorkerJob);
 
@@ -1142,48 +1145,59 @@ LifecycleEventWorkerRunnable::DispatchLi
     new LifecycleEventPromiseHandler(mTask, mServiceWorker, false /* activateImmediately */);
   waitUntilPromise->AppendNativeHandler(handler);
   return true;
 }
 
 void
 ServiceWorkerRegistrationInfo::TryToActivate()
 {
-  if (!IsControllingDocuments()) {
+  if (!IsControllingDocuments() || mWaitingWorker->SkipWaitingFlag()) {
     Activate();
   }
 }
 
 void
 ContinueActivateTask::ContinueAfterWorkerEvent(bool aSuccess, bool aActivateImmediately /* unused */)
 {
   mRegistration->FinishActivate(aSuccess);
 }
 
 void
+ServiceWorkerRegistrationInfo::PurgeActiveWorker()
+{
+  nsRefPtr<ServiceWorkerInfo> exitingWorker = mActiveWorker;
+  if (!exitingWorker)
+    return;
+
+  // FIXME(jaoo): Wait for exitingWorker to finish and terminate.
+  exitingWorker->UpdateState(ServiceWorkerState::Redundant);
+  nsresult rv = serviceWorkerScriptCache::PurgeCache(mPrincipal,
+                                                     exitingWorker->CacheName());
+  if (NS_FAILED(rv)) {
+    NS_WARNING("Failed to purge the activating cache.");
+  }
+  nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  swm->InvalidateServiceWorkerRegistrationWorker(this, WhichServiceWorker::ACTIVE_WORKER);
+}
+
+void
 ServiceWorkerRegistrationInfo::Activate()
 {
   nsRefPtr<ServiceWorkerInfo> activatingWorker = mWaitingWorker;
   nsRefPtr<ServiceWorkerInfo> exitingWorker = mActiveWorker;
 
   nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   swm->InvalidateServiceWorkerRegistrationWorker(this, WhichServiceWorker::WAITING_WORKER | WhichServiceWorker::ACTIVE_WORKER);
   if (!activatingWorker) {
     return;
   }
 
   if (exitingWorker) {
-    // FIXME(nsm): Wait for worker.
-    // Terminate worker
-    exitingWorker->UpdateState(ServiceWorkerState::Redundant);
-    nsresult rv = serviceWorkerScriptCache::PurgeCache(mPrincipal,
-                                                       exitingWorker->CacheName());
-    if (NS_FAILED(rv)) {
-      NS_WARNING("Failed to purge the activating cache.");
-    }
+    PurgeActiveWorker();
   }
 
   mActiveWorker = activatingWorker.forget();
   mWaitingWorker = nullptr;
   mActiveWorker->UpdateState(ServiceWorkerState::Activating);
 
   // FIXME(nsm): Unlink appcache if there is one.
 
@@ -3051,16 +3065,38 @@ ServiceWorkerManager::ClaimClients(const
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
   mAllDocuments.EnumerateEntries(ClaimMatchingClients, registration);
 
   return NS_OK;
 }
 
+nsresult
+ServiceWorkerManager::SetSkipWaitingFlag(const nsCString& aScope,
+                                         const uint64_t aServiceWorkerID)
+{
+  nsRefPtr<ServiceWorkerRegistrationInfo> registration = GetRegistration(aScope);
+  if (!registration) {
+    return NS_ERROR_FAILURE;
+  }
+
+  if (registration->mInstallingWorker &&
+      (registration->mInstallingWorker->ID() == aServiceWorkerID)) {
+    registration->mInstallingWorker->SetSkipWaitingFlag();
+  } else if (registration->mWaitingWorker &&
+             (registration->mWaitingWorker->ID() == aServiceWorkerID)) {
+    registration->mWaitingWorker->SetSkipWaitingFlag();
+  } else {
+    return NS_ERROR_FAILURE;
+  }
+
+  return NS_OK;
+}
+
 void
 ServiceWorkerManager::FireControllerChange(ServiceWorkerRegistrationInfo* aRegistration)
 {
   mControlledDocuments.EnumerateRead(FireControllerChangeOnMatchingDocument, aRegistration);
 }
 
 ServiceWorkerRegistrationInfo*
 ServiceWorkerManager::CreateNewRegistration(const nsCString& aScope,
diff --git a/dom/workers/ServiceWorkerManager.h b/dom/workers/ServiceWorkerManager.h
--- a/dom/workers/ServiceWorkerManager.h
+++ b/dom/workers/ServiceWorkerManager.h
@@ -187,16 +187,19 @@ public:
   {
     return mActiveWorker && mControlledDocumentsCounter > 0;
   }
 
   void
   Clear();
 
   void
+  PurgeActiveWorker();
+
+  void
   TryToActivate();
 
   void
   Activate();
 
   void
   FinishActivate(bool aSuccess);
 
@@ -220,16 +223,17 @@ private:
   // workers to their corresponding serviceWorkerInfo.
   uint64_t mServiceWorkerID;
 
   // We hold rawptrs since the ServiceWorker constructor and destructor ensure
   // addition and removal.
   // There is a high chance of there being at least one ServiceWorker
   // associated with this all the time.
   nsAutoTArray<ServiceWorker*, 1> mInstances;
+  bool mSkipWaitingFlag;
 
   ~ServiceWorkerInfo()
   { }
 
   // Generates a unique id for the service worker, with zero being treated as
   // invalid.
   uint64_t
   GetNextID() const;
@@ -250,24 +254,38 @@ public:
   }
 
   void SetScriptSpec(const nsCString& aSpec)
   {
     MOZ_ASSERT(!aSpec.IsEmpty());
     mScriptSpec = aSpec;
   }
 
-  explicit ServiceWorkerInfo(ServiceWorkerRegistrationInfo* aReg,
-                             const nsACString& aScriptSpec,
-                             const nsAString& aCacheName)
+  bool
+  SkipWaitingFlag() const
+  {
+    AssertIsOnMainThread();
+    return mSkipWaitingFlag;
+  }
+
+  void SetSkipWaitingFlag()
+  {
+    AssertIsOnMainThread();
+    mSkipWaitingFlag = true;
+  }
+
+  ServiceWorkerInfo(ServiceWorkerRegistrationInfo* aReg,
+                    const nsACString& aScriptSpec,
+                    const nsAString& aCacheName)
     : mRegistration(aReg)
     , mScriptSpec(aScriptSpec)
     , mCacheName(aCacheName)
     , mState(ServiceWorkerState::EndGuard_)
     , mServiceWorkerID(GetNextID())
+    , mSkipWaitingFlag(false)
   {
     MOZ_ASSERT(mRegistration);
     MOZ_ASSERT(!aCacheName.IsEmpty());
   }
 
   ServiceWorkerState
   State() const
   {
@@ -412,16 +430,19 @@ public:
 
   void
   MaybeClaimClient(nsIDocument* aDocument,
                    ServiceWorkerRegistrationInfo* aWorkerRegistration);
 
   nsresult
   ClaimClients(const nsCString& aScope, WorkerPrivate* aWorkerPrivate);
 
+  nsresult
+  SetSkipWaitingFlag(const nsCString& aScope, const uint64_t aServiceWorkerID);
+
   static already_AddRefed<ServiceWorkerManager>
   GetInstance();
 
  void LoadRegistrations(
                  const nsTArray<ServiceWorkerRegistrationData>& aRegistrations);
 
   NS_IMETHOD
   AddRegistrationEventListener(const nsAString& aScope,
diff --git a/dom/workers/WorkerScope.cpp b/dom/workers/WorkerScope.cpp
--- a/dom/workers/WorkerScope.cpp
+++ b/dom/workers/WorkerScope.cpp
@@ -480,16 +480,138 @@ ServiceWorkerGlobalScope::Registration()
   if (!mRegistration) {
     mRegistration =
       new ServiceWorkerRegistrationWorkerThread(mWorkerPrivate, mScope);
   }
 
   return mRegistration;
 }
 
+namespace {
+
+class SkipWaitingResultRunnable final : public WorkerRunnable
+{
+  nsRefPtr<PromiseWorkerProxy> mPromiseProxy;
+  nsresult mResult;
+
+public:
+  SkipWaitingResultRunnable(WorkerPrivate* aWorkerPrivate,
+                            PromiseWorkerProxy* aPromiseProxy,
+                            nsresult aResult)
+    : WorkerRunnable(aWorkerPrivate, WorkerThreadModifyBusyCount)
+    , mPromiseProxy(aPromiseProxy)
+    , mResult(aResult)
+  {
+    AssertIsOnMainThread();
+  }
+
+  virtual bool
+  WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
+  {
+    MOZ_ASSERT(aWorkerPrivate);
+    aWorkerPrivate->AssertIsOnWorkerThread();
+
+    Promise* promise = mPromiseProxy->GetWorkerPromise();
+    MOZ_ASSERT(promise);
+
+    if (!NS_FAILED(mResult)) {
+      promise->MaybeResolve(JS::UndefinedHandleValue);
+    } else {
+      promise->MaybeReject(mResult);
+    }
+
+    // Release the reference on the worker thread.
+    mPromiseProxy->CleanUp(aCx);
+
+    return true;
+  }
+};
+
+class WorkerScopeSkipWaitingRunnable final : public nsRunnable
+{
+  uint64_t mServiceWorkerID;
+  nsRefPtr<PromiseWorkerProxy> mPromiseProxy;
+  nsCString mScope;
+
+public:
+  WorkerScopeSkipWaitingRunnable(const uint64_t aServiceWorkerID,
+                                 PromiseWorkerProxy* aPromiseProxy,
+                                 const nsCString& aScope)
+    : mServiceWorkerID(aServiceWorkerID)
+    , mPromiseProxy(aPromiseProxy)
+    , mScope(aScope)
+  {
+    MOZ_ASSERT(aPromiseProxy);
+  }
+
+  NS_IMETHODIMP
+  Run() override
+  {
+    AssertIsOnMainThread();
+    nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+    MOZ_ASSERT(swm);
+    WorkerPrivate* workerPrivate = mPromiseProxy->GetWorkerPrivate();
+    MOZ_ASSERT(workerPrivate);
+
+    nsresult rv = swm->SetSkipWaitingFlag(mScope, mServiceWorkerID);
+
+    nsRefPtr<SkipWaitingResultRunnable> runnable =
+      new SkipWaitingResultRunnable(workerPrivate, mPromiseProxy, rv);
+
+    AutoSafeJSContext cx;
+    if (runnable->Dispatch(cx)) {
+      return NS_OK;
+    }
+
+    // Dispatch to worker thread failed because the worker is shutting down.
+    // Use a control runnable to release the runnable on the worker thread.
+    nsRefPtr<PromiseWorkerProxyControlRunnable> releaseRunnable =
+      new PromiseWorkerProxyControlRunnable(workerPrivate, mPromiseProxy);
+
+    if (!releaseRunnable->Dispatch(cx)) {
+      NS_RUNTIMEABORT("Failed to dispatch Claim control runnable.");
+    }
+
+    return NS_OK;
+  }
+};
+
+}
+
+already_AddRefed<Promise>
+ServiceWorkerGlobalScope::SkipWaiting(ErrorResult& aRv)
+{
+  mWorkerPrivate->AssertIsOnWorkerThread();
+  MOZ_ASSERT(mWorkerPrivate->IsServiceWorker());
+
+  nsRefPtr<Promise> promise = Promise::Create(this, aRv);
+  if (aRv.Failed()) {
+    return nullptr;
+  }
+
+  nsRefPtr<PromiseWorkerProxy> promiseProxy =
+    PromiseWorkerProxy::Create(mWorkerPrivate, promise);
+  if (!promiseProxy->GetWorkerPromise()) {
+    // Don't dispatch if adding the worker feature failed.
+    return promise.forget();
+  }
+
+  nsRefPtr<WorkerScopeSkipWaitingRunnable> runnable =
+    new WorkerScopeSkipWaitingRunnable(mWorkerPrivate->ServiceWorkerID(),
+                                       promiseProxy,
+                                       NS_ConvertUTF16toUTF8(mScope));
+
+  aRv = NS_DispatchToMainThread(runnable);
+  if (NS_WARN_IF(aRv.Failed())) {
+    promise->MaybeReject(NS_ERROR_DOM_ABORT_ERR);
+  }
+
+  return promise.forget();
+}
+
 WorkerDebuggerGlobalScope::WorkerDebuggerGlobalScope(
                                                   WorkerPrivate* aWorkerPrivate)
 : mWorkerPrivate(aWorkerPrivate)
 {
   mWorkerPrivate->AssertIsOnWorkerThread();
 }
 
 WorkerDebuggerGlobalScope::~WorkerDebuggerGlobalScope()
diff --git a/dom/workers/WorkerScope.h b/dom/workers/WorkerScope.h
--- a/dom/workers/WorkerScope.h
+++ b/dom/workers/WorkerScope.h
@@ -221,16 +221,19 @@ public:
   }
 
   ServiceWorkerClients*
   Clients();
 
   ServiceWorkerRegistrationWorkerThread*
   Registration();
 
+  already_AddRefed<Promise>
+  SkipWaiting(ErrorResult& aRv);
+
   IMPL_EVENT_HANDLER(activate)
   IMPL_EVENT_HANDLER(beforeevicted)
   IMPL_EVENT_HANDLER(evicted)
   IMPL_EVENT_HANDLER(fetch)
   IMPL_EVENT_HANDLER(install)
   IMPL_EVENT_HANDLER(message)
 
   IMPL_EVENT_HANDLER(push)
diff --git a/dom/workers/test/serviceworkers/mochitest.ini b/dom/workers/test/serviceworkers/mochitest.ini
--- a/dom/workers/test/serviceworkers/mochitest.ini
+++ b/dom/workers/test/serviceworkers/mochitest.ini
@@ -75,16 +75,18 @@ support-files =
   worker_updatefoundevent.js
   worker_updatefoundevent2.js
   updatefoundevent.html
   empty.js
   periodic.sjs
   periodic/frame.html
   periodic/register.html
   periodic/unregister.html
+  skip_waiting_installed_worker.js
+  skip_waiting_scope/index.html
 
 [test_unregister.html]
 [test_installation_simple.html]
 [test_fetch_event.html]
 [test_https_fetch.html]
 [test_https_fetch_cloned_response.html]
 [test_https_synth_fetch_from_cached_sw.html]
 [test_match_all.html]
@@ -108,8 +110,9 @@ support-files =
 [test_importscript.html]
 [test_client_focus.html]
 [test_claim_oninstall.html]
 [test_claim.html]
 [test_bug1151916.html]
 [test_workerupdatefoundevent.html]
 [test_empty_serviceworker.html]
 [test_periodic_update.html]
+[test_skip_waiting.html]
diff --git a/dom/workers/test/serviceworkers/skip_waiting_installed_worker.js b/dom/workers/test/serviceworkers/skip_waiting_installed_worker.js
new file mode 100644
--- /dev/null
+++ b/dom/workers/test/serviceworkers/skip_waiting_installed_worker.js
@@ -0,0 +1,6 @@
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+self.addEventListener('install', evt => {
+  evt.waitUntil(self.skipWaiting());
+});
diff --git a/dom/workers/test/serviceworkers/skip_waiting_scope/index.html b/dom/workers/test/serviceworkers/skip_waiting_scope/index.html
new file mode 100644
--- /dev/null
+++ b/dom/workers/test/serviceworkers/skip_waiting_scope/index.html
@@ -0,0 +1,37 @@
+<!--
+  Any copyright is dedicated to the Public Domain.
+  http://creativecommons.org/publicdomain/zero/1.0/
+-->
+<!DOCTYPE HTML>
+<html>
+<head>
+  <title>Bug 1131352 - Add ServiceWorkerGlobalScope skipWaiting()</title>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<p id="display"></p>
+<div id="content" style="display: none"></div>
+<pre id="test"></pre>
+<script class="testbody" type="text/javascript">
+
+  if (!parent) {
+    info("skip_waiting_scope/index.html shouldn't be launched directly!");
+  }
+
+  navigator.serviceWorker.ready.then(function() {
+    parent.postMessage("READY", "*");
+  });
+
+  navigator.serviceWorker.oncontrollerchange = function() {
+    parent.postMessage({
+      event: "controllerchange",
+      controllerScriptURL: navigator.serviceWorker.controller &&
+                           navigator.serviceWorker.controller.scriptURL
+    }, "*");
+  }
+
+</script>
+</pre>
+</body>
+</html>
diff --git a/dom/workers/test/serviceworkers/test_skip_waiting.html b/dom/workers/test/serviceworkers/test_skip_waiting.html
new file mode 100644
--- /dev/null
+++ b/dom/workers/test/serviceworkers/test_skip_waiting.html
@@ -0,0 +1,96 @@
+<!--
+  Any copyright is dedicated to the Public Domain.
+  http://creativecommons.org/publicdomain/zero/1.0/
+-->
+<!DOCTYPE HTML>
+<html>
+<head>
+  <title>Bug 1131352 - Add ServiceWorkerGlobalScope skipWaiting()</title>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<p id="display"></p>
+<div id="content" style="display: none"></div>
+<pre id="test"></pre>
+<script class="testbody" type="text/javascript">
+  var registration, iframe, content;
+
+  function start() {
+    return navigator.serviceWorker.register("worker.js",
+                                            {scope: "./skip_waiting_scope/"});
+  }
+
+  function waitForActivated(swr) {
+    registration = swr;
+    var promise = new Promise(function(resolve, reject) {
+      window.onmessage = function(e) {
+        if (e.data === "READY") {
+          ok(true, "Active worker is activated now");
+          resolve();
+        } else {
+          ok(false, "Wrong value. Somenting went wrong");
+          resolve();
+        }
+      }
+    });
+
+    iframe = document.createElement("iframe");
+    iframe.setAttribute("src", "skip_waiting_scope/index.html");
+
+    content = document.getElementById("content");
+    content.appendChild(iframe);
+
+    return promise;
+  }
+
+  function register() {
+    return navigator.serviceWorker.register("skip_waiting_installed_worker.js",
+                                            {scope: "./skip_waiting_scope/"});
+  }
+
+  function checkWhetherItSkipedWaiting(swr) {
+    registration = swr;
+    var promise = new Promise(function(resolve, reject) {
+      window.onmessage = function (evt) {
+        if (evt.data.event === "controllerchange") {
+          ok(evt.data.controllerScriptURL.match("skip_waiting_installed_worker"),
+             "The controller changed after skiping the waiting step");
+          resolve();
+        } else {
+          ok(false, "Wrong value. Somenting went wrong");
+          resolve();
+        }
+      };
+    });
+
+    return promise;
+  }
+
+  function clean() {
+    content.removeChild(iframe);
+
+    return registration.unregister();
+  }
+
+  function runTest() {
+    start()
+      .then(waitForActivated)
+      .then(register)
+      .then(checkWhetherItSkipedWaiting)
+      .then(clean)
+      .catch(function(e) {
+        ok(false, "Some test failed with error " + e);
+      }).then(SimpleTest.finish);
+  }
+
+  SimpleTest.waitForExplicitFinish();
+  SpecialPowers.pushPrefEnv({"set": [
+    ["dom.serviceWorkers.exemptFromPerDomainMax", true],
+    ["dom.serviceWorkers.enabled", true],
+    ["dom.serviceWorkers.testing.enabled", true]
+  ]}, runTest);
+</script>
+</pre>
+</body>
+</html>
