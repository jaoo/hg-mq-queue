# HG changeset patch
# Parent c28e5d7a32a987a14bad2d559a5ed2334c7107ae
# User Andrea Marchesini <amarchesini@mozilla.com>

diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -14029,17 +14029,18 @@ nsDocShell::ShouldPrepareForIntercept(ns
   }
 
   nsCOMPtr<nsIServiceWorkerManager> swm = services::GetServiceWorkerManager();
   if (!swm) {
     return NS_OK;
   }
 
   if (aIsNavigate) {
-    return swm->IsAvailableForURI(aURI, aShouldIntercept);
+    return swm->IsAvailableForURI(GetAppId(), GetIsInBrowserElement(), aURI,
+                                  aShouldIntercept);
   }
 
   nsCOMPtr<nsIDocument> doc = GetDocument();
   if (!doc) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   return swm->IsControlled(doc, aShouldIntercept);
@@ -14063,17 +14064,19 @@ nsDocShell::ChannelIntercepted(nsIInterc
   if (!isNavigation) {
     doc = GetDocument();
     if (!doc) {
       return NS_ERROR_NOT_AVAILABLE;
     }
   }
 
   bool isReload = mLoadType & LOAD_CMD_RELOAD;
-  return swm->DispatchFetchEvent(doc, aChannel, isReload);
+
+  return swm->DispatchFetchEvent(GetAppId(), GetIsInBrowserElement(), doc,
+                                 aChannel, isReload);
 }
 
 NS_IMETHODIMP
 nsDocShell::SetPaymentRequestId(const nsAString& aPaymentRequestId)
 {
   mPaymentRequestId = aPaymentRequestId;
   return NS_OK;
 }
diff --git a/dom/interfaces/base/nsIServiceWorkerManager.idl b/dom/interfaces/base/nsIServiceWorkerManager.idl
--- a/dom/interfaces/base/nsIServiceWorkerManager.idl
+++ b/dom/interfaces/base/nsIServiceWorkerManager.idl
@@ -15,17 +15,17 @@ interface nsIURI;
 interface nsIServiceWorkerUnregisterCallback : nsISupports
 {
   // aState is true if the unregistration succeded.
   // It's false if this ServiceWorkerRegistration doesn't exist.
   void unregisterSucceeded(in bool aState);
   void unregisterFailed();
 };
 
-[scriptable, builtinclass, uuid(8ce0d197-5740-4ddf-aa4a-e5a63e611d03)]
+[scriptable, builtinclass, uuid(103763c8-53ba-42e4-8b26-e601d5bc4afe)]
 interface nsIServiceWorkerInfo : nsISupports
 {
   readonly attribute nsIPrincipal principal;
 
   readonly attribute DOMString scope;
   readonly attribute DOMString scriptSpec;
   readonly attribute DOMString currentWorkerURL;
 
@@ -61,24 +61,31 @@ interface nsIServiceWorkerManager : nsIS
   nsISupports getRegistration(in nsIDOMWindow aWindow, in DOMString aScope);
 
   // Returns a Promise
   nsISupports getReadyPromise(in nsIDOMWindow aWindow);
 
   // Remove ready pending Promise
   void removeReadyPromise(in nsIDOMWindow aWindow);
 
-  // Returns true if a ServiceWorker is available for the scope of aURI.
-  bool isAvailableForURI(in nsIURI aURI);
+  // Returns true if a ServiceWorker is available for the scope of aURI for a
+  // particular appId+BrowserElement
+  bool isAvailableForURI(in unsigned long aAppId,
+                         in boolean aIsInBrowserElement,
+                         in nsIURI aURI);
 
   // Returns true if a given document is currently controlled by a ServiceWorker
   bool isControlled(in nsIDocument aDocument);
 
-  // Cause a fetch event to be dispatched to the worker global associated with the given document.
-  void dispatchFetchEvent(in nsIDocument aDoc, in nsIInterceptedChannel aChannel,
+  // Cause a fetch event to be dispatched to the worker global associated with
+  // the given document.
+  void dispatchFetchEvent(in unsigned long aAppId,
+                          in boolean aIsInBrowserElement,
+                          in nsIDocument aDoc,
+                          in nsIInterceptedChannel aChannel,
                           in boolean aIsReload);
 
   /**
    * Call this to request that document `aDoc` be controlled by a ServiceWorker
    * if a registration exists for it's scope.
    *
    * This MUST only be called once per document!
    */
@@ -104,17 +111,18 @@ interface nsIServiceWorkerManager : nsIS
   /*
    * Returns a ServiceWorker.
    */
   [noscript] nsISupports GetDocumentController(in nsIDOMWindow aWindow);
 
   /*
    * This implements the soft update algorithm.
    */
-  void softUpdate(in DOMString aScope);
+  void softUpdate(in unsigned long aAppId, in boolean aIsInBrowserElement,
+                  in DOMString aScope);
 
   /*
    * Clears ServiceWorker registrations from memory and disk for the specified
    * host.
    * - All ServiceWorker instances change their state to redundant.
    * - Existing ServiceWorker instances handling fetches will keep running.
    * - All documents will immediately stop being controlled.
    * - Unregister jobs will be queued for all registrations.
@@ -123,23 +131,26 @@ interface nsIServiceWorkerManager : nsIS
   void remove(in AUTF8String aHost);
 
   /*
    * Clear all registrations for all hosts. See remove().
    */
   void removeAll();
 
   // Testing
-  DOMString getScopeForUrl(in DOMString path);
+  DOMString getScopeForUrl(in nsIPrincipal aPrincipal, in DOMString aPath);
 
   // This is meant to be used only by about:serviceworkers. It returns an array
   // of nsIServiceWorkerInfo.
   nsIArray getAllRegistrations();
 
-  void sendPushEvent(in ACString scope, in DOMString data);
-  void sendPushSubscriptionChangeEvent(in ACString scope);
+  void sendPushEvent(in unsigned long aAppId, in boolean aIsInBrowserElement,
+                     in ACString aScope, in DOMString aData);
+  void sendPushSubscriptionChangeEvent(in unsigned long aAppId,
+                                       in boolean aIsInBrowserElement,
+                                       in ACString scope);
 
   void updateAllRegistrations();
 };
 
 %{ C++
 #define SERVICEWORKERMANAGER_CONTRACTID "@mozilla.org/serviceworkers/manager;1"
 %}
diff --git a/dom/push/PushService.jsm b/dom/push/PushService.jsm
--- a/dom/push/PushService.jsm
+++ b/dom/push/PushService.jsm
@@ -1394,17 +1394,24 @@ this.PushService = {
         let globalMM = Cc['@mozilla.org/globalmessagemanager;1'].getService(Ci.nsIMessageListenerManager);
         for (let scope of scopes) {
           // Notify XPCOM observers.
           Services.obs.notifyObservers(
             null,
             "push-subscription-change",
             scope
           );
-          globalMM.broadcastAsyncMessage('pushsubscriptionchanged', scope);
+
+          let data = {
+            appId: 0 // TODO,
+            inBrowserElement: false, // TODO
+            scope: scope
+          };
+
+          globalMM.broadcastAsyncMessage('pushsubscriptionchanged', data);
         }
       });
   },
 
   _notifyApp: function(aPushRecord) {
     if (!aPushRecord || !aPushRecord.scope) {
       debug("notifyApp() something is undefined.  Dropping notification: "
         + JSON.stringify(aPushRecord) );
@@ -1432,16 +1439,18 @@ this.PushService = {
     if(Services.perms.testExactPermission(scopeURI, "push") != Ci.nsIPermissionManager.ALLOW_ACTION) {
       debug("Does not have permission for push.")
       return;
     }
 
     // TODO data.
     let data = {
       payload: "Short as life is, we make it still shorter by the careless waste of time.",
+      appId: 0 // TODO,
+      inBrowserElement: false, // TODO
       scope: aPushRecord.scope
     };
 
     let globalMM = Cc['@mozilla.org/globalmessagemanager;1']
                  .getService(Ci.nsIMessageListenerManager);
     globalMM.broadcastAsyncMessage('push', data);
   },
 
diff --git a/dom/push/PushServiceChildPreload.js b/dom/push/PushServiceChildPreload.js
--- a/dom/push/PushServiceChildPreload.js
+++ b/dom/push/PushServiceChildPreload.js
@@ -5,14 +5,17 @@
 "use strict";
 
 XPCOMUtils.defineLazyServiceGetter(this,
                                    "swm",
                                    "@mozilla.org/serviceworkers/manager;1",
                                    "nsIServiceWorkerManager");
 
 addMessageListener("push", function (aMessage) {
-  swm.sendPushEvent(aMessage.data.scope, aMessage.data.payload);
+  swm.sendPushEvent(aMessage.data.appId, aMessage.data.inBrowserElement,
+                    aMessage.data.scope, aMessage.data.payload);
 });
 
 addMessageListener("pushsubscriptionchange", function (aMessage) {
-  swm.sendPushSubscriptionChangeEvent(aMessage.data);
+  swm.sendPushSubscriptionChangeEvent(aMessage.data.appId,
+                                      aMessage.data.inBrowserElement,
+                                      aMessage.data.scope);
 });
diff --git a/dom/workers/ServiceWorkerClients.cpp b/dom/workers/ServiceWorkerClients.cpp
--- a/dom/workers/ServiceWorkerClients.cpp
+++ b/dom/workers/ServiceWorkerClients.cpp
@@ -109,17 +109,17 @@ public:
     if (mPromiseProxy->IsClean()) {
       // Don't resolve the promise if it was already released.
       return NS_OK;
     }
 
     nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
     nsTArray<ServiceWorkerClientInfo> result;
 
-    swm->GetAllClients(mScope, result);
+    swm->GetAllClients(mWorkerPrivate->GetPrincipal(), mScope, result);
     nsRefPtr<ResolvePromiseWorkerRunnable> r =
       new ResolvePromiseWorkerRunnable(mWorkerPrivate, mPromiseProxy, result);
 
     AutoSafeJSContext cx;
     if (r->Dispatch(cx)) {
       return NS_OK;
     }
 
@@ -192,17 +192,19 @@ public:
   }
 
   NS_IMETHOD
   Run() override
   {
     nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
     MOZ_ASSERT(swm);
 
-    nsresult rv = swm->ClaimClients(mScope, mServiceWorkerID);
+    nsresult rv =
+      swm->ClaimClients(mPromiseProxy->GetWorkerPrivate()->GetPrincipal(),
+                        mScope, mServiceWorkerID);
 
     MutexAutoLock lock(mPromiseProxy->GetCleanUpLock());
     if (mPromiseProxy->IsClean()) {
       // Don't resolve the promise if it was already released.
       return NS_OK;
     }
 
     WorkerPrivate* workerPrivate = mPromiseProxy->GetWorkerPrivate();
diff --git a/dom/workers/ServiceWorkerContainer.cpp b/dom/workers/ServiceWorkerContainer.cpp
--- a/dom/workers/ServiceWorkerContainer.cpp
+++ b/dom/workers/ServiceWorkerContainer.cpp
@@ -220,19 +220,25 @@ ServiceWorkerContainer::GetReady(ErrorRe
 }
 
 // Testing only.
 void
 ServiceWorkerContainer::GetScopeForUrl(const nsAString& aUrl,
                                        nsString& aScope,
                                        ErrorResult& aRv)
 {
+  nsCOMPtr<nsIDocument> doc = GetOwner()->GetExtantDoc();
+  MOZ_ASSERT(doc);
+
+  nsCOMPtr<nsIPrincipal> principal = doc->NodePrincipal();
+  MOZ_ASSERT(principal);
+
   nsCOMPtr<nsIServiceWorkerManager> swm = mozilla::services::GetServiceWorkerManager();
   if (!swm) {
     aRv.Throw(NS_ERROR_FAILURE);
     return;
   }
 
-  aRv = swm->GetScopeForUrl(aUrl, aScope);
+  aRv = swm->GetScopeForUrl(principal, aUrl, aScope);
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -47,16 +47,17 @@
 #include "nsProxyRelease.h"
 #include "nsQueryObject.h"
 #include "nsTArray.h"
 
 #include "RuntimeService.h"
 #include "ServiceWorker.h"
 #include "ServiceWorkerClient.h"
 #include "ServiceWorkerContainer.h"
+#include "ServiceWorkerRegistrar.h"
 #include "ServiceWorkerRegistration.h"
 #include "ServiceWorkerScriptCache.h"
 #include "ServiceWorkerEvents.h"
 #include "WorkerInlines.h"
 #include "WorkerPrivate.h"
 #include "WorkerRunnable.h"
 #include "WorkerScope.h"
 
@@ -77,16 +78,34 @@ static_assert(nsIHttpChannelInternal::CO
               "RequestMode enumeration value should match Necko CORS mode value.");
 static_assert(nsIHttpChannelInternal::CORS_MODE_NO_CORS == static_cast<uint32_t>(RequestMode::No_cors),
               "RequestMode enumeration value should match Necko CORS mode value.");
 static_assert(nsIHttpChannelInternal::CORS_MODE_CORS == static_cast<uint32_t>(RequestMode::Cors),
               "RequestMode enumeration value should match Necko CORS mode value.");
 static_assert(nsIHttpChannelInternal::CORS_MODE_CORS_WITH_FORCED_PREFLIGHT == static_cast<uint32_t>(RequestMode::Cors_with_forced_preflight),
               "RequestMode enumeration value should match Necko CORS mode value.");
 
+struct ServiceWorkerManager::RegistrationDataPerPrincipal
+{
+  // Ordered list of scopes for glob matching.
+  // Each entry is an absolute URL representing the scope.
+  // Each value of the hash table is an array of an absolute URLs representing
+  // the scopes.
+  //
+  // An array is used for now since the number of controlled scopes per
+  // domain is expected to be relatively low. If that assumption was proved
+  // wrong this should be replaced with a better structure to avoid the
+  // memmoves associated with inserting stuff in the middle of the array.
+  nsTArray<nsCString> mOrderedScopes;
+
+  // Scope to registration.
+  // The scope should be a fully qualified valid URL.
+  nsRefPtrHashtable<nsCStringHashKey, ServiceWorkerRegistrationInfo> mInfos;
+};
+
 struct ServiceWorkerManager::PendingOperation
 {
   nsCOMPtr<nsIRunnable> mRunnable;
 
   ServiceWorkerJobQueue* mQueue;
   nsRefPtr<ServiceWorkerJob> mJob;
 
   ServiceWorkerRegistrationData mRegistration;
@@ -254,17 +273,17 @@ ServiceWorkerManager::ServiceWorkerManag
       MOZ_ASSERT(NS_SUCCEEDED(rv));
     }
   }
 }
 
 ServiceWorkerManager::~ServiceWorkerManager()
 {
   // The map will assert if it is not empty when destroyed.
-  mServiceWorkerRegistrationInfos.Clear();
+  mRegistrationInfos.Clear();
 }
 
 class ContinueLifecycleTask : public nsISupports
 {
   NS_DECL_ISUPPORTS
 
 protected:
   virtual ~ContinueLifecycleTask()
@@ -638,17 +657,17 @@ public:
     if (!swm->HasBackgroundActor()) {
       nsCOMPtr<nsIRunnable> runnable =
         NS_NewRunnableMethod(this, &ServiceWorkerRegisterJob::Start);
       swm->AppendPendingOperation(runnable);
       return;
     }
 
     if (mJobType == REGISTER_JOB) {
-      mRegistration = swm->GetRegistration(mScope);
+      mRegistration = swm->GetRegistration(mPrincipal, mScope);
 
       if (mRegistration) {
         nsRefPtr<ServiceWorkerInfo> newest = mRegistration->Newest();
         if (newest && mScriptSpec.Equals(newest->ScriptSpec()) &&
             mScriptSpec.Equals(mRegistration->mScriptSpec)) {
           mRegistration->mPendingUninstall = false;
           swm->StoreRegistration(mPrincipal, mRegistration);
           Succeed();
@@ -1433,18 +1452,30 @@ public:
       return rv;
     }
 
     if (nsContentUtils::IsSystemPrincipal(principal) || isNullPrincipal) {
       mPromise->MaybeResolve(array);
       return NS_OK;
     }
 
-    for (uint32_t i = 0; i < swm->mOrderedScopes.Length(); ++i) {
-      NS_ConvertUTF8toUTF16 scope(swm->mOrderedScopes[i]);
+    nsAutoCString principalKey;
+    rv = swm->PrincipalToScopeKey(principal, principalKey);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+
+    ServiceWorkerManager::RegistrationDataPerPrincipal* data;
+    if (!swm->mRegistrationInfos.Get(principalKey, &data)) {
+      mPromise->MaybeResolve(array);
+      return NS_OK;
+    }
+
+    for (uint32_t i = 0; i < data->mOrderedScopes.Length(); ++i) {
+      NS_ConvertUTF8toUTF16 scope(data->mOrderedScopes[i]);
 
       nsCOMPtr<nsIURI> scopeURI;
       nsresult rv = NS_NewURI(getter_AddRefs(scopeURI), scope, nullptr, nullptr);
       if (NS_WARN_IF(NS_FAILED(rv))) {
         mPromise->MaybeReject(rv);
         break;
       }
 
@@ -1544,17 +1575,17 @@ public:
     rv = principal->CheckMayLoad(uri, true /* report */,
                                  false /* allowIfInheritsPrinciple */);
     if (NS_FAILED(rv)) {
       mPromise->MaybeReject(NS_ERROR_DOM_SECURITY_ERR);
       return NS_OK;
     }
 
     nsRefPtr<ServiceWorkerRegistrationInfo> registration =
-      swm->GetServiceWorkerRegistrationInfo(uri);
+      swm->GetServiceWorkerRegistrationInfo(principal, uri);
 
     if (!registration) {
       mPromise->MaybeResolve(JS::UndefinedHandleValue);
       return NS_OK;
     }
 
     NS_ConvertUTF8toUTF16 scope(registration->mScope);
     nsRefPtr<ServiceWorkerRegistrationMainThread> swr =
@@ -1720,57 +1751,66 @@ public:
     globalScope->DispatchDOMEvent(nullptr, event, nullptr, nullptr);
     return true;
   }
 };
 
 #endif /* ! MOZ_SIMPLEPUSH */
 
 NS_IMETHODIMP
-ServiceWorkerManager::SendPushEvent(const nsACString& aScope, const nsAString& aData)
+ServiceWorkerManager::SendPushEvent(uint32_t aAppId,
+                                    bool aInBrowserElement,
+                                    const nsACString& aScope,
+                                    const nsAString& aData)
 {
 #ifdef MOZ_SIMPLEPUSH
   return NS_ERROR_NOT_AVAILABLE;
 #else
-  nsRefPtr<ServiceWorker> serviceWorker = CreateServiceWorkerForScope(aScope);
+  nsRefPtr<ServiceWorker> serviceWorker =
+    CreateServiceWorkerForScope(aAppId, aInBrowserElement, aScope);
   if (!serviceWorker) {
     return NS_ERROR_FAILURE;
   }
 
   nsMainThreadPtrHandle<ServiceWorker> serviceWorkerHandle(
     new nsMainThreadPtrHolder<ServiceWorker>(serviceWorker));
 
   nsRefPtr<SendPushEventRunnable> r =
-    new SendPushEventRunnable(serviceWorker->GetWorkerPrivate(), aData, serviceWorkerHandle);
+    new SendPushEventRunnable(serviceWorker->GetWorkerPrivate(), aData,
+                              serviceWorkerHandle);
 
   AutoJSAPI jsapi;
   jsapi.Init();
   if (NS_WARN_IF(!r->Dispatch(jsapi.cx()))) {
     return NS_ERROR_FAILURE;
   }
 
   return NS_OK;
 #endif
 }
 
 NS_IMETHODIMP
-ServiceWorkerManager::SendPushSubscriptionChangeEvent(const nsACString& aScope)
+ServiceWorkerManager::SendPushSubscriptionChangeEvent(uint32_t aAppId,
+                                                      bool aInBrowserElement,
+                                                      const nsACString& aScope)
 {
 #ifdef MOZ_SIMPLEPUSH
   return NS_ERROR_NOT_AVAILABLE;
 #else
-  nsRefPtr<ServiceWorker> serviceWorker = CreateServiceWorkerForScope(aScope);
+  nsRefPtr<ServiceWorker> serviceWorker =
+    CreateServiceWorkerForScope(aAppId, aInBrowserElement, aScope);
   if (!serviceWorker) {
     return NS_ERROR_FAILURE;
   }
   nsMainThreadPtrHandle<ServiceWorker> serviceWorkerHandle(
     new nsMainThreadPtrHolder<ServiceWorker>(serviceWorker));
 
   nsRefPtr<SendPushSubscriptionChangeEventRunnable> r =
-    new SendPushSubscriptionChangeEventRunnable(serviceWorker->GetWorkerPrivate(), serviceWorkerHandle);
+    new SendPushSubscriptionChangeEventRunnable(
+      serviceWorker->GetWorkerPrivate(), serviceWorkerHandle);
 
   AutoJSAPI jsapi;
   jsapi.Init();
   if (NS_WARN_IF(!r->Dispatch(jsapi.cx()))) {
     return NS_ERROR_FAILURE;
   }
 
   return NS_OK;
@@ -1859,41 +1899,53 @@ ServiceWorkerManager::CheckPendingReadyP
 
   return PL_DHASH_NEXT;
 }
 
 bool
 ServiceWorkerManager::CheckReadyPromise(nsPIDOMWindow* aWindow,
                                         nsIURI* aURI, Promise* aPromise)
 {
+  MOZ_ASSERT(aWindow);
+  MOZ_ASSERT(aURI);
+
+  nsCOMPtr<nsIDocument> doc = aWindow->GetExtantDoc();
+  MOZ_ASSERT(doc);
+
+  nsCOMPtr<nsIPrincipal> principal = doc->NodePrincipal();
+  MOZ_ASSERT(principal);
+
   nsRefPtr<ServiceWorkerRegistrationInfo> registration =
-    GetServiceWorkerRegistrationInfo(aURI);
+    GetServiceWorkerRegistrationInfo(principal, aURI);
 
   if (registration && registration->mActiveWorker) {
     NS_ConvertUTF8toUTF16 scope(registration->mScope);
     nsRefPtr<ServiceWorkerRegistrationMainThread> swr =
       new ServiceWorkerRegistrationMainThread(aWindow, scope);
     aPromise->MaybeResolve(swr);
     return true;
   }
 
   return false;
 }
 
 already_AddRefed<ServiceWorker>
-ServiceWorkerManager::CreateServiceWorkerForScope(const nsACString& aScope)
+ServiceWorkerManager::CreateServiceWorkerForScope(uint32_t aAppId,
+                                                  bool aInBrowserElement,
+                                                  const nsACString& aScope)
 {
   AssertIsOnMainThread();
 
   nsCOMPtr<nsIURI> scopeURI;
   nsresult rv = NS_NewURI(getter_AddRefs(scopeURI), aScope, nullptr, nullptr);
   if (NS_FAILED(rv)) {
     return nullptr;
   }
-  nsRefPtr<ServiceWorkerRegistrationInfo> registration = GetServiceWorkerRegistrationInfo(scopeURI);
+  nsRefPtr<ServiceWorkerRegistrationInfo> registration =
+    GetServiceWorkerRegistrationInfo(aAppId, aInBrowserElement, scopeURI);
   if (!registration) {
     return nullptr;
   }
 
   if (!registration->mActiveWorker) {
     return nullptr;
   }
 
@@ -1909,30 +1961,30 @@ ServiceWorkerManager::CreateServiceWorke
   return sw.forget();
 }
 
 class ServiceWorkerUnregisterJob final : public ServiceWorkerJob
 {
   nsRefPtr<ServiceWorkerRegistrationInfo> mRegistration;
   const nsCString mScope;
   nsCOMPtr<nsIServiceWorkerUnregisterCallback> mCallback;
-  PrincipalInfo mPrincipalInfo;
+  nsCOMPtr<nsIPrincipal> mPrincipal;
 
   ~ServiceWorkerUnregisterJob()
   { }
 
 public:
   ServiceWorkerUnregisterJob(ServiceWorkerJobQueue* aQueue,
                              const nsACString& aScope,
                              nsIServiceWorkerUnregisterCallback* aCallback,
-                             PrincipalInfo& aPrincipalInfo)
+                             nsIPrincipal* aPrincipal)
     : ServiceWorkerJob(aQueue)
     , mScope(aScope)
     , mCallback(aCallback)
-    , mPrincipalInfo(aPrincipalInfo)
+    , mPrincipal(aPrincipal)
   {
     AssertIsOnMainThread();
   }
 
   void
   Start() override
   {
     AssertIsOnMainThread();
@@ -1943,32 +1995,50 @@ public:
 
 private:
   // You probably want UnregisterAndDone().
   nsresult
   Unregister()
   {
     AssertIsOnMainThread();
 
+    PrincipalInfo principalInfo;
+    if (NS_WARN_IF(NS_FAILED(PrincipalToPrincipalInfo(mPrincipal,
+                                                      &principalInfo)))) {
+      return mCallback ? mCallback->UnregisterSucceeded(false) : NS_OK;
+    }
+
     nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
 
+    nsAutoCString principalKey;
+    nsresult rv = swm->PrincipalToScopeKey(mPrincipal, principalKey);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return mCallback ? mCallback->UnregisterSucceeded(false) : NS_OK;
+    }
+
     // "Let registration be the result of running [[Get Registration]]
     // algorithm passing scope as the argument."
-    nsRefPtr<ServiceWorkerRegistrationInfo> registration;
-    if (!swm->mServiceWorkerRegistrationInfos.Get(mScope, getter_AddRefs(registration))) {
+    ServiceWorkerManager::RegistrationDataPerPrincipal* data;
+    if (!swm->mRegistrationInfos.Get(principalKey, &data)) {
       // "If registration is null, then, resolve promise with false."
       return mCallback ? mCallback->UnregisterSucceeded(false) : NS_OK;
     }
 
+    nsRefPtr<ServiceWorkerRegistrationInfo> registration;
+    if (!data->mInfos.Get(mScope, getter_AddRefs(registration))) {
+      // "If registration is null, then, resolve promise with false."
+      return mCallback ? mCallback->UnregisterSucceeded(false) : NS_OK;
+    }
+
     MOZ_ASSERT(registration);
 
     // "Set registration's uninstalling flag."
     registration->mPendingUninstall = true;
     // "Resolve promise with true"
-    nsresult rv = mCallback ? mCallback->UnregisterSucceeded(true) : NS_OK;
+    rv = mCallback ? mCallback->UnregisterSucceeded(true) : NS_OK;
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return rv;
     }
 
     // "If no service worker client is using registration..."
     if (!registration->IsControllingDocuments()) {
       // "If registration's uninstalling flag is set.."
       if (!registration->mPendingUninstall) {
@@ -1976,17 +2046,17 @@ private:
       }
 
       // "Invoke [[Clear Registration]]..."
       registration->Clear();
       swm->RemoveRegistration(registration);
     }
 
     MOZ_ASSERT(swm->mActor);
-    swm->mActor->SendUnregisterServiceWorker(mPrincipalInfo,
+    swm->mActor->SendUnregisterServiceWorker(principalInfo,
                                              NS_ConvertUTF8toUTF16(mScope));
 
     return NS_OK;
   }
 
   // The unregister job is done irrespective of success or failure of any sort.
   void
   UnregisterAndDone()
@@ -2017,24 +2087,18 @@ ServiceWorkerManager::Unregister(nsIPrin
     return NS_ERROR_DOM_SECURITY_ERR;
   }
 #endif
 
   NS_ConvertUTF16toUTF8 scope(aScope);
   ServiceWorkerJobQueue* queue = GetOrCreateJobQueue(scope);
   MOZ_ASSERT(queue);
 
-  PrincipalInfo principalInfo;
-  if (NS_WARN_IF(NS_FAILED(PrincipalToPrincipalInfo(aPrincipal,
-                                                    &principalInfo)))) {
-    return NS_ERROR_DOM_SECURITY_ERR;
-  }
-
   nsRefPtr<ServiceWorkerUnregisterJob> job =
-    new ServiceWorkerUnregisterJob(queue, scope, aCallback, principalInfo);
+    new ServiceWorkerUnregisterJob(queue, scope, aCallback, aPrincipal);
 
   if (mActor) {
     queue->Append(job);
     return NS_OK;
   }
 
   AppendPendingOperation(queue, job);
   return NS_OK;
@@ -2242,95 +2306,278 @@ ServiceWorkerManager::StoreRegistration(
   }
 
   mActor->SendRegisterServiceWorker(data);
 }
 
 already_AddRefed<ServiceWorkerRegistrationInfo>
 ServiceWorkerManager::GetServiceWorkerRegistrationInfo(nsPIDOMWindow* aWindow)
 {
+  MOZ_ASSERT(aWindow);
   nsCOMPtr<nsIDocument> document = aWindow->GetExtantDoc();
   return GetServiceWorkerRegistrationInfo(document);
 }
 
 already_AddRefed<ServiceWorkerRegistrationInfo>
 ServiceWorkerManager::GetServiceWorkerRegistrationInfo(nsIDocument* aDoc)
 {
+  MOZ_ASSERT(aDoc);
   nsCOMPtr<nsIURI> documentURI = aDoc->GetDocumentURI();
-  return GetServiceWorkerRegistrationInfo(documentURI);
+  nsCOMPtr<nsIPrincipal> principal = aDoc->NodePrincipal();
+  return GetServiceWorkerRegistrationInfo(principal, documentURI);
 }
 
 already_AddRefed<ServiceWorkerRegistrationInfo>
-ServiceWorkerManager::GetServiceWorkerRegistrationInfo(nsIURI* aURI)
+ServiceWorkerManager::GetServiceWorkerRegistrationInfo(nsIPrincipal* aPrincipal,
+                                                       nsIURI* aURI)
 {
-  nsCString spec;
+  MOZ_ASSERT(aPrincipal);
+  MOZ_ASSERT(aURI);
+
+  // No system principal for now.
+  if (nsContentUtils::IsSystemPrincipal(aPrincipal)) {
+    return nullptr;
+  }
+
+  bool isNullPrincipal = true;
+  nsresult rv = aPrincipal->GetIsNullPrincipal(&isNullPrincipal);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return nullptr;
+  }
+
+  // No null principals.
+  if (isNullPrincipal) {
+    return nullptr;
+  }
+
+  uint32_t appId;
+  rv = aPrincipal->GetAppId(&appId);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return nullptr;
+  }
+
+  bool inBrowserElement;
+  rv = aPrincipal->GetIsInBrowserElement(&inBrowserElement);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return nullptr;
+  }
+
+  return GetServiceWorkerRegistrationInfo(appId, inBrowserElement, aURI);
+}
+
+already_AddRefed<ServiceWorkerRegistrationInfo>
+ServiceWorkerManager::GetServiceWorkerRegistrationInfo(uint32_t aAppId,
+                                                       bool aInBrowserElement,
+                                                       nsIURI* aURI)
+{
+  MOZ_ASSERT(aURI);
+
+  nsAutoCString spec;
   nsresult rv = aURI->GetSpec(spec);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return nullptr;
   }
 
-  nsCString scope = FindScopeForPath(mOrderedScopes, spec);
-  if (scope.IsEmpty()) {
+  nsAutoCString scope;
+  RegistrationDataPerPrincipal* data;
+  if (!FindScopeForPath(aAppId, aInBrowserElement, spec, &data, scope)) {
     return nullptr;
   }
 
+  MOZ_ASSERT(data);
+
   nsRefPtr<ServiceWorkerRegistrationInfo> registration;
-  mServiceWorkerRegistrationInfos.Get(scope, getter_AddRefs(registration));
+  data->mInfos.Get(scope, getter_AddRefs(registration));
   // ordered scopes and registrations better be in sync.
   MOZ_ASSERT(registration);
 
   if (registration->mPendingUninstall) {
     return nullptr;
   }
   return registration.forget();
 }
 
+/* static */ nsresult
+ServiceWorkerManager::PrincipalToScopeKey(nsIPrincipal* aPrincipal,
+                                          nsACString& aKey)
+{
+  MOZ_ASSERT(aPrincipal);
+
+  // No system principal for now.
+  if (nsContentUtils::IsSystemPrincipal(aPrincipal)) {
+    return NS_ERROR_FAILURE;
+  }
+
+  nsresult rv;
+
+  bool isNullPrincipal = true;
+  rv = aPrincipal->GetIsNullPrincipal(&isNullPrincipal);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+
+  // No null principals.
+  if (isNullPrincipal) {
+    return NS_ERROR_FAILURE;
+  }
+
+  uint32_t appId;
+  rv = aPrincipal->GetAppId(&appId);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+
+  bool inBrowserElement;
+  rv = aPrincipal->GetIsInBrowserElement(&inBrowserElement);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+
+  CreateScopeKey(appId, inBrowserElement, aKey);
+  return NS_OK;
+}
+
 /* static */ void
-ServiceWorkerManager::AddScope(nsTArray<nsCString>& aList, const nsACString& aScope)
+ServiceWorkerManager::CreateScopeKey(int32_t aAppId, bool aInBrowserElement,
+                                     nsACString& aKey)
 {
-  for (uint32_t i = 0; i < aList.Length(); ++i) {
-    const nsCString& current = aList[i];
+  nsAutoCString key;
+  key.AppendInt(aAppId);
+  key.Append('-');
+
+  if (aInBrowserElement) {
+    key.AppendLiteral(SERVICEWORKERREGISTRAR_TRUE);
+  } else {
+    key.AppendLiteral(SERVICEWORKERREGISTRAR_FALSE);
+  }
+
+  aKey = key;
+}
+
+/* static */ void
+ServiceWorkerManager::AddScopeAndRegistration(nsIPrincipal* aPrincipal,
+                                              const nsACString& aScope,
+                                              ServiceWorkerRegistrationInfo* aInfo)
+{
+  MOZ_ASSERT(aInfo);
+
+  nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  MOZ_ASSERT(swm);
+
+  nsAutoCString principalKey;
+  nsresult rv = swm->PrincipalToScopeKey(aPrincipal, principalKey);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return;
+  }
+
+  RegistrationDataPerPrincipal* data;
+  if (!swm->mRegistrationInfos.Get(principalKey, &data)) {
+    data = new RegistrationDataPerPrincipal();
+    swm->mRegistrationInfos.Put(principalKey, data);
+  }
+
+  for (uint32_t i = 0; i < data->mOrderedScopes.Length(); ++i) {
+    const nsCString& current = data->mOrderedScopes[i];
 
     // Perfect match!
     if (aScope.Equals(current)) {
+      data->mInfos.Put(aScope, aInfo);
       return;
     }
 
     // Sort by length, with longest match first.
     // /foo/bar should be before /foo/
     // Similarly /foo/b is between the two.
     if (StringBeginsWith(aScope, current)) {
-      aList.InsertElementAt(i, aScope);
+      data->mOrderedScopes.InsertElementAt(i, aScope);
+      data->mInfos.Put(aScope, aInfo);
       return;
     }
   }
 
-  aList.AppendElement(aScope);
+  data->mOrderedScopes.AppendElement(aScope);
+  data->mInfos.Put(aScope, aInfo);
 }
 
-/* static */ nsCString
-ServiceWorkerManager::FindScopeForPath(nsTArray<nsCString>& aList, const nsACString& aPath)
+/* static */ bool
+ServiceWorkerManager::FindScopeForPath(uint32_t aAppId,
+                                       bool aInBrowserElement,
+                                       const nsACString& aPath,
+                                       RegistrationDataPerPrincipal** aData,
+                                       nsACString& aMatch)
 {
-  nsCString match;
-
-  for (uint32_t i = 0; i < aList.Length(); ++i) {
-    const nsCString& current = aList[i];
+  MOZ_ASSERT(aData);
+
+  nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  MOZ_ASSERT(swm);
+
+  nsAutoCString principalKey;
+  swm->CreateScopeKey(aAppId, aInBrowserElement, principalKey);
+
+  if (!swm->mRegistrationInfos.Get(principalKey, aData)) {
+    return false;
+  }
+
+  for (uint32_t i = 0; i < (*aData)->mOrderedScopes.Length(); ++i) {
+    const nsCString& current = (*aData)->mOrderedScopes[i];
     if (StringBeginsWith(aPath, current)) {
-      match = current;
-      break;
+      aMatch = current;
+      return true;
     }
   }
 
-  return match;
+  return false;
 }
 
+#ifdef DEBUG
+/* static */ bool
+ServiceWorkerManager::HasScope(nsIPrincipal* aPrincipal,
+                               const nsACString& aScope)
+{
+  nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  MOZ_ASSERT(swm);
+
+  nsAutoCString principalKey;
+  nsresult rv = swm->PrincipalToScopeKey(aPrincipal, principalKey);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return false;
+  }
+
+  RegistrationDataPerPrincipal* data;
+  if (!swm->mRegistrationInfos.Get(principalKey, &data)) {
+    return false;
+  }
+
+  return data->mOrderedScopes.Contains(aScope);
+}
+#endif
+
 /* static */ void
-ServiceWorkerManager::RemoveScope(nsTArray<nsCString>& aList, const nsACString& aScope)
+ServiceWorkerManager::RemoveScopeAndRegistration(ServiceWorkerRegistrationInfo* aRegistration)
 {
-  aList.RemoveElement(aScope);
+  nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  MOZ_ASSERT(swm);
+
+  nsAutoCString principalKey;
+  nsresult rv = swm->PrincipalToScopeKey(aRegistration->mPrincipal, principalKey);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return;
+  }
+
+  RegistrationDataPerPrincipal* data;
+  if (!swm->mRegistrationInfos.Get(principalKey, &data)) {
+    return;
+  }
+
+  data->mInfos.Remove(aRegistration->mScope);
+  data->mOrderedScopes.RemoveElement(aRegistration->mScope);
+
+  if (data->mOrderedScopes.IsEmpty()) {
+    swm->mRegistrationInfos.Remove(principalKey);
+  }
 }
 
 void
 ServiceWorkerManager::MaybeStartControlling(nsIDocument* aDoc)
 {
   AssertIsOnMainThread();
 
   // We keep a set of documents that service workers may choose to start
@@ -2385,25 +2632,29 @@ ServiceWorkerManager::StopControllingADo
       RemoveRegistration(aRegistration);
     } else {
       aRegistration->TryToActivate();
     }
   }
 }
 
 NS_IMETHODIMP
-ServiceWorkerManager::GetScopeForUrl(const nsAString& aUrl, nsAString& aScope)
+ServiceWorkerManager::GetScopeForUrl(nsIPrincipal* aPrincipal,
+                                     const nsAString& aUrl, nsAString& aScope)
 {
+  MOZ_ASSERT(aPrincipal);
+
   nsCOMPtr<nsIURI> uri;
   nsresult rv = NS_NewURI(getter_AddRefs(uri), aUrl, nullptr, nullptr);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return NS_ERROR_FAILURE;
   }
 
-  nsRefPtr<ServiceWorkerRegistrationInfo> r = GetServiceWorkerRegistrationInfo(uri);
+  nsRefPtr<ServiceWorkerRegistrationInfo> r =
+    GetServiceWorkerRegistrationInfo(aPrincipal, uri);
   if (!r) {
       return NS_ERROR_FAILURE;
   }
 
   aScope = NS_ConvertUTF8toUTF16(r->mScope);
   return NS_OK;
 }
 
@@ -2498,17 +2749,18 @@ ServiceWorkerManager::GetServiceWorkerFo
   nsCOMPtr<nsIPrincipal> documentPrincipal = doc->NodePrincipal();
   rv = documentPrincipal->CheckMayLoad(scopeURI, true /* report */,
                                        false /* allowIfInheritsPrinciple */);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return NS_ERROR_DOM_SECURITY_ERR;
   }
   ////////////////////////////////////////////
 
-  nsRefPtr<ServiceWorkerRegistrationInfo> registration = GetRegistration(scope);
+  nsRefPtr<ServiceWorkerRegistrationInfo> registration =
+    GetRegistration(documentPrincipal, scope);
   if (NS_WARN_IF(!registration)) {
     return NS_ERROR_FAILURE;
   }
 
   nsRefPtr<ServiceWorkerInfo> info;
   if (aWhichWorker == WhichServiceWorker::INSTALLING_WORKER) {
     info = registration->mInstallingWorker;
   } else if (aWhichWorker == WhichServiceWorker::WAITING_WORKER) {
@@ -2760,17 +3012,20 @@ private:
     }
     return true;
   }
 };
 
 NS_IMPL_ISUPPORTS_INHERITED(FetchEventRunnable, WorkerRunnable, nsIHttpHeaderVisitor)
 
 NS_IMETHODIMP
-ServiceWorkerManager::DispatchFetchEvent(nsIDocument* aDoc, nsIInterceptedChannel* aChannel,
+ServiceWorkerManager::DispatchFetchEvent(uint32_t aAppId,
+                                         bool aInBrowserElement,
+                                         nsIDocument* aDoc,
+                                         nsIInterceptedChannel* aChannel,
                                          bool aIsReload)
 {
   MOZ_ASSERT(aChannel);
   nsCOMPtr<nsISupports> serviceWorker;
 
   bool isNavigation = false;
   nsresult rv = aChannel->GetIsNavigation(&isNavigation);
   NS_ENSURE_SUCCESS(rv, rv);
@@ -2786,17 +3041,17 @@ ServiceWorkerManager::DispatchFetchEvent
     rv = aChannel->GetChannel(getter_AddRefs(internalChannel));
     NS_ENSURE_SUCCESS(rv, rv);
 
     nsCOMPtr<nsIURI> uri;
     rv = internalChannel->GetURI(getter_AddRefs(uri));
     NS_ENSURE_SUCCESS(rv, rv);
 
     nsRefPtr<ServiceWorkerRegistrationInfo> registration =
-      GetServiceWorkerRegistrationInfo(uri);
+      GetServiceWorkerRegistrationInfo(aAppId, aInBrowserElement, uri);
     if (!registration) {
       NS_WARNING("No registration found when dispatching the fetch event");
       return NS_ERROR_FAILURE;
     }
     // This should only happen if IsAvailableForURI() returned true.
     MOZ_ASSERT(registration->mActiveWorker);
 
     nsRefPtr<ServiceWorker> sw;
@@ -2814,36 +3069,38 @@ ServiceWorkerManager::DispatchFetchEvent
     new nsMainThreadPtrHolder<nsIInterceptedChannel>(aChannel, false));
 
   nsRefPtr<ServiceWorker> sw = static_cast<ServiceWorker*>(serviceWorker.get());
   nsMainThreadPtrHandle<ServiceWorker> serviceWorkerHandle(
     new nsMainThreadPtrHolder<ServiceWorker>(sw));
 
   // clientInfo is null if we don't have a controlled document
   nsRefPtr<FetchEventRunnable> event =
-    new FetchEventRunnable(sw->GetWorkerPrivate(), handle, serviceWorkerHandle, clientInfo, aIsReload);
+    new FetchEventRunnable(sw->GetWorkerPrivate(), handle, serviceWorkerHandle,
+                           clientInfo, aIsReload);
   rv = event->Init();
   NS_ENSURE_SUCCESS(rv, rv);
 
   AutoJSAPI api;
   api.Init();
   if (NS_WARN_IF(!event->Dispatch(api.cx()))) {
     return NS_ERROR_FAILURE;
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
-ServiceWorkerManager::IsAvailableForURI(nsIURI* aURI, bool* aIsAvailable)
+ServiceWorkerManager::IsAvailableForURI(uint32_t aAppId, bool aInBrowserElement,
+                                        nsIURI* aURI, bool* aIsAvailable)
 {
   MOZ_ASSERT(aURI);
   MOZ_ASSERT(aIsAvailable);
   nsRefPtr<ServiceWorkerRegistrationInfo> registration =
-    GetServiceWorkerRegistrationInfo(aURI);
+    GetServiceWorkerRegistrationInfo(aAppId, aInBrowserElement, aURI);
   *aIsAvailable = registration && registration->mActiveWorker;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerManager::IsControlled(nsIDocument* aDoc, bool* aIsControlled)
 {
   MOZ_ASSERT(aDoc);
@@ -3014,23 +3271,24 @@ ServiceWorkerManager::InvalidateServiceW
 
     if (utf8Scope.Equals(aRegistration->mScope)) {
       target->InvalidateWorkers(aWhichOnes);
     }
   }
 }
 
 NS_IMETHODIMP
-ServiceWorkerManager::SoftUpdate(const nsAString& aScope)
+ServiceWorkerManager::SoftUpdate(uint32_t aAppId, bool aInBrowserElement,
+                                 const nsAString& aScope)
 {
   AssertIsOnMainThread();
   NS_ConvertUTF16toUTF8 scope(aScope);
 
-  nsRefPtr<ServiceWorkerRegistrationInfo> registration;
-  mServiceWorkerRegistrationInfos.Get(scope, getter_AddRefs(registration));
+  nsRefPtr<ServiceWorkerRegistrationInfo> registration =
+    GetRegistration(aAppId, aInBrowserElement, scope);
   if (NS_WARN_IF(!registration)) {
     return NS_OK;
   }
 
   // "If registration's uninstalling flag is set, abort these steps."
   if (registration->mPendingUninstall) {
     return NS_OK;
   }
@@ -3162,20 +3420,24 @@ ClaimMatchingClients(nsISupportsHashKey*
 
   swm->MaybeClaimClient(document, workerRegistration);
 
   return PL_DHASH_NEXT;
 }
 } // anonymous namespace
 
 void
-ServiceWorkerManager::GetAllClients(const nsCString& aScope,
+ServiceWorkerManager::GetAllClients(nsIPrincipal* aPrincipal,
+                                    const nsCString& aScope,
                                     nsTArray<ServiceWorkerClientInfo>& aControlledDocuments)
 {
-  nsRefPtr<ServiceWorkerRegistrationInfo> registration = GetRegistration(aScope);
+  MOZ_ASSERT(aPrincipal);
+
+  nsRefPtr<ServiceWorkerRegistrationInfo> registration =
+    GetRegistration(aPrincipal, aScope);
 
   if (!registration) {
     // The registration was removed, leave the array empty.
     return;
   }
 
   FilterRegistrationData data(aControlledDocuments, registration);
 
@@ -3211,20 +3473,21 @@ ServiceWorkerManager::MaybeClaimClient(n
     StopControllingADocument(controllingRegistration);
   }
 
   StartControllingADocument(aWorkerRegistration, aDocument);
   FireControllerChangeOnDocument(aDocument);
 }
 
 nsresult
-ServiceWorkerManager::ClaimClients(const nsCString& aScope, uint64_t aId)
+ServiceWorkerManager::ClaimClients(nsIPrincipal* aPrincipal,
+                                   const nsCString& aScope, uint64_t aId)
 {
   nsRefPtr<ServiceWorkerRegistrationInfo> registration =
-    GetRegistration(aScope);
+    GetRegistration(aPrincipal, aScope);
 
   if (!registration || !registration->mActiveWorker ||
       !(registration->mActiveWorker->ID() == aId)) {
     // The worker is not active.
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
   mAllDocuments.EnumerateEntries(ClaimMatchingClients, registration);
@@ -3233,31 +3496,70 @@ ServiceWorkerManager::ClaimClients(const
 }
 
 void
 ServiceWorkerManager::FireControllerChange(ServiceWorkerRegistrationInfo* aRegistration)
 {
   mControlledDocuments.EnumerateRead(FireControllerChangeOnMatchingDocument, aRegistration);
 }
 
+already_AddRefed<ServiceWorkerRegistrationInfo>
+ServiceWorkerManager::GetRegistration(nsIPrincipal* aPrincipal,
+                                      const nsCString& aScope) const
+{
+  MOZ_ASSERT(aPrincipal);
+
+  uint32_t appId;
+  nsresult rv = aPrincipal->GetAppId(&appId);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return nullptr;
+  }
+
+  bool inBrowserElement;
+  rv = aPrincipal->GetIsInBrowserElement(&inBrowserElement);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return nullptr;
+  }
+
+  return GetRegistration(appId, inBrowserElement, aScope);
+}
+
+already_AddRefed<ServiceWorkerRegistrationInfo>
+ServiceWorkerManager::GetRegistration(uint32_t aAppId, bool aInBrowserElement,
+                                      const nsCString& aScope) const
+{
+  nsRefPtr<ServiceWorkerRegistrationInfo> reg;
+
+  nsAutoCString scopeKey;
+  CreateScopeKey(aAppId, aInBrowserElement, scopeKey);
+
+  RegistrationDataPerPrincipal* data;
+  if (!mRegistrationInfos.Get(scopeKey, &data)) {
+    return reg.forget();
+  }
+
+  data->mInfos.Get(aScope, getter_AddRefs(reg));
+  return reg.forget();
+}
+
 ServiceWorkerRegistrationInfo*
 ServiceWorkerManager::CreateNewRegistration(const nsCString& aScope,
                                             nsIPrincipal* aPrincipal)
 {
 #ifdef DEBUG
   AssertIsOnMainThread();
   nsCOMPtr<nsIURI> scopeURI;
   nsresult rv = NS_NewURI(getter_AddRefs(scopeURI), aScope, nullptr, nullptr);
   MOZ_ASSERT(NS_SUCCEEDED(rv));
 #endif
+
   ServiceWorkerRegistrationInfo* registration = new ServiceWorkerRegistrationInfo(aScope, aPrincipal);
   // From now on ownership of registration is with
   // mServiceWorkerRegistrationInfos.
-  mServiceWorkerRegistrationInfos.Put(aScope, registration);
-  AddScope(mOrderedScopes, aScope);
+  AddScopeAndRegistration(aPrincipal, aScope, registration);
   return registration;
 }
 
 void
 ServiceWorkerManager::MaybeRemoveRegistration(ServiceWorkerRegistrationInfo* aRegistration)
 {
   MOZ_ASSERT(aRegistration);
   nsRefPtr<ServiceWorkerInfo> newest = aRegistration->Newest();
@@ -3266,18 +3568,16 @@ ServiceWorkerManager::MaybeRemoveRegistr
   }
 }
 
 void
 ServiceWorkerManager::RemoveRegistrationInternal(ServiceWorkerRegistrationInfo* aRegistration)
 {
   MOZ_ASSERT(aRegistration);
   MOZ_ASSERT(!aRegistration->IsControllingDocuments());
-  MOZ_ASSERT(mServiceWorkerRegistrationInfos.Contains(aRegistration->mScope));
-  ServiceWorkerManager::RemoveScope(mOrderedScopes, aRegistration->mScope);
 
   // All callers should be either from a job in which case the actor is
   // available, or from MaybeStopControlling(), in which case, this will only be
   // called if a valid registration is found. If a valid registration exists,
   // it means the actor is available since the original map of registrations is
   // populated by it, and any new registrations wait until the actor is
   // available before proceeding (See ServiceWorkerRegisterJob::Start).
   MOZ_ASSERT(mActor);
@@ -3285,17 +3585,19 @@ ServiceWorkerManager::RemoveRegistration
   PrincipalInfo principalInfo;
   if (NS_WARN_IF(NS_FAILED(PrincipalToPrincipalInfo(aRegistration->mPrincipal,
                                                     &principalInfo)))) {
     //XXXnsm I can't think of any other reason a stored principal would fail to
     //convert.
     NS_WARNING("Unable to unregister serviceworker due to possible OOM");
     return;
   }
-  mActor->SendUnregisterServiceWorker(principalInfo, NS_ConvertUTF8toUTF16(aRegistration->mScope));
+
+  mActor->SendUnregisterServiceWorker(principalInfo,
+                                      NS_ConvertUTF8toUTF16(aRegistration->mScope));
 }
 
 class ServiceWorkerDataInfo final : public nsIServiceWorkerInfo
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSISERVICEWORKERINFO
 
@@ -3315,18 +3617,18 @@ private:
   nsString mCurrentWorkerURL;
   nsString mActiveCacheName;
   nsString mWaitingCacheName;
 };
 void
 ServiceWorkerManager::RemoveRegistration(ServiceWorkerRegistrationInfo* aRegistration)
 {
   RemoveRegistrationInternal(aRegistration);
-  MOZ_ASSERT(mServiceWorkerRegistrationInfos.Contains(aRegistration->mScope));
-  mServiceWorkerRegistrationInfos.Remove(aRegistration->mScope);
+  MOZ_ASSERT(HasScope(aRegistration->mPrincipal, aRegistration->mScope));
+  RemoveScopeAndRegistration(aRegistration);
 }
 
 namespace {
 /**
  * See browser/components/sessionstore/Utils.jsm function hasRootDomain().
  *
  * Returns true if the |url| passed in is part of the given root |domain|.
  * For example, if |url| is "www.mozilla.org", and we pass in |domain| as
@@ -3390,16 +3692,27 @@ UnregisterIfMatchesHost(const nsACString
 
   if (toRemove) {
     nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
     swm->ForceUnregister(toRemove);
   }
 
   return PL_DHASH_NEXT;
 }
+
+// If host/aData is null, unconditionally unregisters.
+PLDHashOperator
+UnregisterIfMatchesHostPerPrincipal(const nsACString& aKey,
+                                    ServiceWorkerManager::RegistrationDataPerPrincipal* aData,
+                                    void* aUserData)
+{
+  aData->mInfos.EnumerateRead(UnregisterIfMatchesHost, aUserData);
+  return PL_DHASH_NEXT;
+}
+
 } // anonymous namespace
 NS_IMPL_ISUPPORTS(ServiceWorkerDataInfo, nsIServiceWorkerInfo)
 
 /* static */ already_AddRefed<ServiceWorkerDataInfo>
 ServiceWorkerDataInfo::Create(const ServiceWorkerRegistrationData& aData)
 {
   AssertIsOnMainThread();
 
@@ -3511,46 +3824,69 @@ ServiceWorkerManager::ForceUnregister(Se
   // Since Unregister is async, it is ok to call it in an enumeration.
   Unregister(aRegistration->mPrincipal, nullptr, NS_ConvertUTF8toUTF16(aRegistration->mScope));
 }
 
 NS_IMETHODIMP
 ServiceWorkerManager::Remove(const nsACString& aHost)
 {
   AssertIsOnMainThread();
-  mServiceWorkerRegistrationInfos.EnumerateRead(UnregisterIfMatchesHost, &const_cast<nsACString&>(aHost));
+  mRegistrationInfos.EnumerateRead(UnregisterIfMatchesHostPerPrincipal,
+                                   &const_cast<nsACString&>(aHost));
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerManager::RemoveAll()
 {
   AssertIsOnMainThread();
-  mServiceWorkerRegistrationInfos.EnumerateRead(UnregisterIfMatchesHost, nullptr);
+  mRegistrationInfos.EnumerateRead(UnregisterIfMatchesHostPerPrincipal, nullptr);
   return NS_OK;
 }
 
 static PLDHashOperator
 UpdateEachRegistration(const nsACString& aKey,
                        ServiceWorkerRegistrationInfo* aInfo,
                        void* aUserArg) {
   auto This = static_cast<ServiceWorkerManager*>(aUserArg);
   MOZ_ASSERT(!aInfo->mScope.IsEmpty());
-  nsresult res = This->SoftUpdate(NS_ConvertUTF8toUTF16(aInfo->mScope));
+
+  uint32_t appId;
+  nsresult rv = aInfo->mPrincipal->GetAppId(&appId);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return PL_DHASH_NEXT;
+  }
+
+  bool inBrowserElement;
+  rv = aInfo->mPrincipal->GetIsInBrowserElement(&inBrowserElement);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return PL_DHASH_NEXT;
+  }
+
+  nsresult res = This->SoftUpdate(appId, inBrowserElement,
+                                  NS_ConvertUTF8toUTF16(aInfo->mScope));
   unused << NS_WARN_IF(NS_FAILED(res));
 
   return PL_DHASH_NEXT;
 }
 
+static PLDHashOperator
+UpdateEachRegistrationPerPrincipal(const nsACString& aKey,
+                                   ServiceWorkerManager::RegistrationDataPerPrincipal* aData,
+                                   void* aUserArg) {
+  aData->mInfos.EnumerateRead(UpdateEachRegistration, aUserArg);
+  return PL_DHASH_NEXT;
+}
+
 NS_IMETHODIMP
 ServiceWorkerManager::UpdateAllRegistrations()
 {
   AssertIsOnMainThread();
 
-  mServiceWorkerRegistrationInfos.EnumerateRead(UpdateEachRegistration, this);
+  mRegistrationInfos.EnumerateRead(UpdateEachRegistrationPerPrincipal, this);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerManager::Observe(nsISupports* aSubject,
                               const char* aTopic,
                               const char16_t* aData)
diff --git a/dom/workers/ServiceWorkerManager.h b/dom/workers/ServiceWorkerManager.h
--- a/dom/workers/ServiceWorkerManager.h
+++ b/dom/workers/ServiceWorkerManager.h
@@ -359,48 +359,36 @@ public:
   {
     AssertIsOnMainThread();
 
     ServiceWorkerManager* res = new ServiceWorkerManager;
     NS_ADDREF(res);
     return res;
   }
 
-  // Ordered list of scopes for glob matching.
-  // Each entry is an absolute URL representing the scope.
-  //
-  // An array is used for now since the number of controlled scopes per
-  // domain is expected to be relatively low. If that assumption was proved
-  // wrong this should be replaced with a better structure to avoid the
-  // memmoves associated with inserting stuff in the middle of the array.
-  nsTArray<nsCString> mOrderedScopes;
-
-  // Scope to registration.
-  // The scope should be a fully qualified valid URL.
-  nsRefPtrHashtable<nsCStringHashKey, ServiceWorkerRegistrationInfo> mServiceWorkerRegistrationInfos;
+  struct RegistrationDataPerPrincipal;
+  nsClassHashtable<nsCStringHashKey, RegistrationDataPerPrincipal> mRegistrationInfos;
 
   nsTObserverArray<ServiceWorkerRegistrationListener*> mServiceWorkerRegistrationListeners;
 
   nsRefPtrHashtable<nsISupportsHashKey, ServiceWorkerRegistrationInfo> mControlledDocuments;
 
   // Set of all documents that may be controlled by a service worker.
   nsTHashtable<nsISupportsHashKey> mAllDocuments;
 
   // Maps scopes to job queues.
   nsClassHashtable<nsCStringHashKey, ServiceWorkerJobQueue> mJobQueues;
 
   nsDataHashtable<nsCStringHashKey, bool> mSetOfScopesBeingUpdated;
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
-  GetRegistration(const nsCString& aScope) const
-  {
-    nsRefPtr<ServiceWorkerRegistrationInfo> reg;
-    mServiceWorkerRegistrationInfos.Get(aScope, getter_AddRefs(reg));
-    return reg.forget();
-  }
+  GetRegistration(nsIPrincipal* aPrincipal, const nsCString& aScope) const;
+
+  already_AddRefed<ServiceWorkerRegistrationInfo>
+  GetRegistration(uint32_t aAppId, bool aInBrowserElement, const nsCString& aScope) const;
 
   ServiceWorkerRegistrationInfo*
   CreateNewRegistration(const nsCString& aScope, nsIPrincipal* aPrincipal);
 
   void
   RemoveRegistration(ServiceWorkerRegistrationInfo* aRegistration);
 
   ServiceWorkerJobQueue*
@@ -424,25 +412,26 @@ public:
               nsString aMessage,
               nsString aFilename,
               nsString aLine,
               uint32_t aLineNumber,
               uint32_t aColumnNumber,
               uint32_t aFlags);
 
   void
-  GetAllClients(const nsCString& aScope,
+  GetAllClients(nsIPrincipal* aPrincipal,
+                const nsCString& aScope,
                 nsTArray<ServiceWorkerClientInfo>& aControlledDocuments);
 
   void
   MaybeClaimClient(nsIDocument* aDocument,
                    ServiceWorkerRegistrationInfo* aWorkerRegistration);
 
   nsresult
-  ClaimClients(const nsCString& aScope, uint64_t aId);
+  ClaimClients(nsIPrincipal* aPrincipal, const nsCString& aScope, uint64_t aId);
 
   static already_AddRefed<ServiceWorkerManager>
   GetInstance();
 
  void LoadRegistrations(
                  const nsTArray<ServiceWorkerRegistrationData>& aRegistrations);
 
   // Used by remove() and removeAll() when clearing history.
@@ -482,17 +471,18 @@ private:
 
   NS_IMETHODIMP
   GetServiceWorkerForScope(nsIDOMWindow* aWindow,
                            const nsAString& aScope,
                            WhichServiceWorker aWhichWorker,
                            nsISupports** aServiceWorker);
 
   already_AddRefed<ServiceWorker>
-  CreateServiceWorkerForScope(const nsACString& aScope);
+  CreateServiceWorkerForScope(uint32_t aAppId, bool aInBrowserElement,
+                              const nsACString& aScope);
 
   void
   InvalidateServiceWorkerRegistrationWorker(ServiceWorkerRegistrationInfo* aRegistration,
                                             WhichServiceWorker aWhichOnes);
 
   void
   StartControllingADocument(ServiceWorkerRegistrationInfo* aRegistration,
                             nsIDocument* aDoc);
@@ -502,26 +492,49 @@ private:
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
   GetServiceWorkerRegistrationInfo(nsPIDOMWindow* aWindow);
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
   GetServiceWorkerRegistrationInfo(nsIDocument* aDoc);
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
-  GetServiceWorkerRegistrationInfo(nsIURI* aURI);
+  GetServiceWorkerRegistrationInfo(nsIPrincipal* aPrincipal, nsIURI* aURI);
+
+  already_AddRefed<ServiceWorkerRegistrationInfo>
+  GetServiceWorkerRegistrationInfo(uint32_t aAppId, bool aInBrowserElement,
+                                   nsIURI* aURI);
+
+  // This method generates a key using appId and isInElementBrowser
+  static void
+  CreateScopeKey(int32_t aAppId, bool aInBrowserElement,
+                 nsACString& aPrincipalKey);
+
+  // This method generates a key using appId and isInElementBrowser from the
+  // principal. We don't use the origin because it can simple change during the
+  // loading.
+  static nsresult
+  PrincipalToScopeKey(nsIPrincipal* aPrincipal, nsACString& aPrincipalKey);
 
   static void
-  AddScope(nsTArray<nsCString>& aList, const nsACString& aScope);
+  AddScopeAndRegistration(nsIPrincipal* aPrincipal, const nsACString& aScope,
+                          ServiceWorkerRegistrationInfo* aRegistation);
 
-  static nsCString
-  FindScopeForPath(nsTArray<nsCString>& aList, const nsACString& aPath);
+  static bool
+  FindScopeForPath(uint32_t aAppId, bool aInBrowserElement,
+                   const nsACString& aPath,
+                   RegistrationDataPerPrincipal** aData, nsACString& aMatch);
+
+#ifdef DEBUG
+  static bool
+  HasScope(nsIPrincipal* aPrincipal, const nsACString& aScope);
+#endif
 
   static void
-  RemoveScope(nsTArray<nsCString>& aList, const nsACString& aScope);
+  RemoveScopeAndRegistration(ServiceWorkerRegistrationInfo* aRegistration);
 
   void
   QueueFireEventOnServiceWorkerRegistrations(ServiceWorkerRegistrationInfo* aRegistration,
                                              const nsAString& aName);
 
   void
   FireUpdateFoundOnServiceWorkerRegistrations(ServiceWorkerRegistrationInfo* aRegistration);
 
diff --git a/dom/workers/ServiceWorkerRegistration.cpp b/dom/workers/ServiceWorkerRegistration.cpp
--- a/dom/workers/ServiceWorkerRegistration.cpp
+++ b/dom/workers/ServiceWorkerRegistration.cpp
@@ -228,45 +228,123 @@ ServiceWorkerRegistrationMainThread::Inv
   if (aWhichOnes & WhichServiceWorker::ACTIVE_WORKER) {
     mActiveWorker = nullptr;
   }
 }
 
 namespace {
 
 void
-UpdateInternal(const nsAString& aScope)
+UpdateInternal(nsIPrincipal* aPrincipal, const nsAString& aScope)
 {
   AssertIsOnMainThread();
+  MOZ_ASSERT(aPrincipal);
+
   nsCOMPtr<nsIServiceWorkerManager> swm =
     mozilla::services::GetServiceWorkerManager();
   MOZ_ASSERT(swm);
+
+  uint32_t appId;
+  nsresult rv = aPrincipal->GetAppId(&appId);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return;
+  }
+
+  bool inBrowserElement;
+  rv = aPrincipal->GetIsInBrowserElement(&inBrowserElement);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return;
+  }
+
   // The spec defines ServiceWorkerRegistration.update() exactly as Soft Update.
-  swm->SoftUpdate(aScope);
+  swm->SoftUpdate(appId, inBrowserElement, aScope);
 }
 
+// This Runnable needs to have a valid WorkerPrivate. For this reason it is also
+// a WorkerFeature that is registered before dispatching itself to the
+// main-thread and it's removed with ReleaseRunnable when the operation is
+// completed. This will keep the worker alive as long as necessary.
 class UpdateRunnable final : public nsRunnable
+                           , public WorkerFeature
 {
 public:
-  explicit UpdateRunnable(const nsAString& aScope)
-    : mScope(aScope)
+  UpdateRunnable(WorkerPrivate* aWorkerPrivate, const nsAString& aScope)
+    : mWorkerPrivate(aWorkerPrivate)
+    , mScope(aScope)
   {}
 
   NS_IMETHOD
   Run() override
   {
     AssertIsOnMainThread();
-    UpdateInternal(mScope);
+    UpdateInternal(mWorkerPrivate->GetPrincipal(), mScope);
+
+    class ReleaseRunnable final : public MainThreadWorkerControlRunnable
+    {
+      nsRefPtr<UpdateRunnable> mRunnable;
+
+    public:
+      ReleaseRunnable(WorkerPrivate* aWorkerPrivate,
+                      UpdateRunnable* aRunnable)
+        : MainThreadWorkerControlRunnable(aWorkerPrivate)
+        , mRunnable(aRunnable)
+      {
+        MOZ_ASSERT(aRunnable);
+      }
+
+      virtual bool
+      WorkerRun(JSContext* aCx,
+                workers::WorkerPrivate* aWorkerPrivate) override
+      {
+        MOZ_ASSERT(aWorkerPrivate);
+        aWorkerPrivate->AssertIsOnWorkerThread();
+
+        aWorkerPrivate->RemoveFeature(aCx, mRunnable);
+        return true;
+      }
+
+    private:
+      ~ReleaseRunnable()
+      {}
+    };
+
+    nsRefPtr<WorkerControlRunnable> runnable =
+      new ReleaseRunnable(mWorkerPrivate, this);
+    runnable->Dispatch(nullptr);
+
     return NS_OK;
   }
 
+  virtual bool Notify(JSContext* aCx, workers::Status aStatus) override
+  {
+    // We don't care about the notification. We just want to keep the
+    // mWorkerPrivate alive.
+    return true;
+  }
+
+  bool
+  Dispatch()
+  {
+    mWorkerPrivate->AssertIsOnWorkerThread();
+
+    JSContext* cx = mWorkerPrivate->GetJSContext();
+
+    if (NS_WARN_IF(!mWorkerPrivate->AddFeature(cx, this))) {
+      return false;
+    }
+
+    NS_SUCCEEDED(NS_DispatchToMainThread(this));
+    return true;
+  }
+
 private:
   ~UpdateRunnable()
   {}
 
+  WorkerPrivate* mWorkerPrivate;
   const nsString mScope;
 };
 
 class UnregisterCallback final : public nsIServiceWorkerUnregisterCallback
 {
   nsRefPtr<Promise> mPromise;
 
 public:
@@ -449,17 +527,23 @@ public:
     return NS_OK;
   }
 };
 } // anonymous namespace
 
 void
 ServiceWorkerRegistrationMainThread::Update()
 {
-  UpdateInternal(mScope);
+  nsCOMPtr<nsIDocument> doc = GetOwner()->GetExtantDoc();
+  MOZ_ASSERT(doc);
+
+  nsCOMPtr<nsIPrincipal> principal = doc->NodePrincipal();
+  MOZ_ASSERT(principal);
+
+  UpdateInternal(principal, mScope);
 }
 
 already_AddRefed<Promise>
 ServiceWorkerRegistrationMainThread::Unregister(ErrorResult& aRv)
 {
   AssertIsOnMainThread();
   nsCOMPtr<nsIGlobalObject> go = do_QueryInterface(GetOwner());
   if (!go) {
@@ -731,23 +815,22 @@ ServiceWorkerRegistrationWorkerThread::G
 {
   // FIXME(nsm): Will be implemented after Bug 1113522.
   return nullptr;
 }
 
 void
 ServiceWorkerRegistrationWorkerThread::Update()
 {
-#ifdef DEBUG
   WorkerPrivate* worker = GetCurrentThreadWorkerPrivate();
   MOZ_ASSERT(worker);
   worker->AssertIsOnWorkerThread();
-#endif
-  nsCOMPtr<nsIRunnable> r = new UpdateRunnable(mScope);
-  MOZ_ALWAYS_TRUE(NS_SUCCEEDED(NS_DispatchToMainThread(r)));
+
+  nsRefPtr<UpdateRunnable> r = new UpdateRunnable(worker, mScope);
+  r->Dispatch();
 }
 
 already_AddRefed<Promise>
 ServiceWorkerRegistrationWorkerThread::Unregister(ErrorResult& aRv)
 {
   WorkerPrivate* worker = GetCurrentThreadWorkerPrivate();
   MOZ_ASSERT(worker);
   worker->AssertIsOnWorkerThread();
diff --git a/toolkit/content/aboutServiceWorkers.js b/toolkit/content/aboutServiceWorkers.js
--- a/toolkit/content/aboutServiceWorkers.js
+++ b/toolkit/content/aboutServiceWorkers.js
@@ -127,17 +127,18 @@ function display(info) {
     error => {
       dump("about:serviceworkers - push registration failed\n");
     }
   );
 
   let updateButton = document.createElement("button");
   updateButton.appendChild(document.createTextNode(bundle.GetStringFromName('update')));
   updateButton.onclick = function() {
-    gSWM.softUpdate(info.scope);
+    gSWM.softUpdate(info.principal.appId, info.principal.isInBrowserElement,
+                    info.scope);
   };
   div.appendChild(updateButton);
 
   let unregisterButton = document.createElement("button");
   unregisterButton.appendChild(document.createTextNode(bundle.GetStringFromName('unregister')));
   div.appendChild(unregisterButton);
 
   let loadingMessage = document.createElement('span');
