# HG changeset patch
# User Catalin Badea <catalin.badea392@gmail.com>

Bug 1130684 - Implement Service Worker clients.claim.

diff --git a/dom/webidl/Clients.webidl b/dom/webidl/Clients.webidl
index 1ae5dd6..c000b13 100644
--- a/dom/webidl/Clients.webidl
+++ b/dom/webidl/Clients.webidl
@@ -9,16 +9,17 @@
  */
 
 [Exposed=ServiceWorker]
 interface Clients {
   // The objects returned will be new instances every time
   [Throws]
   Promise<sequence<Client>?> matchAll(optional ClientQueryOptions options);
   Promise<WindowClient> openWindow(USVString url);
+  [Throws]
   Promise<void> claim();
 };
 
 dictionary ClientQueryOptions {
   boolean includeUncontrolled = false;
   ClientType type = "window";
 };
 
diff --git a/dom/workers/RuntimeService.cpp b/dom/workers/RuntimeService.cpp
index cf81597..e6c6ed3 100644
--- a/dom/workers/RuntimeService.cpp
+++ b/dom/workers/RuntimeService.cpp
@@ -2390,16 +2390,17 @@ RuntimeService::CreateSharedWorkerFromLoadInfo(JSContext* aCx,
                                                const nsAString& aScriptURL,
                                                const nsACString& aName,
                                                WorkerType aType,
                                                SharedWorker** aSharedWorker)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aLoadInfo);
   MOZ_ASSERT(aLoadInfo->mResolvedScriptURI);
+  MOZ_ASSERT_IF(aType == WorkerTypeService, aLoadInfo->mServiceWorkerID > 0);
 
   nsRefPtr<WorkerPrivate> workerPrivate;
   {
     MutexAutoLock lock(mMutex);
 
     WorkerDomainInfo* domainInfo;
     SharedWorkerInfo* sharedWorkerInfo;
 
diff --git a/dom/workers/ServiceWorkerClients.cpp b/dom/workers/ServiceWorkerClients.cpp
index dafa84b..749fb5e 100644
--- a/dom/workers/ServiceWorkerClients.cpp
+++ b/dom/workers/ServiceWorkerClients.cpp
@@ -131,16 +131,100 @@ public:
     if (!releaseRunnable->Dispatch(cx)) {
       NS_RUNTIMEABORT("Failed to dispatch MatchAll promise control runnable.");
     }
 
     return NS_OK;
   }
 };
 
+class ResolveClaimRunnable final : public WorkerRunnable
+{
+  nsRefPtr<PromiseWorkerProxy> mPromiseProxy;
+  nsresult mResult;
+
+public:
+  ResolveClaimRunnable(WorkerPrivate* aWorkerPrivate,
+                       PromiseWorkerProxy* aPromiseProxy,
+                       nsresult aResult)
+    : WorkerRunnable(aWorkerPrivate, WorkerThreadModifyBusyCount)
+    , mPromiseProxy(aPromiseProxy)
+    , mResult(aResult)
+  {
+    AssertIsOnMainThread();
+  }
+
+  bool
+  WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
+  {
+    MOZ_ASSERT(aWorkerPrivate);
+    aWorkerPrivate->AssertIsOnWorkerThread();
+
+    Promise* promise = mPromiseProxy->GetWorkerPromise();
+    MOZ_ASSERT(promise);
+
+    if (NS_SUCCEEDED(mResult)) {
+      promise->MaybeResolve(JS::UndefinedHandleValue);
+    } else {
+      promise->MaybeReject(NS_ERROR_DOM_INVALID_STATE_ERR);
+    }
+
+    // Release the reference on the worker thread.
+    mPromiseProxy->CleanUp(aCx);
+
+    return true;
+  }
+};
+
+class ClaimRunnable final : public nsRunnable
+{
+  nsRefPtr<PromiseWorkerProxy> mPromiseProxy;
+  nsCString mScope;
+
+public:
+  ClaimRunnable(PromiseWorkerProxy* aPromiseProxy, const nsCString& aScope)
+    : mPromiseProxy(aPromiseProxy)
+    , mScope(aScope)
+  {
+    MOZ_ASSERT(aPromiseProxy);
+  }
+
+  NS_IMETHOD
+  Run() override
+  {
+    nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+    WorkerPrivate* workerPrivate = mPromiseProxy->GetWorkerPrivate();
+    MOZ_ASSERT(swm);
+    MOZ_ASSERT(workerPrivate);
+
+    nsresult rv = swm->ClaimClients(mScope, workerPrivate->ServiceWorkerID());
+
+    nsRefPtr<ResolveClaimRunnable> r =
+      new ResolveClaimRunnable(workerPrivate, mPromiseProxy, rv);
+
+    AutoJSAPI jsapi;
+    jsapi.Init();
+    JSContext* cx = jsapi.cx();
+    if (r->Dispatch(cx)) {
+      return NS_OK;
+    }
+
+    // Dispatch to worker thread failed because the worker is shutting down.
+    // Use a control runnable to release the runnable on the worker thread.
+    nsRefPtr<PromiseWorkerProxyControlRunnable> releaseRunnable =
+      new PromiseWorkerProxyControlRunnable(workerPrivate, mPromiseProxy);
+
+    if (!releaseRunnable->Dispatch(cx)) {
+      NS_RUNTIMEABORT("Failed to dispatch Claim control runnable.");
+    }
+
+    return NS_OK;
+  }
+};
+
 } // anonymous namespace
 
 already_AddRefed<Promise>
 ServiceWorkerClients::MatchAll(const ClientQueryOptions& aOptions,
                                ErrorResult& aRv)
 {
   WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
   MOZ_ASSERT(workerPrivate);
@@ -188,19 +272,38 @@ ServiceWorkerClients::OpenWindow(const nsAString& aUrl)
     return nullptr;
   }
 
   promise->MaybeReject(NS_ERROR_NOT_AVAILABLE);
   return promise.forget();
 }
 
 already_AddRefed<Promise>
-ServiceWorkerClients::Claim()
+ServiceWorkerClients::Claim(ErrorResult& aRv)
 {
-  ErrorResult result;
-  nsRefPtr<Promise> promise = Promise::Create(mWorkerScope, result);
-  if (NS_WARN_IF(result.Failed())) {
+  WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
+  MOZ_ASSERT(workerPrivate);
+
+  nsRefPtr<Promise> promise = Promise::Create(mWorkerScope, aRv);
+  if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
-  promise->MaybeResolve(JS::UndefinedHandleValue);
+  nsRefPtr<PromiseWorkerProxy> promiseProxy =
+    PromiseWorkerProxy::Create(workerPrivate, promise);
+  if (!promiseProxy->GetWorkerPromise()) {
+    // Don't dispatch if adding the worker feature failed.
+    return promise.forget();
+  }
+
+  nsString scope;
+  mWorkerScope->GetScope(scope);
+
+  nsRefPtr<ClaimRunnable> runnable =
+    new ClaimRunnable(promiseProxy, NS_ConvertUTF16toUTF8(scope));
+
+  aRv = NS_DispatchToMainThread(runnable);
+  if (NS_WARN_IF(aRv.Failed())) {
+    promise->MaybeReject(NS_ERROR_DOM_ABORT_ERR);
+  }
+
   return promise.forget();
 }
diff --git a/dom/workers/ServiceWorkerClients.h b/dom/workers/ServiceWorkerClients.h
index a2f61d4..7fdf25d 100644
--- a/dom/workers/ServiceWorkerClients.h
+++ b/dom/workers/ServiceWorkerClients.h
@@ -31,17 +31,17 @@ public:
 
   already_AddRefed<Promise>
   MatchAll(const ClientQueryOptions& aOptions, ErrorResult& aRv);
 
   already_AddRefed<Promise>
   OpenWindow(const nsAString& aUrl);
 
   already_AddRefed<Promise>
-  Claim();
+  Claim(ErrorResult& aRv);
 
   JSObject*
   WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override;
 
   ServiceWorkerGlobalScope*
   GetParentObject() const
   {
     return mWorkerScope;
diff --git a/dom/workers/ServiceWorkerContainer.cpp b/dom/workers/ServiceWorkerContainer.cpp
index df6da24..bfda99d 100644
--- a/dom/workers/ServiceWorkerContainer.cpp
+++ b/dom/workers/ServiceWorkerContainer.cpp
@@ -45,16 +45,23 @@ ServiceWorkerContainer::~ServiceWorkerContainer()
 void
 ServiceWorkerContainer::DisconnectFromOwner()
 {
   RemoveReadyPromise();
   DOMEventTargetHelper::DisconnectFromOwner();
 }
 
 void
+ServiceWorkerContainer::ControllerChanged(ErrorResult& aRv)
+{
+  mControllerWorker = nullptr;
+  aRv = DispatchTrustedEvent(NS_LITERAL_STRING("controllerchange"));
+}
+
+void
 ServiceWorkerContainer::RemoveReadyPromise()
 {
   nsCOMPtr<nsPIDOMWindow> window = GetOwner();
   if (window) {
     nsCOMPtr<nsIServiceWorkerManager> swm =
       mozilla::services::GetServiceWorkerManager();
     if (!swm) {
       // If the browser is shutting down, we don't need to remove the promise.
diff --git a/dom/workers/ServiceWorkerContainer.h b/dom/workers/ServiceWorkerContainer.h
index 169363b..56a8218 100644
--- a/dom/workers/ServiceWorkerContainer.h
+++ b/dom/workers/ServiceWorkerContainer.h
@@ -58,24 +58,28 @@ public:
 
   // Testing only.
   void
   GetScopeForUrl(const nsAString& aUrl, nsString& aScope, ErrorResult& aRv);
 
   // DOMEventTargetHelper
   void DisconnectFromOwner() override;
 
+  // Invalidates |mControllerWorker| and dispatches a "controllerchange"
+  // event.
+  void
+  ControllerChanged(ErrorResult& aRv);
+
 private:
   ~ServiceWorkerContainer();
 
   void RemoveReadyPromise();
 
   // This only changes when a worker hijacks everything in its scope by calling
-  // replace().
-  // FIXME(nsm): Bug 982711. Provide API to let SWM invalidate this.
+  // claim.
   nsRefPtr<workers::ServiceWorker> mControllerWorker;
 
   nsRefPtr<Promise> mReadyPromise;
 };
 
 } // namespace dom
 } // namespace mozilla
 
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
index 5e50d39..14a3d1a 100644
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -1966,16 +1966,17 @@ ServiceWorkerManager::CreateServiceWorkerForWindow(nsPIDOMWindow* aWindow,
                                            WorkerPrivate::OverrideLoadGroup,
                                            &loadInfo);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   MOZ_ASSERT(!aInfo->CacheName().IsEmpty());
   loadInfo.mServiceWorkerCacheName = aInfo->CacheName();
+  loadInfo.mServiceWorkerID = aInfo->ID();
 
   RuntimeService* rs = RuntimeService::GetOrCreateService();
   if (!rs) {
     return NS_ERROR_FAILURE;
   }
 
   nsRefPtr<SharedWorker> sharedWorker;
   rv = rs->CreateSharedWorkerForServiceWorkerFromLoadInfo(cx, &loadInfo,
@@ -2159,45 +2160,69 @@ ServiceWorkerManager::RemoveScope(nsTArray<nsCString>& aList, const nsACString&
 {
   aList.RemoveElement(aScope);
 }
 
 void
 ServiceWorkerManager::MaybeStartControlling(nsIDocument* aDoc)
 {
   AssertIsOnMainThread();
+
+  // We keep a set of documents that service workers may choose to start
+  // controlling using claim().
+  MOZ_ASSERT(!mAllDocuments.Contains(aDoc));
+  mAllDocuments.PutEntry(aDoc);
+
   nsRefPtr<ServiceWorkerRegistrationInfo> registration =
     GetServiceWorkerRegistrationInfo(aDoc);
   if (registration) {
     MOZ_ASSERT(!mControlledDocuments.Contains(aDoc));
-    registration->StartControllingADocument();
-    // Use the already_AddRefed<> form of Put to avoid the addref-deref since
-    // we don't need the registration pointer in this function anymore.
-    mControlledDocuments.Put(aDoc, registration.forget());
+    StartControllingADocument(registration, aDoc);
   }
 }
 
 void
 ServiceWorkerManager::MaybeStopControlling(nsIDocument* aDoc)
 {
   MOZ_ASSERT(aDoc);
   nsRefPtr<ServiceWorkerRegistrationInfo> registration;
   mControlledDocuments.Remove(aDoc, getter_AddRefs(registration));
   // A document which was uncontrolled does not maintain that state itself, so
   // it will always call MaybeStopControlling() even if there isn't an
   // associated registration. So this check is required.
   if (registration) {
-    registration->StopControllingADocument();
-    if (!registration->IsControllingDocuments()) {
-      if (registration->mPendingUninstall) {
-        registration->Clear();
-        RemoveRegistration(registration);
-      } else {
-        registration->TryToActivate();
-      }
+    StopControllingADocument(registration);
+  }
+
+  if (mAllDocuments.Contains(aDoc)) {
+    mAllDocuments.RemoveEntry(aDoc);
+  }
+}
+
+void
+ServiceWorkerManager::StartControllingADocument(ServiceWorkerRegistrationInfo* aRegistration,
+                                                nsIDocument* aDoc)
+{
+  MOZ_ASSERT(aRegistration);
+  MOZ_ASSERT(aDoc);
+
+  aRegistration->StartControllingADocument();
+  mControlledDocuments.Put(aDoc, aRegistration);
+}
+
+void
+ServiceWorkerManager::StopControllingADocument(ServiceWorkerRegistrationInfo* aRegistration)
+{
+  aRegistration->StopControllingADocument();
+  if (!aRegistration->IsControllingDocuments()) {
+    if (aRegistration->mPendingUninstall) {
+      aRegistration->Clear();
+      RemoveRegistration(aRegistration);
+    } else {
+      aRegistration->TryToActivate();
     }
   }
 }
 
 NS_IMETHODIMP
 ServiceWorkerManager::GetScopeForUrl(const nsAString& aUrl, nsAString& aScope)
 {
   nsCOMPtr<nsIURI> uri;
@@ -2742,16 +2767,17 @@ ServiceWorkerManager::CreateServiceWorker(nsIPrincipal* aPrincipal,
                           nullptr, nullptr);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   info.mResolvedScriptURI = info.mBaseURI;
   MOZ_ASSERT(!aInfo->CacheName().IsEmpty());
   info.mServiceWorkerCacheName = aInfo->CacheName();
+  info.mServiceWorkerID = aInfo->ID();
 
   rv = info.mBaseURI->GetHost(info.mDomain);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   info.mPrincipal = aPrincipal;
 
@@ -2887,52 +2913,74 @@ EnumControlledDocuments(nsISupports* aKey,
   }
 
   ServiceWorkerClientInfo clientInfo(document);
   data->mDocuments.AppendElement(clientInfo);
 
   return PL_DHASH_NEXT;
 }
 
-static PLDHashOperator
-FireControllerChangeOnMatchingDocument(nsISupports* aKey,
-                                       ServiceWorkerRegistrationInfo* aValue,
-                                       void* aData)
+static void
+FireControllerChangeOnDocument(nsIDocument* aDocument)
 {
   AssertIsOnMainThread();
+  MOZ_ASSERT(aDocument);
 
-  ServiceWorkerRegistrationInfo* contextReg = static_cast<ServiceWorkerRegistrationInfo*>(aData);
-  if (aValue != contextReg) {
-    return PL_DHASH_NEXT;
-  }
-
-  nsCOMPtr<nsIDocument> doc = do_QueryInterface(aKey);
-  if (NS_WARN_IF(!doc)) {
-    return PL_DHASH_NEXT;
-  }
-
-  nsCOMPtr<nsPIDOMWindow> w = doc->GetWindow();
+  nsCOMPtr<nsPIDOMWindow> w = aDocument->GetWindow();
   MOZ_ASSERT(w);
   auto* window = static_cast<nsGlobalWindow*>(w.get());
   if (NS_WARN_IF(!window)) {
     NS_WARNING("No valid nsGlobalWindow");
-    return PL_DHASH_NEXT;
+    return;
   }
 
   ErrorResult result;
   dom::Navigator* navigator = window->GetNavigator(result);
   if (NS_WARN_IF(result.Failed())) {
-    return PL_DHASH_NEXT;
+    return;
   }
 
   nsRefPtr<ServiceWorkerContainer> container = navigator->ServiceWorker();
-  result = container->DispatchTrustedEvent(NS_LITERAL_STRING("controllerchange"));
+  container->ControllerChanged(result);
   if (result.Failed()) {
     NS_WARNING("Failed to dispatch controllerchange event");
   }
+}
+
+static PLDHashOperator
+FireControllerChangeOnMatchingDocument(nsISupports* aKey,
+                                       ServiceWorkerRegistrationInfo* aValue,
+                                       void* aData)
+{
+  AssertIsOnMainThread();
+
+  ServiceWorkerRegistrationInfo* contextReg = static_cast<ServiceWorkerRegistrationInfo*>(aData);
+  if (aValue != contextReg) {
+    return PL_DHASH_NEXT;
+  }
+
+  nsCOMPtr<nsIDocument> doc = do_QueryInterface(aKey);
+  if (NS_WARN_IF(!doc)) {
+    return PL_DHASH_NEXT;
+  }
+
+  FireControllerChangeOnDocument(doc);
+
+  return PL_DHASH_NEXT;
+}
+
+static PLDHashOperator
+ClaimMatchingClients(nsISupportsHashKey* aKey, void* aData)
+{
+  nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  ServiceWorkerRegistrationInfo* workerRegistration =
+    static_cast<ServiceWorkerRegistrationInfo*>(aData);
+  nsCOMPtr<nsIDocument> document = do_QueryInterface(aKey->GetKey());
+
+  swm->MaybeClaimClient(document, workerRegistration);
 
   return PL_DHASH_NEXT;
 }
 } // anonymous namespace
 
 void
 ServiceWorkerManager::GetAllClients(const nsCString& aScope,
                                     nsTArray<ServiceWorkerClientInfo>& aControlledDocuments)
@@ -2945,16 +2993,66 @@ ServiceWorkerManager::GetAllClients(const nsCString& aScope,
   }
 
   FilterRegistrationData data(aControlledDocuments, registration);
 
   mControlledDocuments.EnumerateRead(EnumControlledDocuments, &data);
 }
 
 void
+ServiceWorkerManager::MaybeClaimClient(nsIDocument* aDocument,
+                                       ServiceWorkerRegistrationInfo* aWorkerRegistration)
+{
+  MOZ_ASSERT(aWorkerRegistration);
+  MOZ_ASSERT(aWorkerRegistration->mActiveWorker);
+
+  // Same origin check
+  if (!aWorkerRegistration->mPrincipal->Equals(aDocument->NodePrincipal())) {
+    return;
+  }
+
+  // The registration that should be controlling the client
+  nsRefPtr<ServiceWorkerRegistrationInfo> matchingRegistration =
+    GetServiceWorkerRegistrationInfo(aDocument);
+
+  // The registration currently controlling the client
+  nsRefPtr<ServiceWorkerRegistrationInfo> controllingRegistration;
+  GetDocumentRegistration(aDocument, getter_AddRefs(controllingRegistration));
+
+  if (aWorkerRegistration != matchingRegistration ||
+        aWorkerRegistration == controllingRegistration) {
+    return;
+  }
+
+  if (controllingRegistration) {
+    StopControllingADocument(controllingRegistration);
+  }
+
+  StartControllingADocument(aWorkerRegistration, aDocument);
+  FireControllerChangeOnDocument(aDocument);
+}
+
+nsresult
+ServiceWorkerManager::ClaimClients(const nsCString& aScope, uint64_t aId)
+{
+  nsRefPtr<ServiceWorkerRegistrationInfo> registration =
+    GetRegistration(aScope);
+
+  if (!registration || !registration->mActiveWorker ||
+      !(registration->mActiveWorker->ID() == aId)) {
+    // The worker is not active.
+    return NS_ERROR_DOM_INVALID_STATE_ERR;
+  }
+
+  mAllDocuments.EnumerateEntries(ClaimMatchingClients, registration);
+
+  return NS_OK;
+}
+
+void
 ServiceWorkerManager::FireControllerChange(ServiceWorkerRegistrationInfo* aRegistration)
 {
   mControlledDocuments.EnumerateRead(FireControllerChangeOnMatchingDocument, aRegistration);
 }
 
 ServiceWorkerRegistrationInfo*
 ServiceWorkerManager::CreateNewRegistration(const nsCString& aScope,
                                             nsIPrincipal* aPrincipal)
@@ -3206,9 +3304,18 @@ ServiceWorkerInfo::UpdateState(ServiceWorkerState aState)
   // Activated can only go to redundant.
   MOZ_ASSERT_IF(mState == ServiceWorkerState::Activated, aState == ServiceWorkerState::Redundant);
 #endif
   mState = aState;
   for (uint32_t i = 0; i < mInstances.Length(); ++i) {
     mInstances[i]->QueueStateChangeEvent(mState);
   }
 }
+
+static uint64_t gServiceWorkerInfoCurrentID = 0;
+
+uint64_t
+ServiceWorkerInfo::GetNextID() const
+{
+  return ++gServiceWorkerInfoCurrentID;
+}
+
 END_WORKERS_NAMESPACE
diff --git a/dom/workers/ServiceWorkerManager.h b/dom/workers/ServiceWorkerManager.h
index de09b37..b2ce5b8 100644
--- a/dom/workers/ServiceWorkerManager.h
+++ b/dom/workers/ServiceWorkerManager.h
@@ -212,25 +212,35 @@ public:
  */
 class ServiceWorkerInfo final
 {
 private:
   const ServiceWorkerRegistrationInfo* mRegistration;
   nsCString mScriptSpec;
   nsString mCacheName;
   ServiceWorkerState mState;
+
+  // This id is shared with WorkerPrivate to match requests issued by service
+  // workers to their corresponding serviceWorkerInfo.
+  uint64_t mServiceWorkerID;
+
   // We hold rawptrs since the ServiceWorker constructor and destructor ensure
   // addition and removal.
   // There is a high chance of there being at least one ServiceWorker
   // associated with this all the time.
   nsAutoTArray<ServiceWorker*, 1> mInstances;
 
   ~ServiceWorkerInfo()
   { }
 
+  // Generates a unique id for the service worker, with zero being treated as
+  // invalid.
+  uint64_t
+  GetNextID() const;
+
 public:
   NS_INLINE_DECL_REFCOUNTING(ServiceWorkerInfo)
 
   const nsCString&
   ScriptSpec() const
   {
     return mScriptSpec;
   }
@@ -249,16 +259,17 @@ public:
 
   explicit ServiceWorkerInfo(ServiceWorkerRegistrationInfo* aReg,
                              const nsACString& aScriptSpec,
                              const nsAString& aCacheName)
     : mRegistration(aReg)
     , mScriptSpec(aScriptSpec)
     , mCacheName(aCacheName)
     , mState(ServiceWorkerState::EndGuard_)
+    , mServiceWorkerID(GetNextID())
   {
     MOZ_ASSERT(mRegistration);
     MOZ_ASSERT(!aCacheName.IsEmpty());
   }
 
   ServiceWorkerState
   State() const
   {
@@ -266,16 +277,22 @@ public:
   }
 
   const nsString&
   CacheName() const
   {
     return mCacheName;
   }
 
+  uint64_t
+  ID() const
+  {
+    return mServiceWorkerID;
+  }
+
   void
   UpdateState(ServiceWorkerState aState);
 
   // Only used to set initial state when loading from disk!
   void
   SetActivateStateUncheckedWithoutEvent(ServiceWorkerState aState)
   {
     mState = aState;
@@ -339,16 +356,19 @@ public:
   // Scope to registration. 
   // The scope should be a fully qualified valid URL.
   nsRefPtrHashtable<nsCStringHashKey, ServiceWorkerRegistrationInfo> mServiceWorkerRegistrationInfos;
 
   nsTObserverArray<ServiceWorkerRegistrationListener*> mServiceWorkerRegistrationListeners;
 
   nsRefPtrHashtable<nsISupportsHashKey, ServiceWorkerRegistrationInfo> mControlledDocuments;
 
+  // Set of all documents that may be controlled by a service worker.
+  nsTHashtable<nsISupportsHashKey> mAllDocuments;
+
   // Maps scopes to job queues.
   nsClassHashtable<nsCStringHashKey, ServiceWorkerJobQueue> mJobQueues;
 
   nsDataHashtable<nsCStringHashKey, bool> mSetOfScopesBeingUpdated;
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
   GetRegistration(const nsCString& aScope) const
   {
@@ -387,16 +407,23 @@ public:
               uint32_t aLineNumber,
               uint32_t aColumnNumber,
               uint32_t aFlags);
 
   void
   GetAllClients(const nsCString& aScope,
                 nsTArray<ServiceWorkerClientInfo>& aControlledDocuments);
 
+  void
+  MaybeClaimClient(nsIDocument* aDocument,
+                   ServiceWorkerRegistrationInfo* aWorkerRegistration);
+
+  nsresult
+  ClaimClients(const nsCString& aScope, uint64_t aId);
+
   static already_AddRefed<ServiceWorkerManager>
   GetInstance();
 
  void LoadRegistrations(
                  const nsTArray<ServiceWorkerRegistrationData>& aRegistrations);
 
   NS_IMETHOD
   AddRegistrationEventListener(const nsAString& aScope,
@@ -436,16 +463,23 @@ private:
 
   already_AddRefed<ServiceWorker>
   CreateServiceWorkerForScope(const nsACString& aScope);
 
   void
   InvalidateServiceWorkerRegistrationWorker(ServiceWorkerRegistrationInfo* aRegistration,
                                             WhichServiceWorker aWhichOnes);
 
+  void
+  StartControllingADocument(ServiceWorkerRegistrationInfo* aRegistration,
+                            nsIDocument* aDoc);
+
+  void
+  StopControllingADocument(ServiceWorkerRegistrationInfo* aRegistration);
+
   already_AddRefed<ServiceWorkerRegistrationInfo>
   GetServiceWorkerRegistrationInfo(nsPIDOMWindow* aWindow);
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
   GetServiceWorkerRegistrationInfo(nsIDocument* aDoc);
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
   GetServiceWorkerRegistrationInfo(nsIURI* aURI);
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
index 697c7ca..f954ead 100644
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -2241,16 +2241,17 @@ PRThreadFromThread(nsIThread* aThread)
 NS_IMPL_ISUPPORTS_INHERITED0(MainThreadReleaseRunnable, nsRunnable)
 
 NS_IMPL_ISUPPORTS_INHERITED0(TopLevelWorkerFinishedRunnable, nsRunnable)
 
 NS_IMPL_ISUPPORTS(TimerThreadEventTarget, nsIEventTarget)
 
 WorkerLoadInfo::WorkerLoadInfo()
   : mWindowID(UINT64_MAX)
+  , mServiceWorkerID(0)
   , mFromWindow(false)
   , mEvalAllowed(false)
   , mReportCSPViolations(false)
   , mXHRParamsAllowed(false)
   , mPrincipalIsSystem(false)
   , mIsInPrivilegedApp(false)
   , mIsInCertifiedApp(false)
   , mIndexedDBAllowed(false)
@@ -2294,16 +2295,17 @@ WorkerLoadInfo::StealFrom(WorkerLoadInfo& aOther)
   aOther.mInterfaceRequestor.swap(mInterfaceRequestor);
 
   MOZ_ASSERT(!mPrincipalInfo);
   mPrincipalInfo = aOther.mPrincipalInfo.forget();
 
   mDomain = aOther.mDomain;
   mServiceWorkerCacheName = aOther.mServiceWorkerCacheName;
   mWindowID = aOther.mWindowID;
+  mServiceWorkerID = aOther.mServiceWorkerID;
   mFromWindow = aOther.mFromWindow;
   mEvalAllowed = aOther.mEvalAllowed;
   mReportCSPViolations = aOther.mReportCSPViolations;
   mXHRParamsAllowed = aOther.mXHRParamsAllowed;
   mPrincipalIsSystem = aOther.mPrincipalIsSystem;
   mIsInPrivilegedApp = aOther.mIsInPrivilegedApp;
   mIsInCertifiedApp = aOther.mIsInCertifiedApp;
   mIndexedDBAllowed = aOther.mIndexedDBAllowed;
diff --git a/dom/workers/WorkerPrivate.h b/dom/workers/WorkerPrivate.h
index 59c5093..8d89b2d 100644
--- a/dom/workers/WorkerPrivate.h
+++ b/dom/workers/WorkerPrivate.h
@@ -463,16 +463,22 @@ public:
   }
 
   uint64_t
   WindowID() const
   {
     return mLoadInfo.mWindowID;
   }
 
+  uint64_t
+  ServiceWorkerID() const
+  {
+    return mLoadInfo.mServiceWorkerID;
+  }
+
   nsIURI*
   GetBaseURI() const
   {
     AssertIsOnMainThread();
     return mLoadInfo.mBaseURI;
   }
 
   void
diff --git a/dom/workers/Workers.h b/dom/workers/Workers.h
index b1b1147..19029ec 100644
--- a/dom/workers/Workers.h
+++ b/dom/workers/Workers.h
@@ -242,16 +242,17 @@ struct WorkerLoadInfo
   nsAutoPtr<mozilla::ipc::PrincipalInfo> mPrincipalInfo;
   nsCString mDomain;
 
   nsString mServiceWorkerCacheName;
 
   nsCString mSecurityInfo;
 
   uint64_t mWindowID;
+  uint64_t mServiceWorkerID;
 
   bool mFromWindow;
   bool mEvalAllowed;
   bool mReportCSPViolations;
   bool mXHRParamsAllowed;
   bool mPrincipalIsSystem;
   bool mIsInPrivilegedApp;
   bool mIsInCertifiedApp;
diff --git a/dom/workers/test/serviceworkers/claim_clients/client.html b/dom/workers/test/serviceworkers/claim_clients/client.html
new file mode 100644
index 0000000..eecfb29
--- /dev/null
+++ b/dom/workers/test/serviceworkers/claim_clients/client.html
@@ -0,0 +1,44 @@
+<!--
+  Any copyright is dedicated to the Public Domain.
+  http://creativecommons.org/publicdomain/zero/1.0/
+-->
+<!DOCTYPE HTML>
+<html>
+<head>
+  <title>Bug 1130684 - claim client </title>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<p id="display"></p>
+<div id="content" style="display: none"></div>
+<pre id="test"></pre>
+<script class="testbody" type="text/javascript">
+
+  if (!parent) {
+    info("This page shouldn't be launched directly!");
+  }
+
+  window.onload = function() {
+    parent.postMessage("READY", "*");
+  }
+
+  navigator.serviceWorker.oncontrollerchange = function() {
+    parent.postMessage({
+      event: "controllerchange",
+      controller: (navigator.serviceWorker.controller !== null)
+    }, "*");
+  }
+
+  navigator.serviceWorker.onmessage = function(e) {
+    parent.postMessage({
+      event: "message",
+      data: e.data
+    }, "*");
+  }
+
+</script>
+</pre>
+</body>
+</html>
+
diff --git a/dom/workers/test/serviceworkers/claim_oninstall_worker.js b/dom/workers/test/serviceworkers/claim_oninstall_worker.js
new file mode 100644
index 0000000..269afa7
--- /dev/null
+++ b/dom/workers/test/serviceworkers/claim_oninstall_worker.js
@@ -0,0 +1,7 @@
+oninstall = function(e) {
+  var claimFailedPromise = new Promise(function(resolve, reject) {
+    clients.claim().then(reject, () => resolve());
+  });
+
+  e.waitUntil(claimFailedPromise);
+}
diff --git a/dom/workers/test/serviceworkers/claim_worker_1.js b/dom/workers/test/serviceworkers/claim_worker_1.js
new file mode 100644
index 0000000..e5f6392
--- /dev/null
+++ b/dom/workers/test/serviceworkers/claim_worker_1.js
@@ -0,0 +1,28 @@
+onactivate = function(e) {
+  var result = {
+    resolve_value: false,
+    match_count_before: -1,
+    match_count_after: -1,
+    message: "claim_worker_1"
+  };
+
+  self.clients.matchAll().then(function(matched) {
+    // should be 0
+    result.match_count_before = matched.length;
+  }).then(function() {
+    var claimPromise = self.clients.claim().then(function(ret) {
+      result.resolve_value = ret;
+    });
+
+    return claimPromise.then(self.clients.matchAll().then(function(matched) {
+      // should be 2
+      result.match_count_after = matched.length;
+      for (i = 0; i < matched.length; i++) {
+        matched[i].postMessage(result);
+      }
+      if (result.match_count_after !== 2) {
+        dump("ERROR: claim_worker_1 failed to capture clients.\n");
+      }
+    }));
+  });
+}
diff --git a/dom/workers/test/serviceworkers/claim_worker_2.js b/dom/workers/test/serviceworkers/claim_worker_2.js
new file mode 100644
index 0000000..be8281d
--- /dev/null
+++ b/dom/workers/test/serviceworkers/claim_worker_2.js
@@ -0,0 +1,27 @@
+onactivate = function(e) {
+  var result = {
+    resolve_value: false,
+    match_count_before: -1,
+    match_count_after: -1,
+    message: "claim_worker_2"
+  };
+
+  self.clients.matchAll().then(function(matched) {
+    // should be 0
+    result.match_count_before = matched.length;
+  }).then(function() {
+    var claimPromise = self.clients.claim().then(function(ret) {
+      result.resolve_value = ret;
+    });
+
+    return claimPromise.then(self.clients.matchAll().then(function(matched) {
+      // should be 1
+      result.match_count_after = matched.length;
+      if (result.match_count_after === 1) {
+        matched[0].postMessage(result);
+      } else {
+        dump("ERROR: claim_worker_2 failed to capture clients.\n");
+      }
+    }));
+  });
+}
diff --git a/dom/workers/test/serviceworkers/mochitest.ini b/dom/workers/test/serviceworkers/mochitest.ini
index dda12fe..2f837b0 100644
--- a/dom/workers/test/serviceworkers/mochitest.ini
+++ b/dom/workers/test/serviceworkers/mochitest.ini
@@ -71,16 +71,20 @@ support-files =
   worker_updatefoundevent.js
   worker_updatefoundevent2.js
   updatefoundevent.html
   empty.js
   periodic.sjs
   periodic/frame.html
   periodic/register.html
   periodic/unregister.html
+  claim_oninstall_worker.js
+  claim_worker_1.js
+  claim_worker_2.js
+  claim_clients/client.html
 
 [test_unregister.html]
 [test_installation_simple.html]
 [test_fetch_event.html]
 [test_https_fetch.html]
 [test_https_fetch_cloned_response.html]
 [test_https_synth_fetch_from_cached_sw.html]
 [test_match_all.html]
@@ -102,8 +106,10 @@ support-files =
 [test_sandbox_intercept.html]
 [test_request_context.html]
 [test_importscript.html]
 [test_client_focus.html]
 [test_bug1151916.html]
 [test_workerupdatefoundevent.html]
 [test_empty_serviceworker.html]
 [test_periodic_update.html]
+[test_claim_oninstall.html]
+[test_claim.html]
diff --git a/dom/workers/test/serviceworkers/test_claim.html b/dom/workers/test/serviceworkers/test_claim.html
new file mode 100644
index 0000000..d701585
--- /dev/null
+++ b/dom/workers/test/serviceworkers/test_claim.html
@@ -0,0 +1,172 @@
+<!--
+  Any copyright is dedicated to the Public Domain.
+  http://creativecommons.org/publicdomain/zero/1.0/
+-->
+<!DOCTYPE HTML>
+<html>
+<head>
+  <title>Bug 1130684 - Test service worker clients claim onactivate </title>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<p id="display"></p>
+<div id="content" style="display: none"></div>
+<pre id="test"></pre>
+<script class="testbody" type="text/javascript">
+  var registration_1;
+  var registration_2;
+  var client;
+
+  function register_1() {
+    return navigator.serviceWorker.register("claim_worker_1.js",
+                                            { scope: "./" })
+      .then((swr) => registration_1 = swr);
+  }
+
+  function register_2() {
+    return navigator.serviceWorker.register("claim_worker_2.js",
+                                            { scope: "./claim_clients/client.html" })
+      .then((swr) => registration_2 = swr);
+  }
+
+  function unregister(reg) {
+    return reg.unregister().then(function(result) {
+      ok(result, "Unregister should return true.");
+    });
+  }
+
+  function createClient() {
+    var p = new Promise(function(res, rej) {
+      window.onmessage = function(e) {
+        if (e.data === "READY") {
+          res();
+        }
+      }
+    });
+
+    content = document.getElementById("content");
+    ok(content, "parent exists.");
+
+    client = document.createElement("iframe");
+    client.setAttribute('src', "claim_clients/client.html");
+    content.appendChild(client);
+
+    return p;
+  }
+
+  function testController() {
+    ok(navigator.serviceWorker.controller.scriptURL.match("claim_worker_1"),
+        "Controlling service worker has the correct url.");
+  }
+
+  function testClientWasClaimed(expected) {
+    var resolveClientMessage, resolveClientControllerChange;
+    var messageFromClient = new Promise(function(res, rej) {
+      resolveClientMessage = res;
+    });
+    var controllerChangeFromClient = new Promise(function(res, rej) {
+      resolveClientControllerChange = res;
+    });
+    window.onmessage = function(e) {
+      if (!e.data.event) {
+        ok(false, "Unknown message received: " + e.data);
+      }
+
+      if (e.data.event === "controllerchange") {
+        ok(e.data.controller,
+           "Client was claimed and received controllerchange event.");
+        resolveClientControllerChange();
+      }
+
+      if (e.data.event === "message") {
+        ok(e.data.data.resolve_value === undefined,
+            "Claim should resolve with undefined.");
+        ok(e.data.data.message === expected.message,
+           "Client received message from claiming worker.");
+        ok(e.data.data.match_count_before === expected.match_count_before,
+            "MatchAll clients count before claim should be " + expected.match_count_before);
+        ok(e.data.data.match_count_after === expected.match_count_after,
+            "MatchAll clients count after claim should be " + expected.match_count_after);
+        resolveClientMessage();
+      }
+    }
+
+    return Promise.all([messageFromClient, controllerChangeFromClient])
+      .then(() => window.onmessage = null);
+  }
+
+  function testClaimFirstWorker() {
+    // wait for the worker to control us
+    var controllerChange = new Promise(function(res, rej) {
+      navigator.serviceWorker.oncontrollerchange = function(e) {
+        ok(true, "controller changed event received.");
+        res();
+      };
+    });
+
+    var messageFromWorker = new Promise(function(res, rej) {
+      navigator.serviceWorker.onmessage = function(e) {
+        ok(e.data.resolve_value === undefined,
+            "Claim should resolve with undefined.");
+        ok(e.data.message === "claim_worker_1",
+            "Received message from claiming worker.");
+        ok(e.data.match_count_before === 0,
+            "Worker doesn't control any client before claim.");
+        ok(e.data.match_count_after === 2, "Worker should claim 2 clients.");
+        res();
+      }
+    });
+
+    var clientClaim = testClientWasClaimed({
+      message: "claim_worker_1",
+      match_count_before: 0,
+      match_count_after: 2
+    });
+
+    return Promise.all([controllerChange, messageFromWorker, clientClaim])
+      .then(testController);
+  }
+
+  function testClaimSecondWorker() {
+    navigator.serviceWorker.oncontrollerchange = function(e) {
+      ok(false, "Claim_worker_2 shouldn't claim this window.");
+    }
+
+    navigator.serviceWorker.onmessage = function(e) {
+      ok(false, "Claim_worker_2 shouldn't claim this window.");
+    }
+
+    var clientClaim = testClientWasClaimed({
+      message: "claim_worker_2",
+      match_count_before: 0,
+      match_count_after: 1
+    });
+
+    return clientClaim.then(testController);
+  }
+
+  function runTest() {
+    createClient()
+      .then(register_1)
+      .then(testClaimFirstWorker)
+      .then(register_2)
+      .then(testClaimSecondWorker)
+      .then(function() { return unregister(registration_1); })
+      .then(function() { return unregister(registration_2); })
+      .catch(function(e) {
+        ok(false, "Some test failed with error " + e);
+      }).then(SimpleTest.finish);
+  }
+
+  SimpleTest.waitForExplicitFinish();
+  SpecialPowers.pushPrefEnv({"set": [
+    ["dom.serviceWorkers.exemptFromPerDomainMax", true],
+    ["dom.serviceWorkers.enabled", true],
+    ["dom.serviceWorkers.testing.enabled", true]
+  ]}, runTest);
+</script>
+</pre>
+</body>
+</html>
+
diff --git a/dom/workers/test/serviceworkers/test_claim_oninstall.html b/dom/workers/test/serviceworkers/test_claim_oninstall.html
new file mode 100644
index 0000000..5844614
--- /dev/null
+++ b/dom/workers/test/serviceworkers/test_claim_oninstall.html
@@ -0,0 +1,73 @@
+<!--
+  Any copyright is dedicated to the Public Domain.
+  http://creativecommons.org/publicdomain/zero/1.0/
+-->
+<!DOCTYPE HTML>
+<html>
+<head>
+  <title>Bug 1130684 - Test service worker clients.claim oninstall</title>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<p id="display"></p>
+<div id="content" style="display: none"></div>
+<pre id="test"></pre>
+<script class="testbody" type="text/javascript">
+  var registration;
+
+  function register() {
+    return navigator.serviceWorker.register("claim_oninstall_worker.js",
+                                            { scope: "./" })
+      .then((swr) => registration = swr);
+  }
+
+
+  function unregister() {
+    return registration.unregister().then(function(result) {
+      ok(result, "Unregister should return true.");
+    });
+  }
+
+  function testClaim() {
+    ok(registration.installing, "Worker should be in installing state");
+
+    navigator.serviceWorker.oncontrollerchange = function() {
+      ok(false, "Claim should not succeed when the worker is not active.");
+    }
+
+    var p = new Promise(function(res, rej) {
+      registration.installing.onstatechange = function(e) {
+        // The worker will become active only if claim will reject inside the
+        // install handler.
+
+        ok(registration.active, "Claim should reject if the worker is not active");
+        ok(navigator.serviceWorker.controller === null, "Client is not controlled.");
+        e.target.onstatechange = null;
+        res();
+      }
+    });
+
+    return p;
+  }
+
+  function runTest() {
+    register()
+      .then(testClaim)
+      .then(unregister)
+      .catch(function(e) {
+        ok(false, "Some test failed with error " + e);
+      }).then(SimpleTest.finish);
+  }
+
+  SimpleTest.waitForExplicitFinish();
+  SpecialPowers.pushPrefEnv({"set": [
+    ["dom.serviceWorkers.exemptFromPerDomainMax", true],
+    ["dom.serviceWorkers.enabled", true],
+    ["dom.serviceWorkers.testing.enabled", true]
+  ]}, runTest);
+</script>
+</pre>
+</body>
+</html>
+
