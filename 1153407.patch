# HG changeset patch
# Parent 698d7568b99c3132adc9a17d548278a1f2064f86
# User Jose Antonio Olivera Ortega <jaoo@jaoo.es>
# Parent  4fb7ff694bf5944b76c20b2240fb3abdc55f9a4e
Bug 1153407 - browser_toolbox_options_enable_serviceworkers_testing.js breaks other tests, needs to be e10s. r=ochameau

diff --git a/browser/devtools/framework/test/browser.ini b/browser/devtools/framework/test/browser.ini
--- a/browser/devtools/framework/test/browser.ini
+++ b/browser/devtools/framework/test/browser.ini
@@ -6,16 +6,17 @@ support-files =
   browser_toolbox_options_disable_js_iframe.html
   browser_toolbox_options_disable_cache.sjs
   browser_toolbox_sidebar_tool.xul
   code_math.js
   head.js
   helper_disable_cache.js
   doc_theme.css
   doc_viewsource.html
+  browser_toolbox_options_enable_serviceworkers_testing_frame_script.js
   browser_toolbox_options_enable_serviceworkers_testing.html
   serviceworker.js
 
 [browser_devtools_api.js]
 [browser_devtools_api_destroy.js]
 [browser_dynamic_tool_enabling.js]
 [browser_keybindings.js]
 [browser_new_activation_workflow.js]
@@ -58,14 +59,13 @@ skip-if = e10s # Bug 1069044 - destroyIn
 [browser_toolbox_window_reload_target.js]
 [browser_toolbox_window_shortcuts.js]
 skip-if = os == "mac" && os_version == "10.8" || os == "win" && os_version == "5.1" # Bug 851129 - Re-enable browser_toolbox_window_shortcuts.js test after leaks are fixed
 [browser_toolbox_window_title_changes.js]
 [browser_toolbox_zoom.js]
 [browser_toolbox_custom_host.js]
 [browser_toolbox_theme_registration.js]
 [browser_toolbox_options_enable_serviceworkers_testing.js]
-skip-if = true # Bug 1153407 - this test breaks subsequent tests and is not e10s compatible
 [browser_toolbox_selected_tool_unavailable.js]
 
 # We want this test to run for mochitest-dt as well, so we include it here:
 [../../../base/content/test/general/browser_parsable_css.js]
 
diff --git a/browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing.html b/browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing.html
--- a/browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing.html
+++ b/browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing.html
@@ -1,32 +1,46 @@
 <!DOCTYPE html>
 <html>
   <head>
     <title>browser_toolbox_options_enable_serviceworkers_testing.html</title>
     <meta charset="UTF-8">
     <style>
       div {
-        width: 260px;
+        width: 360px;
         height: 24px;
         border: 1px solid #000;
         margin-top: 10px;
       }
 
       h1 {
         font-size: 20px
       }
     </style>
     <script type="application/javascript;version=1.8">
       function log(msg) {
         var output = document.getElementById("output");
 
         output.innerHTML = msg;
       }
 
+      function unregister() {
+        navigator.serviceWorker.getRegistration().then(swr => {
+          if (!swr) {
+           log("Error");
+           button.click();
+           return;
+          }
+          swr.unregister().then(result => {
+            result ? log("UnregistersCorrectly") : log("Error");
+            button.click();
+          });
+        });
+      }
+
       navigator.serviceWorker.register("serviceworker.js").then(
         swr => {
           var msg = "";
           var button = document.getElementById("button");
           if (swr.installing) {
             msg += "Installing worker/";
           }
           if (swr.waiting) {
@@ -49,10 +63,15 @@
   </head>
   <body>
     <h1>Test in page</h1>
     <input id="button"
            type="button"
            value="Worker clicks here"/>
     <br>
     <div id="output">No output</div>
+    <br>
+    <input id="unregister"
+           type="button"
+           value="Unregister"
+           onclick="unregister()"/>
   </body>
 </html>
diff --git a/browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing.js b/browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing.js
--- a/browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing.js
+++ b/browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing.js
@@ -1,14 +1,22 @@
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Test that enabling Service Workers testing option enables the
 // mServiceWorkersTestingEnabled attribute added to nsPIDOMWindow.
 
+const COMMON_FRAME_SCRIPT_URL =
+  "chrome://browser/content/devtools/frame-script-utils.js";
+const ROOT_TEST_DIR =
+  getRootDirectory(gTestPath);
+const FRAME_SCRIPT_URL =
+  ROOT_TEST_DIR +
+  "browser_toolbox_options_enable_serviceworkers_testing_frame_script.js";
+
 const TEST_URI = URL_ROOT +
                  "browser_toolbox_options_enable_serviceworkers_testing.html";
 
 const ELEMENT_ID = "devtools-enable-serviceWorkersTesting";
 
 let toolbox;
 let doc;
 
@@ -18,19 +26,22 @@ function test() {
   SpecialPowers.pushPrefEnv({"set": [
     ["dom.serviceWorkers.exemptFromPerDomainMax", true],
     ["dom.serviceWorkers.enabled", true],
     ["dom.serviceWorkers.testing.enabled", false]
   ]}, start);
 }
 
 function start() {
-  gBrowser.selectedTab = gBrowser.addTab();
+  let tab = gBrowser.selectedTab = gBrowser.addTab();
   let target = TargetFactory.forTab(gBrowser.selectedTab);
+  let linkedBrowser = tab.linkedBrowser;
 
+  linkedBrowser.messageManager.loadFrameScript(COMMON_FRAME_SCRIPT_URL, false);
+  linkedBrowser.messageManager.loadFrameScript(FRAME_SCRIPT_URL, false);
   gBrowser.selectedBrowser.addEventListener("load", function onLoad(evt) {
     gBrowser.selectedBrowser.removeEventListener(evt.type, onLoad, true);
     doc = content.document;
     gDevTools.showToolbox(target).then(testSelectTool);
   }, true);
 
   content.location = TEST_URI;
 }
@@ -41,83 +52,98 @@ function testSelectTool(aToolbox) {
     testRegisterFails().then(testRegisterInstallingWorker);
   });
   toolbox.selectTool("options");
 }
 
 function testRegisterFails() {
   let deferred = promise.defer();
 
-  let output = doc.getElementById("output");
-  let button = doc.getElementById("button");
-
   function doTheCheck() {
-    info("Testing it doesn't registers correctly until enable testing");
-    is(output.textContent,
-       "SecurityError",
-       "SecurityError expected");
-    deferred.resolve();
+    getNodeInfo("#output").then(output => {
+      info("Testing it doesn't registers correctly until enable testing");
+      is(output.textContent,
+         "SecurityError",
+         "SecurityError expected");
+      deferred.resolve();
+    });
   }
 
-  if (output.textContent !== "No output") {
-    doTheCheck();
-  }
-
-  button.addEventListener('click', function onClick() {
-    button.removeEventListener('click', onClick);
-    doTheCheck();
+  getNodeInfo("#output").then(output => {
+    if (output.textContent !== "No output") {
+      doTheCheck();
+    } else {
+      waitForSWMessage("#button").then(doTheCheck);
+    }
   });
 
   return deferred.promise;
 }
 
 function testRegisterInstallingWorker() {
   toggleServiceWorkersTestingCheckbox().then(() => {
-    let output = doc.getElementById("output");
-    let button = doc.getElementById("button");
 
     function doTheCheck() {
-      info("Testing it registers correctly and there is an installing worker");
-      is(output.textContent,
-         "Installing worker/",
-         "Installing worker expected");
-      testRegisterFailsWhenToolboxCloses();
+      getNodeInfo("#output").then(output => {
+        info("Testing it registers correctly and there is an installing worker");
+        is(output.textContent,
+           "Installing worker/",
+           "Installing worker expected");
+        testRegisterFailsWhenToolboxCloses();
+      });
     }
 
-    if (output.textContent !== "No output") {
-      doTheCheck();
-    }
-
-    button.addEventListener('click', function onClick() {
-      button.removeEventListener('click', onClick);
-      doTheCheck();
+    getNodeInfo("#output").then(output => {
+      if (output.textContent !== "No output") {
+        doTheCheck();
+      } else {
+        waitForSWMessage("#button").then(doTheCheck);
+      }
     });
   });
 }
 
 // Workers should be turned back off when we closes the toolbox
 function testRegisterFailsWhenToolboxCloses() {
-  info("Testing it disable worker when closing the toolbox");
+  info("Testing it disables worker when closing the toolbox");
   toolbox.destroy()
          .then(reload)
          .then(testRegisterFails)
+         .then(testUnregister)
          .then(finishUp);
 }
 
 function reload() {
   let deferred = promise.defer();
 
   gBrowser.selectedBrowser.addEventListener("load", function onLoad(evt) {
     gBrowser.selectedBrowser.removeEventListener(evt.type, onLoad, true);
     doc = content.document;
     deferred.resolve();
   }, true);
 
-  let mm = getFrameScript();
-  mm.sendAsyncMessage("devtools:test:reload");
+  executeInContent("devtools:test:reload", {}, {}, false);
+  return deferred.promise;
+}
+
+function testUnregister() {
+  let deferred = promise.defer();
+
+  function doTheCheck() {
+    getNodeInfo("#output").then(output => {
+      info("Testing it unregisters correctly");
+      is(output.textContent,
+         "UnregistersCorrectly",
+         "Unregisters correctly");
+      deferred.resolve();
+    });
+  }
+
+  waitForSWMessage("#button").then(doTheCheck);
+  evalInDebuggee("unregister()");
 
   return deferred.promise;
 }
 
 function toggleServiceWorkersTestingCheckbox() {
   let deferred = promise.defer();
 
   let panel = toolbox.getCurrentPanel();
diff --git a/browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing_frame_script.js b/browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing_frame_script.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/framework/test/browser_toolbox_options_enable_serviceworkers_testing_frame_script.js
@@ -0,0 +1,63 @@
+/* Any copyright is dedicated to the Public Domain.
+ http://creativecommons.org/publicdomain/zero/1.0/ */
+
+// A helper frame-script for browser/devtools/framework tests.
+
+"use strict";
+
+const {classes: Cc, interfaces: Ci, utils: Cu, results: Cr} = Components;
+const { devtools } = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
+devtools.lazyImporter(this, "promise", "resource://gre/modules/Promise.jsm", "Promise");
+devtools.lazyImporter(this, "Task", "resource://gre/modules/Task.jsm", "Task");
+const loader = Cc["@mozilla.org/moz/jssubscript-loader;1"]
+            .getService(Ci.mozIJSSubScriptLoader);
+let EventUtils = {};
+loader.loadSubScript("chrome://marionette/content/EventUtils.js", EventUtils);
+
+addMessageListener("devtools:test:waitForSWMessage", function(msg) {
+  let {selector} = msg.data;
+  let node = superQuerySelector(selector);
+
+  if (!node) {
+    sendAsyncMessage("devtools:test:waitForSWMessage");
+  }
+  node.addEventListener('click', function onClick() {
+    node.removeEventListener('click', onClick);
+    sendAsyncMessage("devtools:test:waitForSWMessage");
+  });
+});
+
+addMessageListener("devtools:test:unregisterSW", function(msg) {
+  let {selector} = msg.data;
+  let node = superQuerySelector(selector);
+
+  if (node) {
+    node.click();
+  }
+});
+
+/**
+ * Like document.querySelector but can go into iframes too.
+ * ".container iframe || .sub-container div" will first try to find the node
+ * matched by ".container iframe" in the root document, then try to get the
+ * content document inside it, and then try to match ".sub-container div" inside
+ * this document.
+ * Any selector coming before the || separator *MUST* match a frame node.
+ * @param {String} superSelector.
+ * @return {DOMNode} The node, or null if not found.
+ */
+function superQuerySelector(superSelector, root=content.document) {
+  let frameIndex = superSelector.indexOf("||");
+  if (frameIndex === -1) {
+    return root.querySelector(superSelector);
+  } else {
+    let rootSelector = superSelector.substring(0, frameIndex).trim();
+    let childSelector = superSelector.substring(frameIndex+2).trim();
+    root = root.querySelector(rootSelector);
+    if (!root || !root.contentWindow) {
+      return null;
+    }
+
+    return superQuerySelector(childSelector, root.contentWindow.document);
+  }
+}
diff --git a/browser/devtools/framework/test/head.js b/browser/devtools/framework/test/head.js
--- a/browser/devtools/framework/test/head.js
+++ b/browser/devtools/framework/test/head.js
@@ -8,16 +8,17 @@ const { console } = Cu.import("resource:
 const { Promise: promise } = Cu.import("resource://gre/modules/Promise.jsm", {});
 const { devtools } = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
 const { ScratchpadManager } = Cu.import("resource:///modules/devtools/scratchpad-manager.jsm", {});
 
 const URL_ROOT = "http://example.com/browser/browser/devtools/framework/test/";
 const CHROME_URL_ROOT = "chrome://mochitests/content/browser/browser/devtools/framework/test/";
 
 let TargetFactory = devtools.TargetFactory;
+let { generateUUID } = Cc['@mozilla.org/uuid-generator;1'].getService(Ci.nsIUUIDGenerator);
 
 // All test are asynchronous
 waitForExplicitFinish();
 
 // Uncomment this pref to dump all devtools emitted events to the console.
 // Services.prefs.setBoolPref("devtools.dump.emit", true);
 
 function getFrameScript() {
@@ -217,8 +218,93 @@ function *openScratchpadWindow () {
   win.Scratchpad.addObserver({
     onReady: function () {
       win.Scratchpad.removeObserver(this);
       resolve(win);
     }
   });
   return p;
 }
+
+/**
+ * Wait for a content -> chrome message on the message manager (the window
+ * messagemanager is used).
+ * @param {String} name The message name
+ * @return {Promise} A promise that resolves to the response data when the
+ * message has been received
+ */
+function waitForContentMessage(name) {
+  info("Expecting message " + name + " from content");
+
+  let mm = gBrowser.selectedBrowser.messageManager;
+
+  let def = promise.defer();
+  mm.addMessageListener(name, function onMessage(msg) {
+    mm.removeMessageListener(name, onMessage);
+    def.resolve(msg.data);
+  });
+  return def.promise;
+}
+
+/**
+ * Send an async message to the frame script (chrome -> content) and wait for a
+ * response message with the same name (content -> chrome).
+ * @param {String} name The message name. Should be one of the messages defined
+ * in doc_frame_script.js
+ * @param {Object} data Optional data to send along
+ * @param {Object} objects Optional CPOW objects to send along
+ * @param {Boolean} expectResponse If set to false, don't wait for a response
+ * with the same name from the content script. Defaults to true.
+ * @return {Promise} Resolves to the response data if a response is expected,
+ * immediately resolves otherwise
+ */
+function executeInContent(name, data={}, objects={}, expectResponse=true) {
+  info("Sending message " + name + " to content");
+  let mm = gBrowser.selectedBrowser.messageManager;
+
+  mm.sendAsyncMessage(name, data, objects);
+  if (expectResponse) {
+    return waitForContentMessage(name);
+  } else {
+    return promise.resolve();
+  }
+}
+
+/**
+ * Get information about a DOM element, identified by its selector.
+ * @param {String} selector.
+ * @return {Promise} a promise that resolves to the element's information.
+ */
+function getNodeInfo(selector) {
+  return executeInContent("devtools:test:getDomElementInfo", {selector});
+}
+
+function waitForSWMessage(selector) {
+  return executeInContent("devtools:test:waitForSWMessage", {selector});
+}
+
+/**
+ * Takes a string `script` and evaluates it directly in the content
+ * in potentially a different process.
+ */
+function evalInDebuggee (script) {
+  let deferred = promise.defer();
+
+  let mm = gBrowser.selectedBrowser.messageManager;
+  if (!mm) {
+    throw new Error("`loadFrameScripts()` must be called when using MessageManager.");
+  }
+
+  let id = generateUUID().toString();
+  mm.sendAsyncMessage("devtools:test:eval", { script: script, id: id });
+  mm.addMessageListener("devtools:test:eval:response", handler);
+
+  function handler ({ data }) {
+    if (id !== data.id) {
+      return;
+    }
+
+    mm.removeMessageListener("devtools:test:eval:response", handler);
+    deferred.resolve(data.value);
+  }
+
+  return deferred.promise;
+}
