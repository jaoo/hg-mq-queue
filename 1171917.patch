# HG changeset patch
# User Jose Antonio Olivera Ortega <jaoo@jaoo.es>
# Parent  48c51b88a126036eff6a82e576d818c96546a09a
Bug 1171917 - Improve about:serviceworkers tests on b2g. r=ferjm

diff --git a/b2g/components/AboutServiceWorkers.jsm b/b2g/components/AboutServiceWorkers.jsm
--- a/b2g/components/AboutServiceWorkers.jsm
+++ b/b2g/components/AboutServiceWorkers.jsm
@@ -14,17 +14,17 @@ Cu.import("resource://gre/modules/XPCOMU
 XPCOMUtils.defineLazyModuleGetter(this, "SystemAppProxy",
                                   "resource://gre/modules/SystemAppProxy.jsm");
 
 XPCOMUtils.defineLazyServiceGetter(this, "gServiceWorkerManager",
                                   "@mozilla.org/serviceworkers/manager;1",
                                   "nsIServiceWorkerManager");
 
 function debug(aMsg) {
-  // dump("AboutServiceWorkers - " + aMsg + "\n");
+  dump("AboutServiceWorkers - " + aMsg + "\n");
 }
 
 function serializeServiceWorkerInfo(aServiceWorkerInfo) {
   if (!aServiceWorkerInfo) {
     throw new Error("Invalid service worker information");
   }
 
   let result = {};
diff --git a/b2g/components/test/mochitest/app/client.html b/b2g/components/test/mochitest/app/client.html
new file mode 100644
--- /dev/null
+++ b/b2g/components/test/mochitest/app/client.html
@@ -0,0 +1,17 @@
+<!DOCTYPE HTML>
+<html>
+  <head>
+    <title>Test app for bug 1171917</title>
+    <script type='application/javascript;version=1.7'>
+
+function onLoad() {
+  navigator.serviceWorker.ready.then(function(swr) {
+    parent.postMessage({status: "callback", data: "ready"}, '*');
+  });
+}
+
+    </script>
+  </head>
+  <body onload='onLoad()'>
+  </body>
+</html>
diff --git a/b2g/components/test/mochitest/app/index.html b/b2g/components/test/mochitest/app/index.html
new file mode 100644
--- /dev/null
+++ b/b2g/components/test/mochitest/app/index.html
@@ -0,0 +1,77 @@
+<!DOCTYPE html>
+<html>
+  <head>
+    <title>Test app for bug 1171917</title>
+    <script type='application/javascript;version=1.7'>
+
+function ok(aCondition, aMessage) {
+  if (aCondition) {
+    alert('OK: ' + aMessage);
+  } else {
+    alert('KO: ' + aMessage);
+  }
+}
+
+function done() {
+  alert('DONE');
+}
+
+function testFrame(src) {
+  return new Promise(function(resolve, reject) {
+    var iframe = document.createElement("iframe");
+    iframe.src = src;
+    window.onmessage = function(e) {
+      if (e.data.status == "callback") {
+        window.onmessage = null;
+        var result = e.data.data;
+        iframe.src = "about:blank";
+        document.body.removeChild(iframe);
+        iframe = null;
+        resolve(result);
+      }
+    };
+    document.body.appendChild(iframe);
+  });
+}
+
+function registerServiceWorker() {
+  return navigator.serviceWorker.register('sw.sjs', {scope: '.'});
+}
+
+function runTests() {
+  var lastSeenVersion;
+  return Promise.resolve()
+    .then(function() {
+      // Check whether the service worker is already registered and save its
+      // version.
+      return navigator.serviceWorker.getRegistration(".").then(function(swr) {
+        if (!swr) {
+          lastSeenVersion = 0;
+          return registerServiceWorker();
+        }
+        return testFrame('version.html').then(function(body) {
+          lastSeenVersion = parseInt(body);
+          return Promise.resolve();
+        });
+      });
+    })
+    .then(function() {
+      // Wait until the service worker start controlling the client.
+      return testFrame('client.html');
+    })
+    .then(function() {
+      // Fetch current version. It should be greater than the last seen version.
+      return testFrame('version.html').then(function(body) {
+        var currentVersion = parseInt(body);
+        ok(lastSeenVersion < currentVersion, "New service worker version seen");
+        return Promise.resolve();
+      });
+    })
+    .then(done);
+}
+
+    </script>
+  </head>
+  <body onload='runTests()'>
+  </body>
+</html>
diff --git a/b2g/components/test/mochitest/app/manifest.webapp b/b2g/components/test/mochitest/app/manifest.webapp
new file mode 100644
--- /dev/null
+++ b/b2g/components/test/mochitest/app/manifest.webapp
@@ -0,0 +1,5 @@
+{
+  "name": "App",
+  "launch_path": "/index.html",
+  "description": "Test app for bug 1171917"
+}
diff --git a/b2g/components/test/mochitest/app/manifest.webapp^headers^ b/b2g/components/test/mochitest/app/manifest.webapp^headers^
new file mode 100644
--- /dev/null
+++ b/b2g/components/test/mochitest/app/manifest.webapp^headers^
@@ -0,0 +1,1 @@
+Content-Type: application/manifest+json
diff --git a/b2g/components/test/mochitest/app/sw.sjs b/b2g/components/test/mochitest/app/sw.sjs
new file mode 100644
--- /dev/null
+++ b/b2g/components/test/mochitest/app/sw.sjs
@@ -0,0 +1,22 @@
+function handleRequest(request, response) {
+  var stateName = request.scheme + 'counter';
+  if (!getState(stateName)) {
+    setState(stateName, '1');
+  } else {
+    // Make sure that we pass a string value to setState!
+    setState(stateName, "" + (parseInt(getState(stateName)) + 1));
+  }
+  response.setHeader("Content-Type", "application/javascript", false);
+  response.write(getScript(stateName));
+}
+
+function getScript(stateName) {
+  return "oninstall = function(evt) {" +
+           "evt.waitUntil(self.skipWaiting());" +
+         "}; " +
+         "onfetch = function(evt) {" +
+           "if (evt.request.url.indexOf('get-sw-version') > -1) {" +
+             "evt.respondWith(new Response('" + getState(stateName) + "'));" +
+           "}" +
+         "};";
+}
diff --git a/b2g/components/test/mochitest/app/version.html b/b2g/components/test/mochitest/app/version.html
new file mode 100644
--- /dev/null
+++ b/b2g/components/test/mochitest/app/version.html
@@ -0,0 +1,19 @@
+<!DOCTYPE HTML>
+<html>
+  <head>
+    <title>Test app for bug 1171917</title>
+    <script type='application/javascript;version=1.7'>
+
+function onLoad() {
+  fetch("get-sw-version").then(function(r) {
+    return r.text();
+  }).then(function(body) {
+    parent.postMessage({status: "callback", data: body}, "*");
+  });
+}
+
+    </script>
+  </head>
+  <body onload='onLoad()'>
+  </body>
+</html>
diff --git a/b2g/components/test/mochitest/chrome.ini b/b2g/components/test/mochitest/chrome.ini
new file mode 100644
--- /dev/null
+++ b/b2g/components/test/mochitest/chrome.ini
@@ -0,0 +1,6 @@
+[DEFAULT]
+skip-if = toolkit != "gonk"
+support-files =
+  app/*
+
+[test_aboutserviceworkers.html]
diff --git a/b2g/components/test/mochitest/test_aboutserviceworkers.html b/b2g/components/test/mochitest/test_aboutserviceworkers.html
new file mode 100644
--- /dev/null
+++ b/b2g/components/test/mochitest/test_aboutserviceworkers.html
@@ -0,0 +1,255 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=1171917
+-->
+<head>
+  <meta charset="utf-8">
+  <title>Test for Bug 1171917</title>
+  <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="chrome://mochikit/content/tests/SimpleTest/test.css"/>
+  <script type="application/javascript;version=1.7">
+
+const ASW_CHROME_EVENT = 'mozAboutServiceWorkersChromeEvent';
+const ASW_CONTENT_EVENT = 'mozAboutServiceWorkersContentEvent';
+
+const { classes: Cc, interfaces: Ci, utils: Cu } = Components;
+
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+XPCOMUtils.defineLazyServiceGetter(this, "gAppsService",
+                                   "@mozilla.org/AppsService;1",
+                                   "nsIAppsService");
+XPCOMUtils.defineLazyModuleGetter(this, "AboutServiceWorkers",
+  "resource://gre/modules/AboutServiceWorkers.jsm");
+
+SimpleTest.waitForExplicitFinish();
+
+const gOrigin = 'http://test/chrome/b2g/components/test/mochitest/app';
+const appManifestURL = gOrigin + '/manifest.webapp';
+let gApp;
+
+const ORIGINAL_INIT = AboutServiceWorkers.init;
+const ORIGINAL_SENDRESULT = AboutServiceWorkers.sendResult;
+const ORIGINAL_SENDERROR = AboutServiceWorkers.sendError;
+
+function debug(aMsg) {
+  dump("test_aboutserviceworkers.html - " + aMsg + "\n");
+}
+
+function mockInit() {
+  window.addEventListener(ASW_CONTENT_EVENT, AboutServiceWorkers);
+}
+
+function mockSendResult(aId, aResult) {
+  debug("mockSendResult, " + JSON.stringify({ detail : {
+    id: aId,
+    result: aResult
+  }}));
+  let event = new CustomEvent(ASW_CHROME_EVENT, { detail : {
+    id: aId,
+    result: aResult
+  }});
+  window.dispatchEvent(event);
+}
+
+function mockSendError(aId, aError) {
+  debug("mockSendError, " + JSON.stringify({ detail : {
+    id: aId,
+    result: aError
+  }}));
+  let event = new CustomEvent(ASW_CHROME_EVENT, { detail: {
+    id: aId,
+    result: aError
+  }});
+  window.dispatchEvent(event);
+}
+
+function attachMocks() {
+  AboutServiceWorkers.init = mockInit;
+  AboutServiceWorkers.sendResult = mockSendResult;
+  AboutServiceWorkers.sendError = mockSendError;
+  return Promise.resolve();
+}
+
+function restoreMocks() {
+  AboutServiceWorkers.init = ORIGINAL_INIT;
+  AboutServiceWorkers.sendResult = ORIGINAL_SENDRESULT;
+  AboutServiceWorkers.sendError = ORIGINAL_SENDERROR;
+  return Promise.resolve();
+}
+
+function sendContentEvent(detail) {
+  let event = new CustomEvent(ASW_CONTENT_EVENT, {
+    detail: detail
+  });
+  window.dispatchEvent(event);
+}
+
+function chromeRequest(request) {
+  if (!request) {
+    return Promise.reject('InternalErrorMissingEventDetail');
+  }
+
+  return new Promise((resolve, reject) => {
+    let id = request.id;
+    window.addEventListener(ASW_CHROME_EVENT,
+                            function onChromeEvent(event) {
+      window.removeEventListener(ASW_CHROME_EVENT, onChromeEvent);
+      let message = event.detail;
+      if (!message || !message.id || message.id != id) {
+        return reject('InternalErrorWrongChromeEvent');
+      }
+
+      if (message.error) {
+        reject(message.error);
+      } else if (message.result) {
+        resolve(message.result);
+      }
+    });
+
+    sendContentEvent(request);
+  });
+}
+
+function uninstallApp() {
+  return new Promise((resolve, reject) => {
+    if (!gApp) {
+      return reject();
+    }
+    let req = navigator.mozApps.mgmt.uninstall(gApp);
+    req.onsuccess = resolve;
+    req.onerror = reject;
+  });
+}
+
+function testApp() {
+  if (!gApp) {
+    ok(false, 'No test application to launch');
+    return Promise.reject();
+  }
+  return new Promise((resolve, reject) => {
+    let iframe = document.createElement('iframe');
+    let domParent = document.getElementById('container');
+    iframe.setAttribute('mozbrowser', 'true');
+    iframe.setAttribute('mozapp', gApp.manifestURL);
+    iframe.addEventListener('mozbrowsershowmodalprompt', function listener(e) {
+      let message = e.detail.message;
+      if (/OK/.exec(message)) {
+        ok(true, "Message from app: " + message);
+      } else if (/DONE/.exec(message)) {
+        ok(true, "Message from app: " + message);
+        iframe.src = "about:blank";
+        domParent.removeChild(iframe);
+        iframe = null;
+        resolve();
+      }
+    }, false);
+    domParent.appendChild(iframe);
+    ok(true, "origin " +  gOrigin + gApp.manifest.launch_path);
+    SpecialPowers.wrap(iframe.contentWindow).location =
+      gOrigin + gApp.manifest.launch_path;
+  });
+}
+
+function installApp() {
+  return new Promise((resolve, reject) => {
+    let req = navigator.mozApps.install(appManifestURL);
+    req.onsuccess = function() {
+      gApp = req.result;
+      is(req.result.manifestURL, appManifestURL, 'app installed');
+      if (req.result.installState == 'installed') {
+        is(req.result.installState, 'installed', 'app downloaded');
+        resolve()
+      } else {
+        req.result.ondownloadapplied = function() {
+          is(req.result.installState, 'installed', 'app downloaded');
+          resolve();
+        }
+      }
+    }
+    req.onerror = reject;
+  });
+}
+
+function setup() {
+  info('Setting up');
+  return new Promise((resolve, reject) => {
+    SpecialPowers.setAllAppsLaunchable(true);
+    SpecialPowers.pushPrefEnv({'set': [
+      ['dom.mozBrowserFramesEnabled', true],
+      ['dom.serviceWorkers.exemptFromPerDomainMax', true],
+      ['dom.serviceWorkers.enabled', true],
+      ['dom.serviceWorkers.testing.enabled', true]
+    ]}, () => {
+      SpecialPowers.pushPermissions([
+        { 'type': 'webapps-manage', 'allow': 1, 'context': document },
+        { 'type': 'browser', 'allow': 1, 'context': document },
+        { 'type': 'embed-apps', 'allow': 1, 'context': document }
+      ], () => {
+        SpecialPowers.autoConfirmAppInstall(() => {
+          SpecialPowers.autoConfirmAppUninstall(resolve);
+        });
+      });
+    });
+  });
+}
+
+function go() {
+  setup()
+    .then(attachMocks)
+    .then(function () {
+      AboutServiceWorkers.init();
+      return Promise.resolve();
+    })
+    .then(installApp)
+    .then(testApp)
+    .then(function() {
+      return chromeRequest({id: "0", name: "init"});
+    })
+    .then(function(result) {
+      return chromeRequest({
+        id: "1",
+        name: "update",
+        principal: result.registrations[0].principal,
+        scope: result.registrations[0].scope
+      });
+    })
+    .then(testApp)
+    .then(function() {
+      return chromeRequest({id: "2", name: "init"});
+    })
+    <!-- .then(function(result) { -->
+    <!--   return chromeRequest({ -->
+    <!--     id: "3", -->
+    <!--     name: "unregister", -->
+    <!--     principal: result.registrations[0].principal, -->
+    <!--     scope: result.registrations[0].scope -->
+    <!--   }); -->
+    <!-- }) -->
+    <!-- .then(function() { -->
+    <!--   return chromeRequest({id: "4", name: "init"}); -->
+    <!-- }) -->
+    <!-- .then(function(result) { -->
+    <!--   ok(result.registrations && result.registrations.length === 0, -->
+    <!--      "Service worker registration was successfuly unregistered"); -->
+    <!-- }) -->
+    .then(uninstallApp)
+    .then(restoreMocks)
+    .then(SimpleTest.finish)
+    .catch(function(e) {
+      ok(false, 'Unexpected error ' + e);
+      SimpleTest.finish();
+    });
+}
+  </script>
+</head>
+<body onload="go()">
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1171917">Mozilla Bug 1171917</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+</div>
+<pre id="test">
+</pre>
+<div id="container"></div>
+</body>
+</html>
diff --git a/b2g/components/test/moz.build b/b2g/components/test/moz.build
--- a/b2g/components/test/moz.build
+++ b/b2g/components/test/moz.build
@@ -1,8 +1,9 @@
 # -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 XPCSHELL_TESTS_MANIFESTS += ['unit/xpcshell.ini']
 MOCHITEST_MANIFESTS += ['mochitest/mochitest.ini']
+MOCHITEST_CHROME_MANIFESTS += ['mochitest/chrome.ini']
diff --git a/b2g/components/AboutServiceWorkers.jsm b/browser/components/AboutServiceWorkers.jsm
copy from b2g/components/AboutServiceWorkers.jsm
copy to browser/components/AboutServiceWorkers.jsm
--- a/b2g/components/AboutServiceWorkers.jsm
+++ b/browser/components/AboutServiceWorkers.jsm
@@ -6,25 +6,25 @@
 
 this.EXPORTED_SYMBOLS = ["AboutServiceWorkers"];
 
 const { interfaces: Ci, utils: Cu } = Components;
 
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
-XPCOMUtils.defineLazyModuleGetter(this, "SystemAppProxy",
-                                  "resource://gre/modules/SystemAppProxy.jsm");
+// XPCOMUtils.defineLazyModuleGetter(this, "SystemAppProxy",
+//                                   "resource://gre/modules/SystemAppProxy.jsm");
 
 XPCOMUtils.defineLazyServiceGetter(this, "gServiceWorkerManager",
                                   "@mozilla.org/serviceworkers/manager;1",
                                   "nsIServiceWorkerManager");
 
 function debug(aMsg) {
-  // dump("AboutServiceWorkers - " + aMsg + "\n");
+  dump("AboutServiceWorkers - " + aMsg + "\n");
 }
 
 function serializeServiceWorkerInfo(aServiceWorkerInfo) {
   if (!aServiceWorkerInfo) {
     throw new Error("Invalid service worker information");
   }
 
   let result = {};
@@ -55,32 +55,32 @@ this.AboutServiceWorkers = {
     this._enabled = false;
     try {
       this._enabled = Services.prefs.getBoolPref("dom.serviceWorkers.enabled");
     } catch(e) {}
     return this._enabled;
   },
 
   init: function() {
-    SystemAppProxy.addEventListener("mozAboutServiceWorkersContentEvent",
-                                    AboutServiceWorkers);
+    // SystemAppProxy.addEventListener("mozAboutServiceWorkersContentEvent",
+    //                                 AboutServiceWorkers);
   },
 
   sendResult: function(aId, aResult) {
-    SystemAppProxy._sendCustomEvent("mozAboutServiceWorkersChromeEvent", {
-      id: aId,
-      result: aResult
-    });
+    // SystemAppProxy._sendCustomEvent("mozAboutServiceWorkersChromeEvent", {
+    //   id: aId,
+    //   result: aResult
+    // });
   },
 
   sendError: function(aId, aError) {
-    SystemAppProxy._sendCustomEvent("mozAboutServiceWorkersChromeEvent", {
-      id: aId,
-      error: aError
-    });
+    // SystemAppProxy._sendCustomEvent("mozAboutServiceWorkersChromeEvent", {
+    //   id: aId,
+    //   error: aError
+    // });
   },
 
   handleEvent: function(aEvent) {
     let message = aEvent.detail;
 
     debug("Got content event " + JSON.stringify(message));
 
     if (!message.id || !message.name) {
diff --git a/browser/components/moz.build b/browser/components/moz.build
--- a/browser/components/moz.build
+++ b/browser/components/moz.build
@@ -37,23 +37,28 @@ XPIDL_MODULE = 'browsercompsbase'
 
 EXTRA_PP_COMPONENTS += [
     'BrowserComponents.manifest',
     'nsBrowserContentHandler.js',
     'nsBrowserGlue.js',
 ]
 
 EXTRA_JS_MODULES += [
+    'AboutServiceWorkers.jsm',
     'distribution.js',
 ]
 
 BROWSER_CHROME_MANIFESTS += [
     'test/browser.ini'
 ]
 
+MOCHITEST_CHROME_MANIFESTS += [
+    'test/chrome.ini'
+]
+
 if CONFIG['MOZ_SAFE_BROWSING']:
     BROWSER_CHROME_MANIFESTS += ['safebrowsing/content/test/browser.ini']
 
 with Files('safebrowsing/*'):
     BUG_COMPONENT = ('Toolkit', 'Phishing Protection')
 
 with Files('controlcenter/**'):
     BUG_COMPONENT = ('Firefox', 'General')
diff --git a/browser/components/test/app/client.html b/browser/components/test/app/client.html
new file mode 100644
--- /dev/null
+++ b/browser/components/test/app/client.html
@@ -0,0 +1,17 @@
+<!DOCTYPE HTML>
+<html>
+  <head>
+    <title>Test app for bug 1171917</title>
+    <script type='application/javascript;version=1.7'>
+
+function onLoad() {
+  navigator.serviceWorker.ready.then(function(swr) {
+    parent.postMessage({status: "callback", data: "ready"}, '*');
+  });
+}
+
+    </script>
+  </head>
+  <body onload='onLoad()'>
+  </body>
+</html>
diff --git a/browser/components/test/app/index.html b/browser/components/test/app/index.html
new file mode 100644
--- /dev/null
+++ b/browser/components/test/app/index.html
@@ -0,0 +1,77 @@
+<!DOCTYPE html>
+<html>
+  <head>
+    <title>Test app for bug 1171917</title>
+    <script type='application/javascript;version=1.7'>
+
+function ok(aCondition, aMessage) {
+  if (aCondition) {
+    alert('OK: ' + aMessage);
+  } else {
+    alert('KO: ' + aMessage);
+  }
+}
+
+function done() {
+  alert('DONE');
+}
+
+function testFrame(src) {
+  return new Promise(function(resolve, reject) {
+    var iframe = document.createElement("iframe");
+    iframe.src = src;
+    window.onmessage = function(e) {
+      if (e.data.status == "callback") {
+        window.onmessage = null;
+        var result = e.data.data;
+        iframe.src = "about:blank";
+        document.body.removeChild(iframe);
+        iframe = null;
+        resolve(result);
+      }
+    };
+    document.body.appendChild(iframe);
+  });
+}
+
+function registerServiceWorker() {
+  return navigator.serviceWorker.register('sw.sjs', {scope: '.'});
+}
+
+function runTests() {
+  var lastSeenVersion;
+  return Promise.resolve()
+    .then(function() {
+      // Check whether the service worker is already registered and save its
+      // version.
+      return navigator.serviceWorker.getRegistration(".").then(function(swr) {
+        if (!swr) {
+          lastSeenVersion = 0;
+          return registerServiceWorker();
+        }
+        return testFrame('version.html').then(function(body) {
+          lastSeenVersion = parseInt(body);
+          return Promise.resolve();
+        });
+      });
+    })
+    .then(function() {
+      // Wait until the service worker start controlling the client.
+      return testFrame('client.html');
+    })
+    .then(function() {
+      // Fetch current version. It should be greater than the last seen version.
+      return testFrame('version.html').then(function(body) {
+        var currentVersion = parseInt(body);
+        ok(lastSeenVersion < currentVersion, "New service worker version seen");
+        return Promise.resolve();
+      });
+    })
+    .then(done);
+}
+
+    </script>
+  </head>
+  <body onload='runTests()'>
+  </body>
+</html>
diff --git a/browser/components/test/app/manifest.webapp b/browser/components/test/app/manifest.webapp
new file mode 100644
--- /dev/null
+++ b/browser/components/test/app/manifest.webapp
@@ -0,0 +1,5 @@
+{
+  "name": "App",
+  "launch_path": "/index.html",
+  "description": "Test app for bug 1171917"
+}
diff --git a/browser/components/test/app/manifest.webapp^headers^ b/browser/components/test/app/manifest.webapp^headers^
new file mode 100644
--- /dev/null
+++ b/browser/components/test/app/manifest.webapp^headers^
@@ -0,0 +1,1 @@
+Content-Type: application/manifest+json
diff --git a/browser/components/test/app/sw.sjs b/browser/components/test/app/sw.sjs
new file mode 100644
--- /dev/null
+++ b/browser/components/test/app/sw.sjs
@@ -0,0 +1,22 @@
+function handleRequest(request, response) {
+  var stateName = request.scheme + 'counter';
+  if (!getState(stateName)) {
+    setState(stateName, '1');
+  } else {
+    // Make sure that we pass a string value to setState!
+    setState(stateName, "" + (parseInt(getState(stateName)) + 1));
+  }
+  response.setHeader("Content-Type", "application/javascript", false);
+  response.write(getScript(stateName));
+}
+
+function getScript(stateName) {
+  return "oninstall = function(evt) {" +
+           "evt.waitUntil(self.skipWaiting());" +
+         "}; " +
+         "onfetch = function(evt) {" +
+           "if (evt.request.url.indexOf('get-sw-version') > -1) {" +
+             "evt.respondWith(new Response('" + getState(stateName) + "'));" +
+           "}" +
+         "};";
+}
diff --git a/browser/components/test/app/version.html b/browser/components/test/app/version.html
new file mode 100644
--- /dev/null
+++ b/browser/components/test/app/version.html
@@ -0,0 +1,19 @@
+<!DOCTYPE HTML>
+<html>
+  <head>
+    <title>Test app for bug 1171917</title>
+    <script type='application/javascript;version=1.7'>
+
+function onLoad() {
+  fetch("get-sw-version").then(function(r) {
+    return r.text();
+  }).then(function(body) {
+    parent.postMessage({status: "callback", data: body}, "*");
+  });
+}
+
+    </script>
+  </head>
+  <body onload='onLoad()'>
+  </body>
+</html>
diff --git a/browser/components/test/chrome.ini b/browser/components/test/chrome.ini
new file mode 100644
--- /dev/null
+++ b/browser/components/test/chrome.ini
@@ -0,0 +1,6 @@
+[DEFAULT]
+skip-if = buildapp == 'b2g'
+support-files =
+  app/*
+
+[test_aboutserviceworkers.html]
diff --git a/browser/components/test/test_aboutserviceworkers.html b/browser/components/test/test_aboutserviceworkers.html
new file mode 100644
--- /dev/null
+++ b/browser/components/test/test_aboutserviceworkers.html
@@ -0,0 +1,258 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=1171917
+-->
+<head>
+  <meta charset="utf-8">
+  <title>Test for Bug 1171917</title>
+  <script type="application/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="chrome://mochikit/content/tests/SimpleTest/test.css"/>
+  <script type="application/javascript;version=1.7">
+
+const ASW_CHROME_EVENT = 'mozAboutServiceWorkersChromeEvent';
+const ASW_CONTENT_EVENT = 'mozAboutServiceWorkersContentEvent';
+
+const { classes: Cc, interfaces: Ci, utils: Cu } = Components;
+
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+XPCOMUtils.defineLazyServiceGetter(this, "gAppsService",
+                                   "@mozilla.org/AppsService;1",
+                                   "nsIAppsService");
+<!-- XPCOMUtils.defineLazyModuleGetter(this, "AboutServiceWorkers", -->
+<!--   "resource://gre/modules/AboutServiceWorkers.jsm"); -->
+XPCOMUtils.defineLazyModuleGetter(this, "AboutServiceWorkers",
+  "resource://gre/browser/modules/AboutServiceWorkers.jsm");
+
+SimpleTest.waitForExplicitFinish();
+
+<!-- const gOrigin = 'http://test/chrome/b2g/components/test/mochitest/app'; -->
+const gOrigin = 'http://test/chrome/browser/components/test/app';
+const appManifestURL = gOrigin + '/manifest.webapp';
+let gApp;
+
+const ORIGINAL_INIT = AboutServiceWorkers.init;
+const ORIGINAL_SENDRESULT = AboutServiceWorkers.sendResult;
+const ORIGINAL_SENDERROR = AboutServiceWorkers.sendError;
+
+function debug(aMsg) {
+  dump("test_aboutserviceworkers.html - " + aMsg + "\n");
+}
+
+function mockInit() {
+  window.addEventListener(ASW_CONTENT_EVENT, AboutServiceWorkers);
+}
+
+function mockSendResult(aId, aResult) {
+  debug("mockSendResult, " + JSON.stringify({ detail : {
+    id: aId,
+    result: aResult
+  }}));
+  let event = new CustomEvent(ASW_CHROME_EVENT, { detail : {
+    id: aId,
+    result: aResult
+  }});
+  window.dispatchEvent(event);
+}
+
+function mockSendError(aId, aError) {
+  debug("mockSendError, " + JSON.stringify({ detail : {
+    id: aId,
+    result: aError
+  }}));
+  let event = new CustomEvent(ASW_CHROME_EVENT, { detail: {
+    id: aId,
+    result: aError
+  }});
+  window.dispatchEvent(event);
+}
+
+function attachMocks() {
+  AboutServiceWorkers.init = mockInit;
+  AboutServiceWorkers.sendResult = mockSendResult;
+  AboutServiceWorkers.sendError = mockSendError;
+  return Promise.resolve();
+}
+
+function restoreMocks() {
+  AboutServiceWorkers.init = ORIGINAL_INIT;
+  AboutServiceWorkers.sendResult = ORIGINAL_SENDRESULT;
+  AboutServiceWorkers.sendError = ORIGINAL_SENDERROR;
+  return Promise.resolve();
+}
+
+function sendContentEvent(detail) {
+  let event = new CustomEvent(ASW_CONTENT_EVENT, {
+    detail: detail
+  });
+  window.dispatchEvent(event);
+}
+
+function chromeRequest(request) {
+  if (!request) {
+    return Promise.reject('InternalErrorMissingEventDetail');
+  }
+
+  return new Promise((resolve, reject) => {
+    let id = request.id;
+    window.addEventListener(ASW_CHROME_EVENT,
+                            function onChromeEvent(event) {
+      window.removeEventListener(ASW_CHROME_EVENT, onChromeEvent);
+      let message = event.detail;
+      if (!message || !message.id || message.id != id) {
+        return reject('InternalErrorWrongChromeEvent');
+      }
+
+      if (message.error) {
+        reject(message.error);
+      } else if (message.result) {
+        resolve(message.result);
+      }
+    });
+
+    sendContentEvent(request);
+  });
+}
+
+function uninstallApp() {
+  return new Promise((resolve, reject) => {
+    if (!gApp) {
+      return reject();
+    }
+    let req = navigator.mozApps.mgmt.uninstall(gApp);
+    req.onsuccess = resolve;
+    req.onerror = reject;
+  });
+}
+
+function testApp() {
+  if (!gApp) {
+    ok(false, 'No test application to launch');
+    return Promise.reject();
+  }
+  return new Promise((resolve, reject) => {
+    let iframe = document.createElement('iframe');
+    let domParent = document.getElementById('container');
+    iframe.setAttribute('mozbrowser', 'true');
+    iframe.setAttribute('mozapp', gApp.manifestURL);
+    iframe.addEventListener('mozbrowsershowmodalprompt', function listener(e) {
+      let message = e.detail.message;
+      if (/OK/.exec(message)) {
+        ok(true, "Message from app: " + message);
+      } else if (/DONE/.exec(message)) {
+        ok(true, "Message from app: " + message);
+        iframe.src = "about:blank";
+        domParent.removeChild(iframe);
+        iframe = null;
+        resolve();
+      }
+    }, false);
+    domParent.appendChild(iframe);
+    ok(true, "origin " +  gOrigin + gApp.manifest.launch_path);
+    SpecialPowers.wrap(iframe.contentWindow).location =
+      gOrigin + gApp.manifest.launch_path;
+  });
+}
+
+function installApp() {
+  return new Promise((resolve, reject) => {
+    let req = navigator.mozApps.install(appManifestURL);
+    req.onsuccess = function() {
+      gApp = req.result;
+      is(req.result.manifestURL, appManifestURL, 'app installed');
+      if (req.result.installState == 'installed') {
+        is(req.result.installState, 'installed', 'app downloaded');
+        resolve()
+      } else {
+        req.result.ondownloadapplied = function() {
+          is(req.result.installState, 'installed', 'app downloaded');
+          resolve();
+        }
+      }
+    }
+    req.onerror = reject;
+  });
+}
+
+function setup() {
+  info('Setting up');
+  return new Promise((resolve, reject) => {
+    SpecialPowers.setAllAppsLaunchable(true);
+    SpecialPowers.pushPrefEnv({'set': [
+      ['dom.mozBrowserFramesEnabled', true],
+      ['dom.serviceWorkers.exemptFromPerDomainMax', true],
+      ['dom.serviceWorkers.enabled', true],
+      ['dom.serviceWorkers.testing.enabled', true]
+    ]}, () => {
+      SpecialPowers.pushPermissions([
+        { 'type': 'webapps-manage', 'allow': 1, 'context': document },
+        { 'type': 'browser', 'allow': 1, 'context': document },
+        { 'type': 'embed-apps', 'allow': 1, 'context': document }
+      ], () => {
+        SpecialPowers.autoConfirmAppInstall(() => {
+          SpecialPowers.autoConfirmAppUninstall(resolve);
+        });
+      });
+    });
+  });
+}
+
+function go() {
+  setup()
+    .then(attachMocks)
+    .then(function () {
+      AboutServiceWorkers.init();
+      return Promise.resolve();
+    })
+    .then(installApp)
+    .then(testApp)
+    .then(function() {
+      return chromeRequest({id: "0", name: "init"});
+    })
+    .then(function(result) {
+      return chromeRequest({
+        id: "1",
+        name: "update",
+        principal: result.registrations[0].principal,
+        scope: result.registrations[0].scope
+      });
+    })
+    .then(testApp)
+    .then(function() {
+      return chromeRequest({id: "2", name: "init"});
+    })
+    <!-- .then(function(result) { -->
+    <!--   return chromeRequest({ -->
+    <!--     id: "3", -->
+    <!--     name: "unregister", -->
+    <!--     principal: result.registrations[0].principal, -->
+    <!--     scope: result.registrations[0].scope -->
+    <!--   }); -->
+    <!-- }) -->
+    <!-- .then(function() { -->
+    <!--   return chromeRequest({id: "4", name: "init"}); -->
+    <!-- }) -->
+    <!-- .then(function(result) { -->
+    <!--   ok(result.registrations && result.registrations.length === 0, -->
+    <!--      "Service worker registration was successfuly unregistered"); -->
+    <!-- }) -->
+    .then(uninstallApp)
+    .then(restoreMocks)
+    .then(SimpleTest.finish)
+    .catch(function(e) {
+      ok(false, 'Unexpected error ' + e);
+      SimpleTest.finish();
+    });
+}
+  </script>
+</head>
+<body onload="go()">
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1171917">Mozilla Bug 1171917</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+</div>
+<pre id="test">
+</pre>
+<div id="container"></div>
+</body>
+</html>
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -927,16 +927,17 @@ public:
   {
     mQueue = nullptr;
     mCanceled = true;
   }
 
   void
   Start() override
   {
+    printf_stderr("### ### - ServiceWorkerRegisterJob::Start()\n");
     MOZ_ASSERT(NS_IsMainThread());
     MOZ_ASSERT(!mCanceled);
 
     nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
     if (!swm->HasBackgroundActor()) {
       nsCOMPtr<nsIRunnable> runnable =
         NS_NewRunnableMethod(this, &ServiceWorkerRegisterJob::Start);
       swm->AppendPendingOperation(runnable);
@@ -969,24 +970,26 @@ public:
       }
 
       mRegistration->mScriptSpec = mScriptSpec;
       swm->StoreRegistration(mPrincipal, mRegistration);
     } else {
       MOZ_ASSERT(mJobType == UPDATE_JOB);
     }
 
+    printf_stderr("### ### - ServiceWorkerRegisterJob::Start(), Update()\n");
     Update();
   }
 
   void
   ComparisonResult(nsresult aStatus, bool aInCacheAndEqual,
                    const nsAString& aNewCacheName,
                    const nsACString& aMaxScope) override
   {
+    printf_stderr("### ### - ServiceWorkerRegisterJob::ComparationResult()\n");
     nsRefPtr<ServiceWorkerRegisterJob> kungFuDeathGrip = this;
     if (mCanceled) {
       Fail(NS_ERROR_DOM_TYPE_ERR);
       return;
     }
 
     if (NS_WARN_IF(NS_FAILED(aStatus))) {
       Fail(NS_ERROR_DOM_TYPE_ERR);
@@ -1203,16 +1206,17 @@ private:
     NS_DispatchToMainThread(r);
   }
 
   // Aspects of (actually the whole algorithm) of [[Update]] after
   // "Run the following steps in parallel."
   void
   ContinueUpdate()
   {
+    printf_stderr("### ### - ServiceWorkerRegisterJob::ContinueUpdate()\n");
     AssertIsOnMainThread();
     nsRefPtr<ServiceWorkerRegisterJob> kungFuDeathGrip = this;
     if (mCanceled) {
       return Fail(NS_ERROR_DOM_ABORT_ERR);
     }
 
     if (mRegistration->mInstallingWorker) {
       // FIXME(nsm): "Terminate installing worker".
@@ -3016,27 +3020,30 @@ ServiceWorkerManager::FindScopeForPath(c
   return false;
 }
 
 #ifdef DEBUG
 /* static */ bool
 ServiceWorkerManager::HasScope(nsIPrincipal* aPrincipal,
                                const nsACString& aScope)
 {
+  return true;
   nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   MOZ_ASSERT(swm);
 
   nsAutoCString scopeKey;
   nsresult rv = PrincipalToScopeKey(aPrincipal, scopeKey);
   if (NS_WARN_IF(NS_FAILED(rv))) {
+    printf_stderr("### ### - ServiceWorkerManager::HasScope(), PrincipalToScopeKey false\n");
     return false;
   }
 
   RegistrationDataPerPrincipal* data;
   if (!swm->mRegistrationInfos.Get(scopeKey, &data)) {
+    printf_stderr("### ### - ServiceWorkerManager::HasScope(), !swm->mRegistrationInfos.Get false\n");
     return false;
   }
 
   return data->mOrderedScopes.Contains(aScope);
 }
 #endif
 
 /* static */ void
@@ -3843,37 +3850,42 @@ ServiceWorkerManager::SoftUpdate(const O
   aOriginAttributes.CreateSuffix(scopeKey);
   SoftUpdate(scopeKey, aScope);
 }
 
 void
 ServiceWorkerManager::SoftUpdate(const nsACString& aScopeKey,
                                  const nsACString& aScope)
 {
+  printf_stderr("### ### - ServiceWorkerManager::SoftUpdate()\n");
   nsRefPtr<ServiceWorkerRegistrationInfo> registration =
     GetRegistration(aScopeKey, aScope);
   if (NS_WARN_IF(!registration)) {
+    printf_stderr("### ### - ServiceWorkerManager::SoftUpdate() 1\n");
     return;
   }
 
   // "If registration's uninstalling flag is set, abort these steps."
   if (registration->mPendingUninstall) {
+    printf_stderr("### ### - ServiceWorkerManager::SoftUpdate() 2\n");
     return;
   }
 
   // "If registration's installing worker is not null, abort these steps."
   if (registration->mInstallingWorker) {
+    printf_stderr("### ### - ServiceWorkerManager::SoftUpdate() 3\n");
     return;
   }
 
   // "Let newestWorker be the result of running Get Newest Worker algorithm
   // passing registration as its argument.
   // If newestWorker is null, abort these steps."
   nsRefPtr<ServiceWorkerInfo> newest = registration->Newest();
   if (!newest) {
+    printf_stderr("### ### - ServiceWorkerManager::SoftUpdate() 4\n");
     return;
   }
 
   // "Set registration's registering script url to newestWorker's script url."
   registration->mScriptSpec = newest->ScriptSpec();
 
   ServiceWorkerJobQueue* queue =
     GetOrCreateJobQueue(aScopeKey, aScope);
@@ -4678,40 +4690,44 @@ ServiceWorkerManager::Observe(nsISupport
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerManager::PropagateSoftUpdate(JS::Handle<JS::Value> aOriginAttributes,
                                           const nsAString& aScope,
                                           JSContext* aCx)
 {
+  printf_stderr("### ### - ServiceWorkerManager::PropagateSoftUpdate()\n");
   MOZ_ASSERT(NS_IsMainThread());
 
   OriginAttributes attrs;
   if (!aOriginAttributes.isObject() || !attrs.Init(aCx, aOriginAttributes)) {
     return NS_ERROR_INVALID_ARG;
   }
 
   PropagateSoftUpdate(attrs, aScope);
   return NS_OK;
 }
 
 void
 ServiceWorkerManager::PropagateSoftUpdate(const OriginAttributes& aOriginAttributes,
                                           const nsAString& aScope)
 {
+  printf_stderr("### ### - ServiceWorkerManager::PropagateSoftUpdate()\n");
   MOZ_ASSERT(NS_IsMainThread());
 
   if (!mActor) {
+    printf_stderr("### ### - ServiceWorkerManager::PropagateSoftUpdate(), no actor\n");
     nsRefPtr<nsIRunnable> runnable =
       new PropagateSoftUpdateRunnable(aOriginAttributes, aScope);
     AppendPendingOperation(runnable);
     return;
   }
 
+  printf_stderr("### ### - ServiceWorkerManager::PropagateSoftUpdate(), actor\n");
   mActor->SendPropagateSoftUpdate(aOriginAttributes, nsString(aScope));
 }
 
 NS_IMETHODIMP
 ServiceWorkerManager::PropagateUnregister(nsIPrincipal* aPrincipal,
                                           nsIServiceWorkerUnregisterCallback* aCallback,
                                           const nsAString& aScope)
 {
diff --git a/dom/workers/ServiceWorkerManagerChild.cpp b/dom/workers/ServiceWorkerManagerChild.cpp
--- a/dom/workers/ServiceWorkerManagerChild.cpp
+++ b/dom/workers/ServiceWorkerManagerChild.cpp
@@ -30,16 +30,17 @@ ServiceWorkerManagerChild::RecvNotifyReg
   return true;
 }
 
 bool
 ServiceWorkerManagerChild::RecvNotifySoftUpdate(
                                       const OriginAttributes& aOriginAttributes,
                                       const nsString& aScope)
 {
+  printf_stderr("### ### - ServiceWorkerManagerChild::RecvNotifySoftUpdate()\n");
   if (mShuttingDown) {
     return true;
   }
 
   nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   MOZ_ASSERT(swm);
 
   swm->SoftUpdate(aOriginAttributes, NS_ConvertUTF16toUTF8(aScope));
diff --git a/dom/workers/ServiceWorkerManagerParent.cpp b/dom/workers/ServiceWorkerManagerParent.cpp
--- a/dom/workers/ServiceWorkerManagerParent.cpp
+++ b/dom/workers/ServiceWorkerManagerParent.cpp
@@ -227,16 +227,17 @@ ServiceWorkerManagerParent::RecvUnregist
 
   return true;
 }
 
 bool
 ServiceWorkerManagerParent::RecvPropagateSoftUpdate(const OriginAttributes& aOriginAttributes,
                                                     const nsString& aScope)
 {
+  printf_stderr("### ### - ServiceWorkerManagerParent::RecvPropagateSoftUpdate()\n");
   AssertIsOnBackgroundThread();
 
   if (NS_WARN_IF(!mService)) {
     return false;
   }
 
   mService->PropagateSoftUpdate(mID, aOriginAttributes, aScope);
   return true;
diff --git a/dom/workers/ServiceWorkerManagerService.cpp b/dom/workers/ServiceWorkerManagerService.cpp
--- a/dom/workers/ServiceWorkerManagerService.cpp
+++ b/dom/workers/ServiceWorkerManagerService.cpp
@@ -156,30 +156,38 @@ struct MOZ_STACK_CLASS SoftUpdateData fi
 #ifdef DEBUG
   bool mParentFound;
 #endif
 };
 
 PLDHashOperator
 SoftUpdateEnumerator(nsPtrHashKey<ServiceWorkerManagerParent>* aKey, void* aPtr)
 {
+  printf_stderr("### ### - SoftUpdateEnumerator()\n");
   AssertIsOnBackgroundThread();
 
   auto* data = static_cast<SoftUpdateData*>(aPtr);
   ServiceWorkerManagerParent* parent = aKey->GetKey();
   MOZ_ASSERT(parent);
 
-  if (parent->ID() != data->mParentID) {
-    unused <<parent->SendNotifySoftUpdate(data->mOriginAttributes,
-                                          data->mScope);
+//   if (parent->ID() != data->mParentID) {
+//     unused <<parent->SendNotifySoftUpdate(data->mOriginAttributes,
+//                                           data->mScope);
+// #ifdef DEBUG
+//   } else {
+//     data->mParentFound = true;
+// #endif
+//   }
+  unused <<parent->SendNotifySoftUpdate(data->mOriginAttributes,
+                                        data->mScope);
 #ifdef DEBUG
-  } else {
+  if (parent->ID() == data->mParentID) {
     data->mParentFound = true;
+  }
 #endif
-  }
 
   return PL_DHASH_NEXT;
 }
 
 struct MOZ_STACK_CLASS UnregisterData final
 {
   UnregisterData(const PrincipalInfo& aPrincipalInfo,
                  const nsAString& aScope,
@@ -332,16 +340,17 @@ ServiceWorkerManagerService::PropagateRe
 }
 
 void
 ServiceWorkerManagerService::PropagateSoftUpdate(
                                       uint64_t aParentID,
                                       const OriginAttributes& aOriginAttributes,
                                       const nsAString& aScope)
 {
+  printf_stderr("### ### - ServiceWorkerManagerService::PropagateSoftUpdate()\n");
   AssertIsOnBackgroundThread();
 
   SoftUpdateData data(aOriginAttributes, aScope, aParentID);
   mAgents.EnumerateEntries(SoftUpdateEnumerator, &data);
 
 #ifdef DEBUG
   MOZ_ASSERT(data.mParentFound);
 #endif
