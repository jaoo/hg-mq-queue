# HG changeset patch
# Parent 32249d9b40563787a5dbab64849c887d724c038b
# User Jose Antonio Olivera Ortega <josea.olivera@gmail.com>
Bug 1139513 - Warn and gather data if ServiceWorker hits max workers per domain limit. r=baku

diff --git a/dom/locales/en-US/chrome/dom/dom.properties b/dom/locales/en-US/chrome/dom/dom.properties
--- a/dom/locales/en-US/chrome/dom/dom.properties
+++ b/dom/locales/en-US/chrome/dom/dom.properties
@@ -156,8 +156,9 @@ DataContainerEventWarning=Use of DataCon
 # LOCALIZATION NOTE: Do not translate "window.controllers"
 Window_ControllersWarning=window.controllers is deprecated. Do not use it for UA detection.
 ImportXULIntoContentWarning=Importing XUL nodes into a content document is deprecated. This functionality may be removed soon.
 XMLDocumentLoadPrincipalMismatch=Use of document.load forbidden on Documents that come from other Windows. Only the Window in which a Document was created is allowed to call .load on that Document. Preferably, use XMLHttpRequest instead.
 # LOCALIZATION NOTE: Do not translate "IndexedDB".
 IndexedDBTransactionAbortNavigation=An IndexedDB transaction that was not yet complete has been aborted due to page navigation.
 # LOCALIZATION NOTE (WillChangeBudgetWarning): Do not translate Will-change, %1$S,%2$S,%3$S are numbers.
 WillChangeBudgetWarning=Will-change memory consumption is too high. Surface area covers %1$S pixels, budget is the document surface area multiplied by %2$S (%3$S pixels). All occurences of will-change in the document are ignored when over budget.
+HittingMaxWorkersPerDomain=ServiceWorker spawn gets queued due to hitting max workers per domain limit.
diff --git a/dom/workers/RuntimeService.cpp b/dom/workers/RuntimeService.cpp
--- a/dom/workers/RuntimeService.cpp
+++ b/dom/workers/RuntimeService.cpp
@@ -9,29 +9,31 @@
 #include "nsIChannel.h"
 #include "nsIContentSecurityPolicy.h"
 #include "nsIDocument.h"
 #include "nsIDOMChromeWindow.h"
 #include "nsIEffectiveTLDService.h"
 #include "nsIObserverService.h"
 #include "nsIPrincipal.h"
 #include "nsIScriptContext.h"
+#include "nsIScriptError.h"
 #include "nsIScriptSecurityManager.h"
 #include "nsISupportsPriority.h"
 #include "nsITimer.h"
 #include "nsIURI.h"
 #include "nsPIDOMWindow.h"
 
 #include <algorithm>
 #include "BackgroundChild.h"
 #include "GeckoProfiler.h"
 #include "jsfriendapi.h"
 #include "mozilla/ArrayUtils.h"
 #include "mozilla/CycleCollectedJSRuntime.h"
 #include "mozilla/TimeStamp.h"
+#include "mozilla/Telemetry.h"
 #include "mozilla/dom/asmjscache/AsmJSCache.h"
 #include "mozilla/dom/AtomList.h"
 #include "mozilla/dom/BindingUtils.h"
 #include "mozilla/dom/ErrorEventBinding.h"
 #include "mozilla/dom/EventTargetBinding.h"
 #include "mozilla/dom/MessageEventBinding.h"
 #include "mozilla/dom/WorkerBinding.h"
 #include "mozilla/dom/ScriptSettings.h"
@@ -1414,16 +1416,18 @@ RuntimeService::RegisterWorker(JSContext
 
   nsCString sharedWorkerScriptSpec;
 
   bool isSharedOrServiceWorker = aWorkerPrivate->IsSharedWorker() ||
                                  aWorkerPrivate->IsServiceWorker();
   if (isSharedOrServiceWorker) {
     AssertIsOnMainThread();
 
+    Telemetry::Accumulate(Telemetry::SERVICE_WORKER_SPAWN_ATTEMPS, 1);
+
     nsCOMPtr<nsIURI> scriptURI = aWorkerPrivate->GetResolvedScriptURI();
     NS_ASSERTION(scriptURI, "Null script URI!");
 
     nsresult rv = scriptURI->GetSpec(sharedWorkerScriptSpec);
     if (NS_FAILED(rv)) {
       NS_WARNING("GetSpec failed?!");
       xpc::Throw(aCx, rv);
       return false;
@@ -1446,32 +1450,58 @@ RuntimeService::RegisterWorker(JSContext
   {
     MutexAutoLock lock(mMutex);
 
     if (!mDomainMap.Get(domain, &domainInfo)) {
       NS_ASSERTION(!parent, "Shouldn't have a parent here!");
 
       domainInfo = new WorkerDomainInfo();
       domainInfo->mDomain = domain;
+      if (isSharedOrServiceWorker && !domainInfo->mDomainTracked) {
+        Telemetry::Accumulate(Telemetry::DOMAIN_WITH_SERVICE_WORKERS, 1);        
+        domainInfo->mDomainTracked = true;
+      }
       mDomainMap.Put(domain, domainInfo);
     }
 
     queued = gMaxWorkersPerDomain &&
              domainInfo->ActiveWorkerCount() >= gMaxWorkersPerDomain &&
              !domain.IsEmpty() &&
              !exemptFromPerDomainMax;
 
     if (queued) {
       domainInfo->mQueuedWorkers.AppendElement(aWorkerPrivate);
+      if (isSharedOrServiceWorker) {
+        // ServiceWorker spawn gets queued due to hitting max workers per domain
+        // limit so let's log a warning.
+        // Note: aWorkerPrivate->GetDocument() call might result nullptr due to
+        // no window so the message warning will show up in the browser console.
+        nsContentUtils::ReportToConsole(nsIScriptError::warningFlag,
+                                        NS_LITERAL_CSTRING("DOM"),
+                                        aWorkerPrivate->GetDocument(),
+                                        nsContentUtils::eDOM_PROPERTIES,
+                                        "HittingMaxWorkersPerDomain");
+        Telemetry::Accumulate(Telemetry::SERVICE_WORKER_SPAWN_GETS_QUEUED, 1);
+        if (!domainInfo->mDomainHitMaxWorkersLimitTracked) {
+          Telemetry::Accumulate(Telemetry::DOMAIN_HITS_SERVICE_WORKERS_LIMIT, 1);
+          domainInfo->mDomainHitMaxWorkersLimitTracked = true;
+        }
+      }
     }
     else if (parent) {
       domainInfo->mChildWorkerCount++;
+      if (isSharedOrServiceWorker) {
+        Telemetry::Accumulate(Telemetry::SERVICE_WORKER_WAS_SPAWNED, 1);
+      }
     }
     else {
       domainInfo->mActiveWorkers.AppendElement(aWorkerPrivate);
+      if (isSharedOrServiceWorker) {
+        Telemetry::Accumulate(Telemetry::SERVICE_WORKER_WAS_SPAWNED, 1);
+      }
     }
 
     if (isSharedOrServiceWorker) {
       const nsCString& sharedWorkerName = aWorkerPrivate->SharedWorkerName();
 
       nsAutoCString key;
       GenerateSharedWorkerKey(sharedWorkerScriptSpec, sharedWorkerName,
                               aWorkerPrivate->Type(), key);
@@ -1480,16 +1510,18 @@ RuntimeService::RegisterWorker(JSContext
       SharedWorkerInfo* sharedWorkerInfo =
         new SharedWorkerInfo(aWorkerPrivate, sharedWorkerScriptSpec,
                              sharedWorkerName);
       domainInfo->mSharedWorkerInfos.Put(key, sharedWorkerInfo);
     }
   }
 
   // From here on out we must call UnregisterWorker if something fails!
+  // TODO: Should we decrease the counters of service workers spawns if the
+  // worker ends up unregistered?
   if (parent) {
     if (!parent->AddChildWorker(aCx, aWorkerPrivate)) {
       UnregisterWorker(aCx, aWorkerPrivate);
       return false;
     }
   }
   else {
     if (!mNavigatorPropertiesLoaded) {
diff --git a/dom/workers/RuntimeService.h b/dom/workers/RuntimeService.h
--- a/dom/workers/RuntimeService.h
+++ b/dom/workers/RuntimeService.h
@@ -42,19 +42,22 @@ class RuntimeService MOZ_FINAL : public 
 
   struct WorkerDomainInfo
   {
     nsCString mDomain;
     nsTArray<WorkerPrivate*> mActiveWorkers;
     nsTArray<WorkerPrivate*> mQueuedWorkers;
     nsClassHashtable<nsCStringHashKey, SharedWorkerInfo> mSharedWorkerInfos;
     uint32_t mChildWorkerCount;
+    bool mDomainTracked;
+    bool mDomainHitMaxWorkersLimitTracked;
 
     WorkerDomainInfo()
-    : mActiveWorkers(1), mChildWorkerCount(0)
+      : mActiveWorkers(1), mChildWorkerCount(0),
+        mDomainTracked(false), mDomainHitMaxWorkersLimitTracked(false)
     { }
 
     uint32_t
     ActiveWorkerCount() const
     {
       return mActiveWorkers.Length() + mChildWorkerCount;
     }
   };
diff --git a/toolkit/components/telemetry/Histograms.json b/toolkit/components/telemetry/Histograms.json
--- a/toolkit/components/telemetry/Histograms.json
+++ b/toolkit/components/telemetry/Histograms.json
@@ -7673,10 +7673,35 @@
     "kind": "count",
     "description": "Count slow script notices"
   },
   "PLUGIN_HANG_NOTICE_COUNT": {
     "alert_emails": ["perf-telemetry-alerts@mozilla.com"],
     "expires_in_version": "never",
     "kind": "count",
     "description": "Count plugin hang notices in e10s"
+  },
+  "SERVICE_WORKER_SPAWN_ATTEMPS": {
+    "expires_in_version": "never",
+    "kind": "count",
+    "description": "Tracking ServiceWorker spawn attemps"
+  },
+  "SERVICE_WORKER_WAS_SPAWNED": {
+    "expires_in_version": "never",
+    "kind": "count",
+    "description": "Tracking whether a ServiceWorker was really spawned"
+  },
+  "SERVICE_WORKER_SPAWN_GETS_QUEUED": {
+    "expires_in_version": "never",
+    "kind": "count",
+    "description": "Tracking whether a ServiceWorker spawn gets queued due to hitting max workers per domain limit"
+  },
+  "DOMAIN_WITH_SERVICE_WORKERS": {
+    "expires_in_version": "never",
+    "kind": "count",
+    "description": "Tracking the number of domains where service workers are registered"
+  },
+  "DOMAIN_HITS_SERVICE_WORKERS_LIMIT": {
+    "expires_in_version": "never",
+    "kind": "count",
+    "description": "Tracking the number of domains where the number of service workers hits the limit"
   }
 }
