# HG changeset patch
# Parent bad18a3da182b2f54558af2e9354e55863f83ce6
# User Andrea Marchesini <amarchesini@mozilla.com>

diff --git a/caps/BasePrincipal.cpp b/caps/BasePrincipal.cpp
--- a/caps/BasePrincipal.cpp
+++ b/caps/BasePrincipal.cpp
@@ -16,17 +16,17 @@
 #include "nsScriptSecurityManager.h"
 
 #include "mozilla/dom/CSPDictionariesBinding.h"
 #include "mozilla/dom/ToJSValue.h"
 
 namespace mozilla {
 
 void
-OriginAttributes::CreateSuffix(nsACString& aStr)
+OriginAttributes::CreateSuffix(nsACString& aStr) const
 {
   aStr.Truncate();
   MOZ_RELEASE_ASSERT(mAppId != nsIScriptSecurityManager::UNKNOWN_APP_ID);
   int attrCount = 0;
 
   if (mAppId != nsIScriptSecurityManager::NO_APP_ID) {
     aStr.Append(attrCount++ ? "&appId=" : "!appId=");
     aStr.AppendInt(mAppId);
diff --git a/caps/BasePrincipal.h b/caps/BasePrincipal.h
--- a/caps/BasePrincipal.h
+++ b/caps/BasePrincipal.h
@@ -36,17 +36,17 @@ public:
   bool operator!=(const OriginAttributes& aOther) const
   {
     return !(*this == aOther);
   }
 
   // Serializes non-default values into the suffix format, i.e.
   // |!key1=value1&key2=value2|. If there are no non-default attributes, this
   // returns an empty string.
-  void CreateSuffix(nsACString& aStr);
+  void CreateSuffix(nsACString& aStr) const;
 
   void Serialize(nsIObjectOutputStream* aStream) const;
   nsresult Deserialize(nsIObjectInputStream* aStream);
 };
 
 /*
  * Base class from which all nsIPrincipal implementations inherit. Use this for
  * default implementations and other commonalities between principal
diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -12,16 +12,17 @@
 #include "mozilla/Attributes.h"
 #include "mozilla/AutoRestore.h"
 #include "mozilla/Casting.h"
 #include "mozilla/dom/ContentChild.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/TabChild.h"
 #include "mozilla/dom/ProfileTimelineMarkerBinding.h"
 #include "mozilla/dom/ToJSValue.h"
+#include "mozilla/dom/workers/ServiceWorkerManager.h"
 #include "mozilla/EventStateManager.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/Services.h"
 #include "mozilla/StartupTimeline.h"
 #include "mozilla/Telemetry.h"
 #include "mozilla/unused.h"
 #include "mozilla/VisualEventTracer.h"
 #include "URIUtils.h"
@@ -47,17 +48,16 @@
 #include "nsIWebBrowserChrome.h"
 #include "nsPoint.h"
 #include "nsIObserverService.h"
 #include "nsIPrompt.h"
 #include "nsIAuthPrompt.h"
 #include "nsIAuthPrompt2.h"
 #include "nsIChannelEventSink.h"
 #include "nsIAsyncVerifyRedirectCallback.h"
-#include "nsIServiceWorkerManager.h"
 #include "nsIScriptSecurityManager.h"
 #include "nsIScriptObjectPrincipal.h"
 #include "nsIScrollableFrame.h"
 #include "nsContentPolicyUtils.h" // NS_CheckContentLoadPolicy(...)
 #include "nsISeekableStream.h"
 #include "nsAutoPtr.h"
 #include "nsQueryObject.h"
 #include "nsIWritablePropertyBag2.h"
@@ -212,16 +212,17 @@ static NS_DEFINE_CID(kAppShellCID, NS_AP
 #include <process.h>
 #define getpid _getpid
 #else
 #include <unistd.h> // for getpid()
 #endif
 
 using namespace mozilla;
 using namespace mozilla::dom;
+using mozilla::dom::workers::ServiceWorkerManager;
 
 // True means sUseErrorPages has been added to preferences var cache.
 static bool gAddedPreferencesVarCache = false;
 
 bool nsDocShell::sUseErrorPages = false;
 
 // Number of documents currently loading
 static int32_t gNumberOfDocumentsLoading = 0;
@@ -14023,37 +14024,45 @@ nsDocShell::ShouldPrepareForIntercept(ns
                                       bool* aShouldIntercept)
 {
   *aShouldIntercept = false;
   if (mSandboxFlags) {
     // If we're sandboxed, don't intercept.
     return NS_OK;
   }
 
-  nsCOMPtr<nsIServiceWorkerManager> swm = services::GetServiceWorkerManager();
+  nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (!swm) {
     return NS_OK;
   }
 
   if (aIsNavigate) {
-    return swm->IsAvailableForURI(aURI, aShouldIntercept);
+    OriginAttributes attrs(GetAppId(), GetIsInBrowserElement());
+    *aShouldIntercept = swm->IsAvailableForURI(attrs, aURI);
+    return NS_OK;
   }
 
   nsCOMPtr<nsIDocument> doc = GetDocument();
   if (!doc) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
-  return swm->IsControlled(doc, aShouldIntercept);
+  ErrorResult rv;
+  *aShouldIntercept = swm->IsControlled(doc, rv);
+  if (NS_WARN_IF(rv.Failed())) {
+    return rv.StealNSResult();
+  }
+
+  return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDocShell::ChannelIntercepted(nsIInterceptedChannel* aChannel)
 {
-  nsCOMPtr<nsIServiceWorkerManager> swm = services::GetServiceWorkerManager();
+  nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (!swm) {
     aChannel->Cancel();
     return NS_OK;
   }
 
   bool isNavigation = false;
   nsresult rv = aChannel->GetIsNavigation(&isNavigation);
   NS_ENSURE_SUCCESS(rv, rv);
@@ -14063,17 +14072,26 @@ nsDocShell::ChannelIntercepted(nsIInterc
   if (!isNavigation) {
     doc = GetDocument();
     if (!doc) {
       return NS_ERROR_NOT_AVAILABLE;
     }
   }
 
   bool isReload = mLoadType & LOAD_CMD_RELOAD;
-  return swm->DispatchFetchEvent(doc, aChannel, isReload);
+
+  OriginAttributes attrs(GetAppId(), GetIsInBrowserElement());
+
+  ErrorResult error;
+  swm->DispatchFetchEvent(attrs, doc, aChannel, isReload, error);
+  if (NS_WARN_IF(error.Failed())) {
+    return error.StealNSResult();
+  }
+
+  return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDocShell::SetPaymentRequestId(const nsAString& aPaymentRequestId)
 {
   mPaymentRequestId = aPaymentRequestId;
   return NS_OK;
 }
diff --git a/dom/interfaces/base/nsIServiceWorkerManager.idl b/dom/interfaces/base/nsIServiceWorkerManager.idl
--- a/dom/interfaces/base/nsIServiceWorkerManager.idl
+++ b/dom/interfaces/base/nsIServiceWorkerManager.idl
@@ -15,17 +15,17 @@ interface nsIURI;
 interface nsIServiceWorkerUnregisterCallback : nsISupports
 {
   // aState is true if the unregistration succeded.
   // It's false if this ServiceWorkerRegistration doesn't exist.
   void unregisterSucceeded(in bool aState);
   void unregisterFailed();
 };
 
-[scriptable, builtinclass, uuid(8ce0d197-5740-4ddf-aa4a-e5a63e611d03)]
+[scriptable, builtinclass, uuid(103763c8-53ba-42e4-8b26-e601d5bc4afe)]
 interface nsIServiceWorkerInfo : nsISupports
 {
   readonly attribute nsIPrincipal principal;
 
   readonly attribute DOMString scope;
   readonly attribute DOMString scriptSpec;
   readonly attribute DOMString currentWorkerURL;
 
@@ -61,26 +61,16 @@ interface nsIServiceWorkerManager : nsIS
   nsISupports getRegistration(in nsIDOMWindow aWindow, in DOMString aScope);
 
   // Returns a Promise
   nsISupports getReadyPromise(in nsIDOMWindow aWindow);
 
   // Remove ready pending Promise
   void removeReadyPromise(in nsIDOMWindow aWindow);
 
-  // Returns true if a ServiceWorker is available for the scope of aURI.
-  bool isAvailableForURI(in nsIURI aURI);
-
-  // Returns true if a given document is currently controlled by a ServiceWorker
-  bool isControlled(in nsIDocument aDocument);
-
-  // Cause a fetch event to be dispatched to the worker global associated with the given document.
-  void dispatchFetchEvent(in nsIDocument aDoc, in nsIInterceptedChannel aChannel,
-                          in boolean aIsReload);
-
   /**
    * Call this to request that document `aDoc` be controlled by a ServiceWorker
    * if a registration exists for it's scope.
    *
    * This MUST only be called once per document!
    */
   [notxpcom,nostdcall] void MaybeStartControlling(in nsIDocument aDoc);
 
@@ -103,18 +93,20 @@ interface nsIServiceWorkerManager : nsIS
 
   /*
    * Returns a ServiceWorker.
    */
   [noscript] nsISupports GetDocumentController(in nsIDOMWindow aWindow);
 
   /*
    * This implements the soft update algorithm.
+   * XXXbaku this can be removed when bug 1155153 lands.
    */
-  void softUpdate(in DOMString aScope);
+  [implicit_jscontext] void softUpdate(in jsval aOriginAttributes,
+                                       in DOMString aScope);
 
   /*
    * Clears ServiceWorker registrations from memory and disk for the specified
    * host.
    * - All ServiceWorker instances change their state to redundant.
    * - Existing ServiceWorker instances handling fetches will keep running.
    * - All documents will immediately stop being controlled.
    * - Unregister jobs will be queued for all registrations.
@@ -123,23 +115,26 @@ interface nsIServiceWorkerManager : nsIS
   void remove(in AUTF8String aHost);
 
   /*
    * Clear all registrations for all hosts. See remove().
    */
   void removeAll();
 
   // Testing
-  DOMString getScopeForUrl(in DOMString path);
+  DOMString getScopeForUrl(in nsIPrincipal aPrincipal, in DOMString aPath);
 
   // This is meant to be used only by about:serviceworkers. It returns an array
   // of nsIServiceWorkerInfo.
   nsIArray getAllRegistrations();
 
-  void sendPushEvent(in ACString scope, in DOMString data);
-  void sendPushSubscriptionChangeEvent(in ACString scope);
+  [implicit_jscontext] void sendPushEvent(in jsval aOriginAttributes,
+                                          in ACString aScope,
+                                          in DOMString aData);
+  [implicit_jscontext] void sendPushSubscriptionChangeEvent(in jsval aOriginAttributes,
+                                                            in ACString scope);
 
   void updateAllRegistrations();
 };
 
 %{ C++
 #define SERVICEWORKERMANAGER_CONTRACTID "@mozilla.org/serviceworkers/manager;1"
 %}
diff --git a/dom/push/PushService.jsm b/dom/push/PushService.jsm
--- a/dom/push/PushService.jsm
+++ b/dom/push/PushService.jsm
@@ -1394,17 +1394,23 @@ this.PushService = {
         let globalMM = Cc['@mozilla.org/globalmessagemanager;1'].getService(Ci.nsIMessageListenerManager);
         for (let scope of scopes) {
           // Notify XPCOM observers.
           Services.obs.notifyObservers(
             null,
             "push-subscription-change",
             scope
           );
-          globalMM.broadcastAsyncMessage('pushsubscriptionchanged', scope);
+
+          let data = {
+            originAttributes: null, // TODO
+            scope: scope
+          };
+
+          globalMM.broadcastAsyncMessage('pushsubscriptionchanged', data);
         }
       });
   },
 
   _notifyApp: function(aPushRecord) {
     if (!aPushRecord || !aPushRecord.scope) {
       debug("notifyApp() something is undefined.  Dropping notification: "
         + JSON.stringify(aPushRecord) );
@@ -1432,16 +1438,17 @@ this.PushService = {
     if(Services.perms.testExactPermission(scopeURI, "push") != Ci.nsIPermissionManager.ALLOW_ACTION) {
       debug("Does not have permission for push.")
       return;
     }
 
     // TODO data.
     let data = {
       payload: "Short as life is, we make it still shorter by the careless waste of time.",
+      originAttributes: null,
       scope: aPushRecord.scope
     };
 
     let globalMM = Cc['@mozilla.org/globalmessagemanager;1']
                  .getService(Ci.nsIMessageListenerManager);
     globalMM.broadcastAsyncMessage('push', data);
   },
 
diff --git a/dom/push/PushServiceChildPreload.js b/dom/push/PushServiceChildPreload.js
--- a/dom/push/PushServiceChildPreload.js
+++ b/dom/push/PushServiceChildPreload.js
@@ -5,14 +5,16 @@
 "use strict";
 
 XPCOMUtils.defineLazyServiceGetter(this,
                                    "swm",
                                    "@mozilla.org/serviceworkers/manager;1",
                                    "nsIServiceWorkerManager");
 
 addMessageListener("push", function (aMessage) {
-  swm.sendPushEvent(aMessage.data.scope, aMessage.data.payload);
+  swm.sendPushEvent(aMessage.data.originAttributes,
+                    aMessage.data.scope, aMessage.data.payload);
 });
 
 addMessageListener("pushsubscriptionchange", function (aMessage) {
-  swm.sendPushSubscriptionChangeEvent(aMessage.data);
+  swm.sendPushSubscriptionChangeEvent(aMessage.data.originAttributes,
+                                      aMessage.data.scope);
 });
diff --git a/dom/workers/ServiceWorkerClients.cpp b/dom/workers/ServiceWorkerClients.cpp
--- a/dom/workers/ServiceWorkerClients.cpp
+++ b/dom/workers/ServiceWorkerClients.cpp
@@ -109,17 +109,17 @@ public:
     if (mPromiseProxy->IsClean()) {
       // Don't resolve the promise if it was already released.
       return NS_OK;
     }
 
     nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
     nsTArray<ServiceWorkerClientInfo> result;
 
-    swm->GetAllClients(mScope, result);
+    swm->GetAllClients(mWorkerPrivate->GetPrincipal(), mScope, result);
     nsRefPtr<ResolvePromiseWorkerRunnable> r =
       new ResolvePromiseWorkerRunnable(mWorkerPrivate, mPromiseProxy, result);
 
     AutoSafeJSContext cx;
     if (r->Dispatch(cx)) {
       return NS_OK;
     }
 
@@ -192,27 +192,28 @@ public:
   }
 
   NS_IMETHOD
   Run() override
   {
     nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
     MOZ_ASSERT(swm);
 
-    nsresult rv = swm->ClaimClients(mScope, mServiceWorkerID);
-
     MutexAutoLock lock(mPromiseProxy->GetCleanUpLock());
     if (mPromiseProxy->IsClean()) {
       // Don't resolve the promise if it was already released.
       return NS_OK;
     }
 
     WorkerPrivate* workerPrivate = mPromiseProxy->GetWorkerPrivate();
     MOZ_ASSERT(workerPrivate);
 
+    nsresult rv = swm->ClaimClients(workerPrivate->GetPrincipal(),
+                                    mScope, mServiceWorkerID);
+
     nsRefPtr<ResolveClaimRunnable> r =
       new ResolveClaimRunnable(workerPrivate, mPromiseProxy, rv);
 
     AutoJSAPI jsapi;
     jsapi.Init();
     JSContext* cx = jsapi.cx();
     if (r->Dispatch(cx)) {
       return NS_OK;
diff --git a/dom/workers/ServiceWorkerContainer.cpp b/dom/workers/ServiceWorkerContainer.cpp
--- a/dom/workers/ServiceWorkerContainer.cpp
+++ b/dom/workers/ServiceWorkerContainer.cpp
@@ -220,19 +220,25 @@ ServiceWorkerContainer::GetReady(ErrorRe
 }
 
 // Testing only.
 void
 ServiceWorkerContainer::GetScopeForUrl(const nsAString& aUrl,
                                        nsString& aScope,
                                        ErrorResult& aRv)
 {
+  nsCOMPtr<nsIDocument> doc = GetOwner()->GetExtantDoc();
+  MOZ_ASSERT(doc);
+
+  nsCOMPtr<nsIPrincipal> principal = doc->NodePrincipal();
+  MOZ_ASSERT(principal);
+
   nsCOMPtr<nsIServiceWorkerManager> swm = mozilla::services::GetServiceWorkerManager();
   if (!swm) {
     aRv.Throw(NS_ERROR_FAILURE);
     return;
   }
 
-  aRv = swm->GetScopeForUrl(aUrl, aScope);
+  aRv = swm->GetScopeForUrl(principal, aUrl, aScope);
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -19,16 +19,17 @@
 #include "nsIMutableArray.h"
 #include "nsIUploadChannel2.h"
 #include "nsPIDOMWindow.h"
 #include "nsScriptLoader.h"
 #include "nsDebug.h"
 
 #include "jsapi.h"
 
+#include "mozilla/BasePrincipal.h"
 #include "mozilla/ErrorNames.h"
 #include "mozilla/LoadContext.h"
 #include "mozilla/dom/BindingUtils.h"
 #include "mozilla/dom/ContentParent.h"
 #include "mozilla/dom/DOMError.h"
 #include "mozilla/dom/ErrorEvent.h"
 #include "mozilla/dom/Headers.h"
 #include "mozilla/dom/InternalHeaders.h"
@@ -47,16 +48,17 @@
 #include "nsProxyRelease.h"
 #include "nsQueryObject.h"
 #include "nsTArray.h"
 
 #include "RuntimeService.h"
 #include "ServiceWorker.h"
 #include "ServiceWorkerClient.h"
 #include "ServiceWorkerContainer.h"
+#include "ServiceWorkerRegistrar.h"
 #include "ServiceWorkerRegistration.h"
 #include "ServiceWorkerScriptCache.h"
 #include "ServiceWorkerEvents.h"
 #include "WorkerInlines.h"
 #include "WorkerPrivate.h"
 #include "WorkerRunnable.h"
 #include "WorkerScope.h"
 
@@ -77,26 +79,151 @@ static_assert(nsIHttpChannelInternal::CO
               "RequestMode enumeration value should match Necko CORS mode value.");
 static_assert(nsIHttpChannelInternal::CORS_MODE_NO_CORS == static_cast<uint32_t>(RequestMode::No_cors),
               "RequestMode enumeration value should match Necko CORS mode value.");
 static_assert(nsIHttpChannelInternal::CORS_MODE_CORS == static_cast<uint32_t>(RequestMode::Cors),
               "RequestMode enumeration value should match Necko CORS mode value.");
 static_assert(nsIHttpChannelInternal::CORS_MODE_CORS_WITH_FORCED_PREFLIGHT == static_cast<uint32_t>(RequestMode::Cors_with_forced_preflight),
               "RequestMode enumeration value should match Necko CORS mode value.");
 
+struct ServiceWorkerManager::RegistrationDataPerPrincipal
+{
+  // Ordered list of scopes for glob matching.
+  // Each entry is an absolute URL representing the scope.
+  // Each value of the hash table is an array of an absolute URLs representing
+  // the scopes.
+  //
+  // An array is used for now since the number of controlled scopes per
+  // domain is expected to be relatively low. If that assumption was proved
+  // wrong this should be replaced with a better structure to avoid the
+  // memmoves associated with inserting stuff in the middle of the array.
+  nsTArray<nsCString> mOrderedScopes;
+
+  // Scope to registration.
+  // The scope should be a fully qualified valid URL.
+  nsRefPtrHashtable<nsCStringHashKey, ServiceWorkerRegistrationInfo> mInfos;
+
+  // Maps scopes to job queues.
+  nsClassHashtable<nsCStringHashKey, ServiceWorkerJobQueue> mJobQueues;
+
+  nsDataHashtable<nsCStringHashKey, bool> mSetOfScopesBeingUpdated;
+};
+
 struct ServiceWorkerManager::PendingOperation
 {
   nsCOMPtr<nsIRunnable> mRunnable;
 
   ServiceWorkerJobQueue* mQueue;
   nsRefPtr<ServiceWorkerJob> mJob;
 
   ServiceWorkerRegistrationData mRegistration;
 };
 
+class ServiceWorkerJob : public nsISupports
+{
+protected:
+  // The queue keeps the jobs alive, so they can hold a rawptr back to the
+  // queue.
+  ServiceWorkerJobQueue* mQueue;
+
+public:
+  NS_DECL_ISUPPORTS
+
+  virtual void Start() = 0;
+
+  virtual bool
+  IsRegisterJob() const { return false; }
+
+protected:
+  explicit ServiceWorkerJob(ServiceWorkerJobQueue* aQueue)
+    : mQueue(aQueue)
+  {
+  }
+
+  virtual ~ServiceWorkerJob()
+  { }
+
+  void
+  Done(nsresult aStatus);
+};
+
+class ServiceWorkerJobQueue final
+{
+  friend class ServiceWorkerJob;
+
+  nsTArray<nsRefPtr<ServiceWorkerJob>> mJobs;
+  const nsCString mOriginAttributesSuffix;
+  bool mPopping;
+
+public:
+  explicit ServiceWorkerJobQueue(const nsACString& aOriginAttributesSuffix)
+    : mOriginAttributesSuffix(aOriginAttributesSuffix)
+    , mPopping(false)
+  {}
+
+  ~ServiceWorkerJobQueue()
+  {
+    if (!mJobs.IsEmpty()) {
+      NS_WARNING("Pending/running jobs still around on shutdown!");
+    }
+  }
+
+  void
+  Append(ServiceWorkerJob* aJob)
+  {
+    MOZ_ASSERT(aJob);
+    MOZ_ASSERT(!mJobs.Contains(aJob));
+    bool wasEmpty = mJobs.IsEmpty();
+    mJobs.AppendElement(aJob);
+    if (wasEmpty) {
+      aJob->Start();
+    }
+  }
+
+  void
+  CancelJobs();
+
+  // Only used by HandleError, keep it that way!
+  ServiceWorkerJob*
+  Peek()
+  {
+    if (mJobs.IsEmpty()) {
+      return nullptr;
+    }
+    return mJobs[0];
+  }
+
+private:
+  void
+  Pop()
+  {
+    MOZ_ASSERT(!mPopping,
+               "Pop() called recursively, did you write a job which calls Done() synchronously from Start()?");
+    AutoRestore<bool> savePopping(mPopping);
+    mPopping = true;
+    MOZ_ASSERT(!mJobs.IsEmpty());
+    mJobs.RemoveElementAt(0);
+    if (!mJobs.IsEmpty()) {
+      mJobs[0]->Start();
+    } else {
+      nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+      MOZ_ASSERT(swm);
+      swm->MaybeRemoveRegistrationInfo(mOriginAttributesSuffix);
+    }
+  }
+
+  void
+  Done(ServiceWorkerJob* aJob)
+  {
+    MOZ_ASSERT(!mJobs.IsEmpty());
+    MOZ_ASSERT(mJobs[0] == aJob);
+    Pop();
+  }
+};
+
 namespace {
 
 nsresult
 PopulateRegistrationData(nsIPrincipal* aPrincipal,
                          const ServiceWorkerRegistrationInfo* aRegistration,
                          ServiceWorkerRegistrationData& aData)
 {
   MOZ_ASSERT(aPrincipal);
@@ -254,17 +381,17 @@ ServiceWorkerManager::ServiceWorkerManag
       MOZ_ASSERT(NS_SUCCEEDED(rv));
     }
   }
 }
 
 ServiceWorkerManager::~ServiceWorkerManager()
 {
   // The map will assert if it is not empty when destroyed.
-  mServiceWorkerRegistrationInfos.Clear();
+  mRegistrationInfos.Clear();
 }
 
 class ContinueLifecycleTask : public nsISupports
 {
   NS_DECL_ISUPPORTS
 
 protected:
   virtual ~ContinueLifecycleTask()
@@ -638,17 +765,17 @@ public:
     if (!swm->HasBackgroundActor()) {
       nsCOMPtr<nsIRunnable> runnable =
         NS_NewRunnableMethod(this, &ServiceWorkerRegisterJob::Start);
       swm->AppendPendingOperation(runnable);
       return;
     }
 
     if (mJobType == REGISTER_JOB) {
-      mRegistration = swm->GetRegistration(mScope);
+      mRegistration = swm->GetRegistration(mPrincipal, mScope);
 
       if (mRegistration) {
         nsRefPtr<ServiceWorkerInfo> newest = mRegistration->Newest();
         if (newest && mScriptSpec.Equals(newest->ScriptSpec()) &&
             mScriptSpec.Equals(mRegistration->mScriptSpec)) {
           mRegistration->mPendingUninstall = false;
           swm->StoreRegistration(mPrincipal, mRegistration);
           Succeed();
@@ -725,52 +852,61 @@ public:
     }
 
     if (!StringBeginsWith(mRegistration->mScope, maxPrefix)) {
       NS_WARNING("By default a service worker's scope is restricted to at or below it's script's location.");
       Fail(NS_ERROR_DOM_SECURITY_ERR);
       return;
     }
 
+    nsAutoCString key;
+    rv = swm->PrincipalToScopeKey(mRegistration->mPrincipal, key);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return Fail(NS_ERROR_FAILURE);
+    }
+
+    ServiceWorkerManager::RegistrationDataPerPrincipal* data;
+    if (!swm->mRegistrationInfos.Get(key, &data)) {
+      return Fail(NS_ERROR_FAILURE);
+    }
+
     nsAutoString cacheName;
     // We have to create a ServiceWorker here simply to ensure there are no
     // errors. Ideally we should just pass this worker on to ContinueInstall.
-    MOZ_ASSERT(!swm->mSetOfScopesBeingUpdated.Contains(mRegistration->mScope));
-    swm->mSetOfScopesBeingUpdated.Put(mRegistration->mScope, true);
+    MOZ_ASSERT(!data->mSetOfScopesBeingUpdated.Contains(mRegistration->mScope));
+    data->mSetOfScopesBeingUpdated.Put(mRegistration->mScope, true);
 
     MOZ_ASSERT(!mUpdateAndInstallInfo);
     mUpdateAndInstallInfo =
       new ServiceWorkerInfo(mRegistration, mRegistration->mScriptSpec,
                             aNewCacheName);
     nsRefPtr<ServiceWorker> serviceWorker;
     rv = swm->CreateServiceWorker(mRegistration->mPrincipal,
                                   mUpdateAndInstallInfo,
                                   getter_AddRefs(serviceWorker));
 
     if (NS_WARN_IF(NS_FAILED(rv))) {
-      swm->mSetOfScopesBeingUpdated.Remove(mRegistration->mScope);
-      Fail(NS_ERROR_DOM_ABORT_ERR);
-      return;
+      data->mSetOfScopesBeingUpdated.Remove(mRegistration->mScope);
+      return Fail(NS_ERROR_DOM_ABORT_ERR);
     }
 
     nsRefPtr<ServiceWorkerJob> upcasted = this;
     nsMainThreadPtrHandle<nsISupports> handle(
         new nsMainThreadPtrHolder<nsISupports>(upcasted));
 
     nsMainThreadPtrHandle<ServiceWorker> serviceWorkerHandle(
       new nsMainThreadPtrHolder<ServiceWorker>(serviceWorker));
     nsRefPtr<CheckWorkerEvaluationAndContinueUpdateWorkerRunnable> r =
       new CheckWorkerEvaluationAndContinueUpdateWorkerRunnable(serviceWorkerHandle, handle);
     AutoJSAPI jsapi;
     jsapi.Init();
     bool ok = r->Dispatch(jsapi.cx());
     if (NS_WARN_IF(!ok)) {
-      swm->mSetOfScopesBeingUpdated.Remove(mRegistration->mScope);
-      Fail(NS_ERROR_DOM_ABORT_ERR);
-      return;
+      data->mSetOfScopesBeingUpdated.Remove(mRegistration->mScope);
+      return Fail(NS_ERROR_DOM_ABORT_ERR);
     }
   }
 
   // Public so our error handling code can use it.
   // Callers MUST hold a strong ref before calling this!
   void
   Fail(const ErrorEventInit& aError)
   {
@@ -788,18 +924,30 @@ public:
 
   // Public so our error handling code can continue with a successful worker.
   void
   ContinueInstall()
   {
     // Even if we are canceled, ensure integrity of mSetOfScopesBeingUpdated
     // first.
     nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
-    MOZ_ASSERT(swm->mSetOfScopesBeingUpdated.Contains(mRegistration->mScope));
-    swm->mSetOfScopesBeingUpdated.Remove(mRegistration->mScope);
+
+    nsAutoCString key;
+    nsresult rv = swm->PrincipalToScopeKey(mRegistration->mPrincipal, key);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return Fail(NS_ERROR_FAILURE);
+    }
+
+    ServiceWorkerManager::RegistrationDataPerPrincipal* data;
+    if (!swm->mRegistrationInfos.Get(key, &data)) {
+      return Fail(NS_ERROR_FAILURE);
+    }
+
+    MOZ_ASSERT(data->mSetOfScopesBeingUpdated.Contains(mRegistration->mScope));
+    data->mSetOfScopesBeingUpdated.Remove(mRegistration->mScope);
     // This is effectively the end of Step 4.3 of the [[Update]] algorithm.
     // The invocation of [[Install]] is not part of the atomic block.
 
     nsRefPtr<ServiceWorkerRegisterJob> kungFuDeathGrip = this;
     if (mCanceled) {
       return Fail(NS_ERROR_DOM_ABORT_ERR);
     }
 
@@ -823,19 +971,19 @@ public:
       NS_NewRunnableMethodWithArg<ServiceWorkerRegistrationInfo*>(
         swm,
         &ServiceWorkerManager::FireUpdateFoundOnServiceWorkerRegistrations,
         mRegistration);
 
     NS_DispatchToMainThread(upr);
 
     nsRefPtr<ServiceWorker> serviceWorker;
-    nsresult rv = swm->CreateServiceWorker(mRegistration->mPrincipal,
-                                           mRegistration->mInstallingWorker,
-                                           getter_AddRefs(serviceWorker));
+    rv = swm->CreateServiceWorker(mRegistration->mPrincipal,
+                                  mRegistration->mInstallingWorker,
+                                  getter_AddRefs(serviceWorker));
 
     if (NS_WARN_IF(NS_FAILED(rv))) {
       ContinueAfterInstallEvent(false /* aSuccess */, false /* aActivateImmediately */);
       return;
     }
 
     nsMainThreadPtrHandle<ContinueLifecycleTask> handle(
         new nsMainThreadPtrHolder<ContinueLifecycleTask>(new ContinueInstallTask(this)));
@@ -1147,17 +1295,23 @@ ServiceWorkerManager::Register(nsIDOMWin
 
   nsCOMPtr<nsIGlobalObject> sgo = do_QueryInterface(window);
   ErrorResult result;
   nsRefPtr<Promise> promise = Promise::Create(sgo, result);
   if (result.Failed()) {
     return result.StealNSResult();
   }
 
-  ServiceWorkerJobQueue* queue = GetOrCreateJobQueue(cleanedScope);
+  nsAutoCString originSuffix;
+  rv = PrincipalToScopeKey(documentPrincipal, originSuffix);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+
+  ServiceWorkerJobQueue* queue = GetOrCreateJobQueue(originSuffix, cleanedScope);
   MOZ_ASSERT(queue);
 
   nsRefPtr<ServiceWorkerResolveWindowPromiseOnUpdateCallback> cb =
     new ServiceWorkerResolveWindowPromiseOnUpdateCallback(window, promise);
 
   nsRefPtr<ServiceWorkerRegisterJob> job =
     new ServiceWorkerRegisterJob(queue, cleanedScope, spec, cb, documentPrincipal);
   queue->Append(job);
@@ -1433,18 +1587,30 @@ public:
       return rv;
     }
 
     if (nsContentUtils::IsSystemPrincipal(principal) || isNullPrincipal) {
       mPromise->MaybeResolve(array);
       return NS_OK;
     }
 
-    for (uint32_t i = 0; i < swm->mOrderedScopes.Length(); ++i) {
-      NS_ConvertUTF8toUTF16 scope(swm->mOrderedScopes[i]);
+    nsAutoCString key;
+    rv = swm->PrincipalToScopeKey(principal, key);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+
+    ServiceWorkerManager::RegistrationDataPerPrincipal* data;
+    if (!swm->mRegistrationInfos.Get(key, &data)) {
+      mPromise->MaybeResolve(array);
+      return NS_OK;
+    }
+
+    for (uint32_t i = 0; i < data->mOrderedScopes.Length(); ++i) {
+      NS_ConvertUTF8toUTF16 scope(data->mOrderedScopes[i]);
 
       nsCOMPtr<nsIURI> scopeURI;
       nsresult rv = NS_NewURI(getter_AddRefs(scopeURI), scope, nullptr, nullptr);
       if (NS_WARN_IF(NS_FAILED(rv))) {
         mPromise->MaybeReject(rv);
         break;
       }
 
@@ -1544,17 +1710,17 @@ public:
     rv = principal->CheckMayLoad(uri, true /* report */,
                                  false /* allowIfInheritsPrinciple */);
     if (NS_FAILED(rv)) {
       mPromise->MaybeReject(NS_ERROR_DOM_SECURITY_ERR);
       return NS_OK;
     }
 
     nsRefPtr<ServiceWorkerRegistrationInfo> registration =
-      swm->GetServiceWorkerRegistrationInfo(uri);
+      swm->GetServiceWorkerRegistrationInfo(principal, uri);
 
     if (!registration) {
       mPromise->MaybeResolve(JS::UndefinedHandleValue);
       return NS_OK;
     }
 
     NS_ConvertUTF8toUTF16 scope(registration->mScope);
     nsRefPtr<ServiceWorkerRegistrationMainThread> swr =
@@ -1720,66 +1886,81 @@ public:
     globalScope->DispatchDOMEvent(nullptr, event, nullptr, nullptr);
     return true;
   }
 };
 
 #endif /* ! MOZ_SIMPLEPUSH */
 
 NS_IMETHODIMP
-ServiceWorkerManager::SendPushEvent(const nsACString& aScope, const nsAString& aData)
+ServiceWorkerManager::SendPushEvent(JS::Handle<JS::Value> aOriginAttributes,
+                                    const nsACString& aScope,
+                                    const nsAString& aData,
+                                    JSContext* aCx)
 {
 #ifdef MOZ_SIMPLEPUSH
   return NS_ERROR_NOT_AVAILABLE;
-#else
-  nsRefPtr<ServiceWorker> serviceWorker = CreateServiceWorkerForScope(aScope);
+#endif
+
+  OriginAttributes attrs;
+  if (!aOriginAttributes.isObject() || !attrs.Init(aCx, aOriginAttributes)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  nsRefPtr<ServiceWorker> serviceWorker =
+    CreateServiceWorkerForScope(attrs, aScope);
   if (!serviceWorker) {
     return NS_ERROR_FAILURE;
   }
 
   nsMainThreadPtrHandle<ServiceWorker> serviceWorkerHandle(
     new nsMainThreadPtrHolder<ServiceWorker>(serviceWorker));
 
   nsRefPtr<SendPushEventRunnable> r =
-    new SendPushEventRunnable(serviceWorker->GetWorkerPrivate(), aData, serviceWorkerHandle);
-
-  AutoJSAPI jsapi;
-  jsapi.Init();
-  if (NS_WARN_IF(!r->Dispatch(jsapi.cx()))) {
+    new SendPushEventRunnable(serviceWorker->GetWorkerPrivate(), aData,
+                              serviceWorkerHandle);
+
+  if (NS_WARN_IF(!r->Dispatch(aCx))) {
     return NS_ERROR_FAILURE;
   }
 
   return NS_OK;
-#endif
 }
 
 NS_IMETHODIMP
-ServiceWorkerManager::SendPushSubscriptionChangeEvent(const nsACString& aScope)
+ServiceWorkerManager::SendPushSubscriptionChangeEvent(JS::Handle<JS::Value> aOriginAttributes,
+                                                      const nsACString& aScope,
+                                                      JSContext* aCx)
 {
 #ifdef MOZ_SIMPLEPUSH
   return NS_ERROR_NOT_AVAILABLE;
-#else
-  nsRefPtr<ServiceWorker> serviceWorker = CreateServiceWorkerForScope(aScope);
+#endif
+
+  OriginAttributes attrs;
+  if (!aOriginAttributes.isObject() || !attrs.Init(aCx, aOriginAttributes)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  nsRefPtr<ServiceWorker> serviceWorker =
+    CreateServiceWorkerForScope(attrs, aScope);
   if (!serviceWorker) {
     return NS_ERROR_FAILURE;
   }
   nsMainThreadPtrHandle<ServiceWorker> serviceWorkerHandle(
     new nsMainThreadPtrHolder<ServiceWorker>(serviceWorker));
 
   nsRefPtr<SendPushSubscriptionChangeEventRunnable> r =
-    new SendPushSubscriptionChangeEventRunnable(serviceWorker->GetWorkerPrivate(), serviceWorkerHandle);
-
-  AutoJSAPI jsapi;
-  jsapi.Init();
-  if (NS_WARN_IF(!r->Dispatch(jsapi.cx()))) {
+    new SendPushSubscriptionChangeEventRunnable(
+      serviceWorker->GetWorkerPrivate(), serviceWorkerHandle);
+
+  if (NS_WARN_IF(!r->Dispatch(aCx))) {
     return NS_ERROR_FAILURE;
   }
 
   return NS_OK;
-#endif
 }
 
 NS_IMETHODIMP
 ServiceWorkerManager::GetReadyPromise(nsIDOMWindow* aWindow,
                                       nsISupports** aPromise)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aWindow);
@@ -1859,41 +2040,52 @@ ServiceWorkerManager::CheckPendingReadyP
 
   return PL_DHASH_NEXT;
 }
 
 bool
 ServiceWorkerManager::CheckReadyPromise(nsPIDOMWindow* aWindow,
                                         nsIURI* aURI, Promise* aPromise)
 {
+  MOZ_ASSERT(aWindow);
+  MOZ_ASSERT(aURI);
+
+  nsCOMPtr<nsIDocument> doc = aWindow->GetExtantDoc();
+  MOZ_ASSERT(doc);
+
+  nsCOMPtr<nsIPrincipal> principal = doc->NodePrincipal();
+  MOZ_ASSERT(principal);
+
   nsRefPtr<ServiceWorkerRegistrationInfo> registration =
-    GetServiceWorkerRegistrationInfo(aURI);
+    GetServiceWorkerRegistrationInfo(principal, aURI);
 
   if (registration && registration->mActiveWorker) {
     NS_ConvertUTF8toUTF16 scope(registration->mScope);
     nsRefPtr<ServiceWorkerRegistrationMainThread> swr =
       new ServiceWorkerRegistrationMainThread(aWindow, scope);
     aPromise->MaybeResolve(swr);
     return true;
   }
 
   return false;
 }
 
 already_AddRefed<ServiceWorker>
-ServiceWorkerManager::CreateServiceWorkerForScope(const nsACString& aScope)
+ServiceWorkerManager::CreateServiceWorkerForScope(const OriginAttributes& aOriginAttributes,
+                                                  const nsACString& aScope)
 {
   AssertIsOnMainThread();
 
   nsCOMPtr<nsIURI> scopeURI;
   nsresult rv = NS_NewURI(getter_AddRefs(scopeURI), aScope, nullptr, nullptr);
   if (NS_FAILED(rv)) {
     return nullptr;
   }
-  nsRefPtr<ServiceWorkerRegistrationInfo> registration = GetServiceWorkerRegistrationInfo(scopeURI);
+  nsRefPtr<ServiceWorkerRegistrationInfo> registration =
+    GetServiceWorkerRegistrationInfo(aOriginAttributes, scopeURI);
   if (!registration) {
     return nullptr;
   }
 
   if (!registration->mActiveWorker) {
     return nullptr;
   }
 
@@ -1909,30 +2101,30 @@ ServiceWorkerManager::CreateServiceWorke
   return sw.forget();
 }
 
 class ServiceWorkerUnregisterJob final : public ServiceWorkerJob
 {
   nsRefPtr<ServiceWorkerRegistrationInfo> mRegistration;
   const nsCString mScope;
   nsCOMPtr<nsIServiceWorkerUnregisterCallback> mCallback;
-  PrincipalInfo mPrincipalInfo;
+  nsCOMPtr<nsIPrincipal> mPrincipal;
 
   ~ServiceWorkerUnregisterJob()
   { }
 
 public:
   ServiceWorkerUnregisterJob(ServiceWorkerJobQueue* aQueue,
                              const nsACString& aScope,
                              nsIServiceWorkerUnregisterCallback* aCallback,
-                             PrincipalInfo& aPrincipalInfo)
+                             nsIPrincipal* aPrincipal)
     : ServiceWorkerJob(aQueue)
     , mScope(aScope)
     , mCallback(aCallback)
-    , mPrincipalInfo(aPrincipalInfo)
+    , mPrincipal(aPrincipal)
   {
     AssertIsOnMainThread();
   }
 
   void
   Start() override
   {
     AssertIsOnMainThread();
@@ -1943,32 +2135,50 @@ public:
 
 private:
   // You probably want UnregisterAndDone().
   nsresult
   Unregister()
   {
     AssertIsOnMainThread();
 
+    PrincipalInfo principalInfo;
+    if (NS_WARN_IF(NS_FAILED(PrincipalToPrincipalInfo(mPrincipal,
+                                                      &principalInfo)))) {
+      return mCallback ? mCallback->UnregisterSucceeded(false) : NS_OK;
+    }
+
     nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
 
+    nsAutoCString key;
+    nsresult rv = swm->PrincipalToScopeKey(mPrincipal, key);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return mCallback ? mCallback->UnregisterSucceeded(false) : NS_OK;
+    }
+
     // "Let registration be the result of running [[Get Registration]]
     // algorithm passing scope as the argument."
-    nsRefPtr<ServiceWorkerRegistrationInfo> registration;
-    if (!swm->mServiceWorkerRegistrationInfos.Get(mScope, getter_AddRefs(registration))) {
+    ServiceWorkerManager::RegistrationDataPerPrincipal* data;
+    if (!swm->mRegistrationInfos.Get(key, &data)) {
       // "If registration is null, then, resolve promise with false."
       return mCallback ? mCallback->UnregisterSucceeded(false) : NS_OK;
     }
 
+    nsRefPtr<ServiceWorkerRegistrationInfo> registration;
+    if (!data->mInfos.Get(mScope, getter_AddRefs(registration))) {
+      // "If registration is null, then, resolve promise with false."
+      return mCallback ? mCallback->UnregisterSucceeded(false) : NS_OK;
+    }
+
     MOZ_ASSERT(registration);
 
     // "Set registration's uninstalling flag."
     registration->mPendingUninstall = true;
     // "Resolve promise with true"
-    nsresult rv = mCallback ? mCallback->UnregisterSucceeded(true) : NS_OK;
+    rv = mCallback ? mCallback->UnregisterSucceeded(true) : NS_OK;
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return rv;
     }
 
     // "If no service worker client is using registration..."
     if (!registration->IsControllingDocuments()) {
       // "If registration's uninstalling flag is set.."
       if (!registration->mPendingUninstall) {
@@ -1976,17 +2186,17 @@ private:
       }
 
       // "Invoke [[Clear Registration]]..."
       registration->Clear();
       swm->RemoveRegistration(registration);
     }
 
     MOZ_ASSERT(swm->mActor);
-    swm->mActor->SendUnregisterServiceWorker(mPrincipalInfo,
+    swm->mActor->SendUnregisterServiceWorker(principalInfo,
                                              NS_ConvertUTF8toUTF16(mScope));
 
     return NS_OK;
   }
 
   // The unregister job is done irrespective of success or failure of any sort.
   void
   UnregisterAndDone()
@@ -2013,72 +2223,104 @@ ServiceWorkerManager::Unregister(nsIPrin
 #ifdef DEBUG
   nsCOMPtr<nsIURI> scopeURI;
   nsresult rv = NS_NewURI(getter_AddRefs(scopeURI), aScope, nullptr, nullptr);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return NS_ERROR_DOM_SECURITY_ERR;
   }
 #endif
 
+  nsAutoCString originSuffix;
+  rv = PrincipalToScopeKey(aPrincipal, originSuffix);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+
   NS_ConvertUTF16toUTF8 scope(aScope);
-  ServiceWorkerJobQueue* queue = GetOrCreateJobQueue(scope);
+  ServiceWorkerJobQueue* queue = GetOrCreateJobQueue(originSuffix, scope);
   MOZ_ASSERT(queue);
 
-  PrincipalInfo principalInfo;
-  if (NS_WARN_IF(NS_FAILED(PrincipalToPrincipalInfo(aPrincipal,
-                                                    &principalInfo)))) {
-    return NS_ERROR_DOM_SECURITY_ERR;
-  }
-
   nsRefPtr<ServiceWorkerUnregisterJob> job =
-    new ServiceWorkerUnregisterJob(queue, scope, aCallback, principalInfo);
+    new ServiceWorkerUnregisterJob(queue, scope, aCallback, aPrincipal);
 
   if (mActor) {
     queue->Append(job);
     return NS_OK;
   }
 
   AppendPendingOperation(queue, job);
   return NS_OK;
 }
 
+ServiceWorkerJobQueue*
+ServiceWorkerManager::GetOrCreateJobQueue(const nsACString& aKey,
+                                          const nsACString& aScope)
+{
+  ServiceWorkerManager::RegistrationDataPerPrincipal* data;
+  if (!mRegistrationInfos.Get(aKey, &data)) {
+    data = new RegistrationDataPerPrincipal();
+    mRegistrationInfos.Put(aKey, data);
+  }
+
+  ServiceWorkerJobQueue* queue;
+  if (!data->mJobQueues.Get(aScope, &queue)) {
+    queue = new ServiceWorkerJobQueue(aKey);
+    data->mJobQueues.Put(aScope, queue);
+  }
+
+  return queue;
+}
+
 /* static */
 already_AddRefed<ServiceWorkerManager>
 ServiceWorkerManager::GetInstance()
 {
   nsCOMPtr<nsIServiceWorkerManager> swm = mozilla::services::GetServiceWorkerManager();
   nsRefPtr<ServiceWorkerManager> concrete = do_QueryObject(swm);
   return concrete.forget();
 }
 
 void
 ServiceWorkerManager::FinishFetch(ServiceWorkerRegistrationInfo* aRegistration)
 {
 }
 
 bool
 ServiceWorkerManager::HandleError(JSContext* aCx,
+                                  nsIPrincipal* aPrincipal,
                                   const nsCString& aScope,
                                   const nsString& aWorkerURL,
                                   nsString aMessage,
                                   nsString aFilename,
                                   nsString aLine,
                                   uint32_t aLineNumber,
                                   uint32_t aColumnNumber,
                                   uint32_t aFlags)
 {
   AssertIsOnMainThread();
-
-  if (!mSetOfScopesBeingUpdated.Contains(aScope)) {
+  MOZ_ASSERT(aPrincipal);
+
+  nsAutoCString key;
+  nsresult rv = PrincipalToScopeKey(aPrincipal, key);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
     return false;
   }
 
-  mSetOfScopesBeingUpdated.Remove(aScope);
-
-  ServiceWorkerJobQueue* queue = mJobQueues.Get(aScope);
+  ServiceWorkerManager::RegistrationDataPerPrincipal* data;
+  if (!mRegistrationInfos.Get(key, &data)) {
+    return false;
+  }
+
+  if (!data->mSetOfScopesBeingUpdated.Contains(aScope)) {
+    return false;
+  }
+
+  data->mSetOfScopesBeingUpdated.Remove(aScope);
+
+  ServiceWorkerJobQueue* queue = data->mJobQueues.Get(aScope);
   MOZ_ASSERT(queue);
   ServiceWorkerJob* job = queue->Peek();
   if (job) {
     MOZ_ASSERT(job->IsRegisterJob());
     nsRefPtr<ServiceWorkerRegisterJob> regJob = static_cast<ServiceWorkerRegisterJob*>(job);
 
     RootedDictionary<ErrorEventInit> init(aCx);
     init.mMessage = aMessage;
@@ -2242,95 +2484,246 @@ ServiceWorkerManager::StoreRegistration(
   }
 
   mActor->SendRegisterServiceWorker(data);
 }
 
 already_AddRefed<ServiceWorkerRegistrationInfo>
 ServiceWorkerManager::GetServiceWorkerRegistrationInfo(nsPIDOMWindow* aWindow)
 {
+  MOZ_ASSERT(aWindow);
   nsCOMPtr<nsIDocument> document = aWindow->GetExtantDoc();
   return GetServiceWorkerRegistrationInfo(document);
 }
 
 already_AddRefed<ServiceWorkerRegistrationInfo>
 ServiceWorkerManager::GetServiceWorkerRegistrationInfo(nsIDocument* aDoc)
 {
+  MOZ_ASSERT(aDoc);
   nsCOMPtr<nsIURI> documentURI = aDoc->GetDocumentURI();
-  return GetServiceWorkerRegistrationInfo(documentURI);
+  nsCOMPtr<nsIPrincipal> principal = aDoc->NodePrincipal();
+  return GetServiceWorkerRegistrationInfo(principal, documentURI);
 }
 
 already_AddRefed<ServiceWorkerRegistrationInfo>
-ServiceWorkerManager::GetServiceWorkerRegistrationInfo(nsIURI* aURI)
+ServiceWorkerManager::GetServiceWorkerRegistrationInfo(nsIPrincipal* aPrincipal,
+                                                       nsIURI* aURI)
 {
-  nsCString spec;
+  MOZ_ASSERT(aPrincipal);
+  MOZ_ASSERT(aURI);
+
+  nsAutoCString originAttributesSuffix;
+  nsresult rv = PrincipalToScopeKey(aPrincipal, originAttributesSuffix);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return nullptr;
+  }
+
+  return GetServiceWorkerRegistrationInfo(originAttributesSuffix, aURI);
+}
+
+already_AddRefed<ServiceWorkerRegistrationInfo>
+ServiceWorkerManager::GetServiceWorkerRegistrationInfo(const OriginAttributes& aOriginAttributes,
+                                                       nsIURI* aURI)
+{
+  MOZ_ASSERT(aURI);
+
+  nsAutoCString originAttributesSuffix;
+  aOriginAttributes.CreateSuffix(originAttributesSuffix);
+  return GetServiceWorkerRegistrationInfo(originAttributesSuffix, aURI);
+}
+
+already_AddRefed<ServiceWorkerRegistrationInfo>
+ServiceWorkerManager::GetServiceWorkerRegistrationInfo(const nsACString& aOriginAttributesSuffix,
+                                                       nsIURI* aURI)
+{
+  MOZ_ASSERT(aURI);
+
+  nsAutoCString spec;
   nsresult rv = aURI->GetSpec(spec);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return nullptr;
   }
 
-  nsCString scope = FindScopeForPath(mOrderedScopes, spec);
-  if (scope.IsEmpty()) {
+  nsAutoCString scope;
+  RegistrationDataPerPrincipal* data;
+  if (!FindScopeForPath(aOriginAttributesSuffix, spec, &data, scope)) {
     return nullptr;
   }
 
+  MOZ_ASSERT(data);
+
   nsRefPtr<ServiceWorkerRegistrationInfo> registration;
-  mServiceWorkerRegistrationInfos.Get(scope, getter_AddRefs(registration));
+  data->mInfos.Get(scope, getter_AddRefs(registration));
   // ordered scopes and registrations better be in sync.
   MOZ_ASSERT(registration);
 
   if (registration->mPendingUninstall) {
     return nullptr;
   }
   return registration.forget();
 }
 
+/* static */ nsresult
+ServiceWorkerManager::PrincipalToScopeKey(nsIPrincipal* aPrincipal,
+                                          nsACString& aKey)
+{
+  MOZ_ASSERT(aPrincipal);
+
+  // No system principal for now.
+  if (nsContentUtils::IsSystemPrincipal(aPrincipal)) {
+    return NS_ERROR_FAILURE;
+  }
+
+  bool isNullPrincipal = true;
+  nsresult rv = aPrincipal->GetIsNullPrincipal(&isNullPrincipal);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+
+  // No null principals.
+  if (isNullPrincipal) {
+    return NS_ERROR_FAILURE;
+  }
+
+  rv = aPrincipal->GetOriginSuffix(aKey);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+
+  return NS_OK;
+}
+
 /* static */ void
-ServiceWorkerManager::AddScope(nsTArray<nsCString>& aList, const nsACString& aScope)
+ServiceWorkerManager::AddScopeAndRegistration(const nsACString& aScope,
+                                              ServiceWorkerRegistrationInfo* aInfo)
 {
-  for (uint32_t i = 0; i < aList.Length(); ++i) {
-    const nsCString& current = aList[i];
+  MOZ_ASSERT(aInfo);
+  MOZ_ASSERT(aInfo->mPrincipal);
+
+  nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  MOZ_ASSERT(swm);
+
+  nsAutoCString key;
+  nsresult rv = swm->PrincipalToScopeKey(aInfo->mPrincipal, key);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return;
+  }
+
+  RegistrationDataPerPrincipal* data;
+  if (!swm->mRegistrationInfos.Get(key, &data)) {
+    data = new RegistrationDataPerPrincipal();
+    swm->mRegistrationInfos.Put(key, data);
+  }
+
+  for (uint32_t i = 0; i < data->mOrderedScopes.Length(); ++i) {
+    const nsCString& current = data->mOrderedScopes[i];
 
     // Perfect match!
     if (aScope.Equals(current)) {
+      data->mInfos.Put(aScope, aInfo);
       return;
     }
 
     // Sort by length, with longest match first.
     // /foo/bar should be before /foo/
     // Similarly /foo/b is between the two.
     if (StringBeginsWith(aScope, current)) {
-      aList.InsertElementAt(i, aScope);
+      data->mOrderedScopes.InsertElementAt(i, aScope);
+      data->mInfos.Put(aScope, aInfo);
       return;
     }
   }
 
-  aList.AppendElement(aScope);
+  data->mOrderedScopes.AppendElement(aScope);
+  data->mInfos.Put(aScope, aInfo);
 }
 
-/* static */ nsCString
-ServiceWorkerManager::FindScopeForPath(nsTArray<nsCString>& aList, const nsACString& aPath)
+/* static */ bool
+ServiceWorkerManager::FindScopeForPath(const nsACString& aOriginAttributesSuffix,
+                                       const nsACString& aPath,
+                                       RegistrationDataPerPrincipal** aData,
+                                       nsACString& aMatch)
 {
-  nsCString match;
-
-  for (uint32_t i = 0; i < aList.Length(); ++i) {
-    const nsCString& current = aList[i];
+  MOZ_ASSERT(aData);
+
+  nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  MOZ_ASSERT(swm);
+
+  if (!swm->mRegistrationInfos.Get(aOriginAttributesSuffix, aData)) {
+    return false;
+  }
+
+  for (uint32_t i = 0; i < (*aData)->mOrderedScopes.Length(); ++i) {
+    const nsCString& current = (*aData)->mOrderedScopes[i];
     if (StringBeginsWith(aPath, current)) {
-      match = current;
-      break;
+      aMatch = current;
+      return true;
     }
   }
 
-  return match;
+  return false;
 }
 
+#ifdef DEBUG
+/* static */ bool
+ServiceWorkerManager::HasScope(nsIPrincipal* aPrincipal,
+                               const nsACString& aScope)
+{
+  nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  MOZ_ASSERT(swm);
+
+  nsAutoCString key;
+  nsresult rv = PrincipalToScopeKey(aPrincipal, key);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return false;
+  }
+
+  RegistrationDataPerPrincipal* data;
+  if (!swm->mRegistrationInfos.Get(key, &data)) {
+    return false;
+  }
+
+  return data->mOrderedScopes.Contains(aScope);
+}
+#endif
+
 /* static */ void
-ServiceWorkerManager::RemoveScope(nsTArray<nsCString>& aList, const nsACString& aScope)
+ServiceWorkerManager::RemoveScopeAndRegistration(ServiceWorkerRegistrationInfo* aRegistration)
 {
-  aList.RemoveElement(aScope);
+  nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  MOZ_ASSERT(swm);
+
+  nsAutoCString key;
+  nsresult rv = swm->PrincipalToScopeKey(aRegistration->mPrincipal, key);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return;
+  }
+
+  RegistrationDataPerPrincipal* data;
+  if (!swm->mRegistrationInfos.Get(key, &data)) {
+    return;
+  }
+
+  data->mInfos.Remove(aRegistration->mScope);
+  data->mOrderedScopes.RemoveElement(aRegistration->mScope);
+
+  swm->MaybeRemoveRegistrationInfo(key);
+}
+
+void
+ServiceWorkerManager::MaybeRemoveRegistrationInfo(const nsACString& aOriginAttributesSuffix)
+{
+  RegistrationDataPerPrincipal* data;
+  if (!mRegistrationInfos.Get(aOriginAttributesSuffix, &data)) {
+    return;
+  }
+
+  if (data->mOrderedScopes.IsEmpty() && data->mJobQueues.Count() == 0) {
+    mRegistrationInfos.Remove(aOriginAttributesSuffix);
+  }
 }
 
 void
 ServiceWorkerManager::MaybeStartControlling(nsIDocument* aDoc)
 {
   AssertIsOnMainThread();
 
   // We keep a set of documents that service workers may choose to start
@@ -2385,25 +2778,29 @@ ServiceWorkerManager::StopControllingADo
       RemoveRegistration(aRegistration);
     } else {
       aRegistration->TryToActivate();
     }
   }
 }
 
 NS_IMETHODIMP
-ServiceWorkerManager::GetScopeForUrl(const nsAString& aUrl, nsAString& aScope)
+ServiceWorkerManager::GetScopeForUrl(nsIPrincipal* aPrincipal,
+                                     const nsAString& aUrl, nsAString& aScope)
 {
+  MOZ_ASSERT(aPrincipal);
+
   nsCOMPtr<nsIURI> uri;
   nsresult rv = NS_NewURI(getter_AddRefs(uri), aUrl, nullptr, nullptr);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return NS_ERROR_FAILURE;
   }
 
-  nsRefPtr<ServiceWorkerRegistrationInfo> r = GetServiceWorkerRegistrationInfo(uri);
+  nsRefPtr<ServiceWorkerRegistrationInfo> r =
+    GetServiceWorkerRegistrationInfo(aPrincipal, uri);
   if (!r) {
       return NS_ERROR_FAILURE;
   }
 
   aScope = NS_ConvertUTF8toUTF16(r->mScope);
   return NS_OK;
 }
 
@@ -2498,17 +2895,18 @@ ServiceWorkerManager::GetServiceWorkerFo
   nsCOMPtr<nsIPrincipal> documentPrincipal = doc->NodePrincipal();
   rv = documentPrincipal->CheckMayLoad(scopeURI, true /* report */,
                                        false /* allowIfInheritsPrinciple */);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return NS_ERROR_DOM_SECURITY_ERR;
   }
   ////////////////////////////////////////////
 
-  nsRefPtr<ServiceWorkerRegistrationInfo> registration = GetRegistration(scope);
+  nsRefPtr<ServiceWorkerRegistrationInfo> registration =
+    GetRegistration(documentPrincipal, scope);
   if (NS_WARN_IF(!registration)) {
     return NS_ERROR_FAILURE;
   }
 
   nsRefPtr<ServiceWorkerInfo> info;
   if (aWhichWorker == WhichServiceWorker::INSTALLING_WORKER) {
     info = registration->mInstallingWorker;
   } else if (aWhichWorker == WhichServiceWorker::WAITING_WORKER) {
@@ -2759,108 +3157,122 @@ private:
       MOZ_ALWAYS_TRUE(NS_SUCCEEDED(NS_DispatchToMainThread(runnable)));
     }
     return true;
   }
 };
 
 NS_IMPL_ISUPPORTS_INHERITED(FetchEventRunnable, WorkerRunnable, nsIHttpHeaderVisitor)
 
-NS_IMETHODIMP
-ServiceWorkerManager::DispatchFetchEvent(nsIDocument* aDoc, nsIInterceptedChannel* aChannel,
-                                         bool aIsReload)
+void
+ServiceWorkerManager::DispatchFetchEvent(const OriginAttributes& aOriginAttributes,
+                                         nsIDocument* aDoc,
+                                         nsIInterceptedChannel* aChannel,
+                                         bool aIsReload,
+                                         ErrorResult& aRv)
 {
   MOZ_ASSERT(aChannel);
   nsCOMPtr<nsISupports> serviceWorker;
 
   bool isNavigation = false;
-  nsresult rv = aChannel->GetIsNavigation(&isNavigation);
-  NS_ENSURE_SUCCESS(rv, rv);
+  aRv = aChannel->GetIsNavigation(&isNavigation);
+  if (NS_WARN_IF(aRv.Failed())) {
+    return;
+  }
 
   nsAutoPtr<ServiceWorkerClientInfo> clientInfo;
 
   if (!isNavigation) {
     MOZ_ASSERT(aDoc);
-    rv = GetDocumentController(aDoc->GetInnerWindow(), getter_AddRefs(serviceWorker));
+    aRv = GetDocumentController(aDoc->GetInnerWindow(), getter_AddRefs(serviceWorker));
     clientInfo = new ServiceWorkerClientInfo(aDoc);
   } else {
     nsCOMPtr<nsIChannel> internalChannel;
-    rv = aChannel->GetChannel(getter_AddRefs(internalChannel));
-    NS_ENSURE_SUCCESS(rv, rv);
+    aRv = aChannel->GetChannel(getter_AddRefs(internalChannel));
+    if (NS_WARN_IF(aRv.Failed())) {
+      return;
+    }
 
     nsCOMPtr<nsIURI> uri;
-    rv = internalChannel->GetURI(getter_AddRefs(uri));
-    NS_ENSURE_SUCCESS(rv, rv);
+    aRv = internalChannel->GetURI(getter_AddRefs(uri));
+    if (NS_WARN_IF(aRv.Failed())) {
+      return;
+    }
 
     nsRefPtr<ServiceWorkerRegistrationInfo> registration =
-      GetServiceWorkerRegistrationInfo(uri);
+      GetServiceWorkerRegistrationInfo(aOriginAttributes, uri);
     if (!registration) {
       NS_WARNING("No registration found when dispatching the fetch event");
-      return NS_ERROR_FAILURE;
+      aRv.Throw(NS_ERROR_FAILURE);
+      return;
     }
+
     // This should only happen if IsAvailableForURI() returned true.
     MOZ_ASSERT(registration->mActiveWorker);
 
     nsRefPtr<ServiceWorker> sw;
-    rv = CreateServiceWorker(registration->mPrincipal,
-                             registration->mActiveWorker,
-                             getter_AddRefs(sw));
+    aRv = CreateServiceWorker(registration->mPrincipal,
+                              registration->mActiveWorker,
+                              getter_AddRefs(sw));
     serviceWorker = sw.forget();
   }
 
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
+  if (NS_WARN_IF(aRv.Failed())) {
+    return;
   }
 
   nsMainThreadPtrHandle<nsIInterceptedChannel> handle(
     new nsMainThreadPtrHolder<nsIInterceptedChannel>(aChannel, false));
 
   nsRefPtr<ServiceWorker> sw = static_cast<ServiceWorker*>(serviceWorker.get());
   nsMainThreadPtrHandle<ServiceWorker> serviceWorkerHandle(
     new nsMainThreadPtrHolder<ServiceWorker>(sw));
 
   // clientInfo is null if we don't have a controlled document
   nsRefPtr<FetchEventRunnable> event =
-    new FetchEventRunnable(sw->GetWorkerPrivate(), handle, serviceWorkerHandle, clientInfo, aIsReload);
-  rv = event->Init();
-  NS_ENSURE_SUCCESS(rv, rv);
+    new FetchEventRunnable(sw->GetWorkerPrivate(), handle, serviceWorkerHandle,
+                           clientInfo, aIsReload);
+  aRv = event->Init();
+  if (NS_WARN_IF(aRv.Failed())) {
+    return;
+  }
 
   AutoJSAPI api;
   api.Init();
   if (NS_WARN_IF(!event->Dispatch(api.cx()))) {
-    return NS_ERROR_FAILURE;
+    aRv.Throw(NS_ERROR_FAILURE);
+    return;
   }
-
-  return NS_OK;
 }
 
-NS_IMETHODIMP
-ServiceWorkerManager::IsAvailableForURI(nsIURI* aURI, bool* aIsAvailable)
+bool
+ServiceWorkerManager::IsAvailableForURI(const OriginAttributes& aOriginAttributes,
+                                        nsIURI* aURI)
 {
   MOZ_ASSERT(aURI);
-  MOZ_ASSERT(aIsAvailable);
+
   nsRefPtr<ServiceWorkerRegistrationInfo> registration =
-    GetServiceWorkerRegistrationInfo(aURI);
-  *aIsAvailable = registration && registration->mActiveWorker;
-  return NS_OK;
+    GetServiceWorkerRegistrationInfo(aOriginAttributes, aURI);
+  return registration && registration->mActiveWorker;
 }
 
-NS_IMETHODIMP
-ServiceWorkerManager::IsControlled(nsIDocument* aDoc, bool* aIsControlled)
+bool
+ServiceWorkerManager::IsControlled(nsIDocument* aDoc, ErrorResult& aRv)
 {
   MOZ_ASSERT(aDoc);
-  MOZ_ASSERT(aIsControlled);
+
   nsRefPtr<ServiceWorkerRegistrationInfo> registration;
   nsresult rv = GetDocumentRegistration(aDoc, getter_AddRefs(registration));
   if (NS_WARN_IF(NS_FAILED(rv) && rv != NS_ERROR_NOT_AVAILABLE)) {
     // It's OK to ignore the case where we don't have a registration.
-    return rv;
+    aRv.Throw(rv);
+    return false;
   }
-  *aIsControlled = !!registration;
-  return NS_OK;
+
+  return !!registration;
 }
 
 nsresult
 ServiceWorkerManager::GetDocumentRegistration(nsIDocument* aDoc,
                                               ServiceWorkerRegistrationInfo** aRegistrationInfo)
 {
   nsRefPtr<ServiceWorkerRegistrationInfo> registration;
   if (!mControlledDocuments.Get(aDoc, getter_AddRefs(registration))) {
@@ -3014,60 +3426,91 @@ ServiceWorkerManager::InvalidateServiceW
 
     if (utf8Scope.Equals(aRegistration->mScope)) {
       target->InvalidateWorkers(aWhichOnes);
     }
   }
 }
 
 NS_IMETHODIMP
-ServiceWorkerManager::SoftUpdate(const nsAString& aScope)
+ServiceWorkerManager::SoftUpdate(JS::Handle<JS::Value> aOriginAttributes,
+                                 const nsAString& aScope, JSContext* aCx)
 {
   AssertIsOnMainThread();
-  NS_ConvertUTF16toUTF8 scope(aScope);
-
-  nsRefPtr<ServiceWorkerRegistrationInfo> registration;
-  mServiceWorkerRegistrationInfos.Get(scope, getter_AddRefs(registration));
+
+  OriginAttributes attrs;
+  if (!aOriginAttributes.isObject() || !attrs.Init(aCx, aOriginAttributes)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  nsAutoCString suffix;
+  attrs.CreateSuffix(suffix);
+
+  SoftUpdate(suffix, NS_ConvertUTF16toUTF8(aScope));
+  return NS_OK;
+}
+
+void
+ServiceWorkerManager::SoftUpdate(nsIPrincipal* aPrincipal,
+                                 const nsACString& aScope)
+{
+  MOZ_ASSERT(aPrincipal);
+
+  nsAutoCString suffix;
+  nsresult rv = PrincipalToScopeKey(aPrincipal, suffix);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return;
+  }
+
+  SoftUpdate(suffix, aScope);
+}
+
+void
+ServiceWorkerManager::SoftUpdate(const nsACString& aOriginAttributesSuffix,
+                                 const nsACString& aScope)
+{
+  nsRefPtr<ServiceWorkerRegistrationInfo> registration =
+    GetRegistration(aOriginAttributesSuffix, aScope);
   if (NS_WARN_IF(!registration)) {
-    return NS_OK;
+    return;
   }
 
   // "If registration's uninstalling flag is set, abort these steps."
   if (registration->mPendingUninstall) {
-    return NS_OK;
+    return;
   }
 
   // "If registration's installing worker is not null, abort these steps."
   if (registration->mInstallingWorker) {
-    return NS_OK;
+    return;
   }
 
   // "Let newestWorker be the result of running Get Newest Worker algorithm
   // passing registration as its argument.
   // If newestWorker is null, abort these steps."
   nsRefPtr<ServiceWorkerInfo> newest = registration->Newest();
   if (!newest) {
-    return NS_OK;
+    return;
   }
 
   // "Set registration's registering script url to newestWorker's script url."
   registration->mScriptSpec = newest->ScriptSpec();
 
-  ServiceWorkerJobQueue* queue = GetOrCreateJobQueue(scope);
+  ServiceWorkerJobQueue* queue =
+    GetOrCreateJobQueue(aOriginAttributesSuffix, aScope);
   MOZ_ASSERT(queue);
 
   nsRefPtr<ServiceWorkerUpdateFinishCallback> cb =
     new ServiceWorkerUpdateFinishCallback();
 
   // "Invoke Update algorithm, or its equivalent, with client, registration as
   // its argument."
   nsRefPtr<ServiceWorkerRegisterJob> job =
     new ServiceWorkerRegisterJob(queue, registration, cb);
   queue->Append(job);
-  return NS_OK;
 }
 
 namespace {
 
 class MOZ_STACK_CLASS FilterRegistrationData
 {
 public:
   FilterRegistrationData(nsTArray<ServiceWorkerClientInfo>& aDocuments,
@@ -3162,20 +3605,24 @@ ClaimMatchingClients(nsISupportsHashKey*
 
   swm->MaybeClaimClient(document, workerRegistration);
 
   return PL_DHASH_NEXT;
 }
 } // anonymous namespace
 
 void
-ServiceWorkerManager::GetAllClients(const nsCString& aScope,
+ServiceWorkerManager::GetAllClients(nsIPrincipal* aPrincipal,
+                                    const nsCString& aScope,
                                     nsTArray<ServiceWorkerClientInfo>& aControlledDocuments)
 {
-  nsRefPtr<ServiceWorkerRegistrationInfo> registration = GetRegistration(aScope);
+  MOZ_ASSERT(aPrincipal);
+
+  nsRefPtr<ServiceWorkerRegistrationInfo> registration =
+    GetRegistration(aPrincipal, aScope);
 
   if (!registration) {
     // The registration was removed, leave the array empty.
     return;
   }
 
   FilterRegistrationData data(aControlledDocuments, registration);
 
@@ -3211,20 +3658,21 @@ ServiceWorkerManager::MaybeClaimClient(n
     StopControllingADocument(controllingRegistration);
   }
 
   StartControllingADocument(aWorkerRegistration, aDocument);
   FireControllerChangeOnDocument(aDocument);
 }
 
 nsresult
-ServiceWorkerManager::ClaimClients(const nsCString& aScope, uint64_t aId)
+ServiceWorkerManager::ClaimClients(nsIPrincipal* aPrincipal,
+                                   const nsCString& aScope, uint64_t aId)
 {
   nsRefPtr<ServiceWorkerRegistrationInfo> registration =
-    GetRegistration(aScope);
+    GetRegistration(aPrincipal, aScope);
 
   if (!registration || !registration->mActiveWorker ||
       !(registration->mActiveWorker->ID() == aId)) {
     // The worker is not active.
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
   mAllDocuments.EnumerateEntries(ClaimMatchingClients, registration);
@@ -3233,31 +3681,61 @@ ServiceWorkerManager::ClaimClients(const
 }
 
 void
 ServiceWorkerManager::FireControllerChange(ServiceWorkerRegistrationInfo* aRegistration)
 {
   mControlledDocuments.EnumerateRead(FireControllerChangeOnMatchingDocument, aRegistration);
 }
 
+already_AddRefed<ServiceWorkerRegistrationInfo>
+ServiceWorkerManager::GetRegistration(nsIPrincipal* aPrincipal,
+                                      const nsACString& aScope) const
+{
+  MOZ_ASSERT(aPrincipal);
+
+  nsAutoCString suffix;
+  nsresult rv = PrincipalToScopeKey(aPrincipal, suffix);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return nullptr;
+  }
+
+  return GetRegistration(suffix, aScope);
+}
+
+already_AddRefed<ServiceWorkerRegistrationInfo>
+ServiceWorkerManager::GetRegistration(const nsACString& aOriginAttributesSuffix,
+                                      const nsACString& aScope) const
+{
+  nsRefPtr<ServiceWorkerRegistrationInfo> reg;
+
+  RegistrationDataPerPrincipal* data;
+  if (!mRegistrationInfos.Get(aOriginAttributesSuffix, &data)) {
+    return reg.forget();
+  }
+
+  data->mInfos.Get(aScope, getter_AddRefs(reg));
+  return reg.forget();
+}
+
 ServiceWorkerRegistrationInfo*
 ServiceWorkerManager::CreateNewRegistration(const nsCString& aScope,
                                             nsIPrincipal* aPrincipal)
 {
 #ifdef DEBUG
   AssertIsOnMainThread();
   nsCOMPtr<nsIURI> scopeURI;
   nsresult rv = NS_NewURI(getter_AddRefs(scopeURI), aScope, nullptr, nullptr);
   MOZ_ASSERT(NS_SUCCEEDED(rv));
 #endif
+
   ServiceWorkerRegistrationInfo* registration = new ServiceWorkerRegistrationInfo(aScope, aPrincipal);
   // From now on ownership of registration is with
   // mServiceWorkerRegistrationInfos.
-  mServiceWorkerRegistrationInfos.Put(aScope, registration);
-  AddScope(mOrderedScopes, aScope);
+  AddScopeAndRegistration(aScope, registration);
   return registration;
 }
 
 void
 ServiceWorkerManager::MaybeRemoveRegistration(ServiceWorkerRegistrationInfo* aRegistration)
 {
   MOZ_ASSERT(aRegistration);
   nsRefPtr<ServiceWorkerInfo> newest = aRegistration->Newest();
@@ -3266,18 +3744,16 @@ ServiceWorkerManager::MaybeRemoveRegistr
   }
 }
 
 void
 ServiceWorkerManager::RemoveRegistrationInternal(ServiceWorkerRegistrationInfo* aRegistration)
 {
   MOZ_ASSERT(aRegistration);
   MOZ_ASSERT(!aRegistration->IsControllingDocuments());
-  MOZ_ASSERT(mServiceWorkerRegistrationInfos.Contains(aRegistration->mScope));
-  ServiceWorkerManager::RemoveScope(mOrderedScopes, aRegistration->mScope);
 
   // All callers should be either from a job in which case the actor is
   // available, or from MaybeStopControlling(), in which case, this will only be
   // called if a valid registration is found. If a valid registration exists,
   // it means the actor is available since the original map of registrations is
   // populated by it, and any new registrations wait until the actor is
   // available before proceeding (See ServiceWorkerRegisterJob::Start).
   MOZ_ASSERT(mActor);
@@ -3285,17 +3761,19 @@ ServiceWorkerManager::RemoveRegistration
   PrincipalInfo principalInfo;
   if (NS_WARN_IF(NS_FAILED(PrincipalToPrincipalInfo(aRegistration->mPrincipal,
                                                     &principalInfo)))) {
     //XXXnsm I can't think of any other reason a stored principal would fail to
     //convert.
     NS_WARNING("Unable to unregister serviceworker due to possible OOM");
     return;
   }
-  mActor->SendUnregisterServiceWorker(principalInfo, NS_ConvertUTF8toUTF16(aRegistration->mScope));
+
+  mActor->SendUnregisterServiceWorker(principalInfo,
+                                      NS_ConvertUTF8toUTF16(aRegistration->mScope));
 }
 
 class ServiceWorkerDataInfo final : public nsIServiceWorkerInfo
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSISERVICEWORKERINFO
 
@@ -3315,18 +3793,18 @@ private:
   nsString mCurrentWorkerURL;
   nsString mActiveCacheName;
   nsString mWaitingCacheName;
 };
 void
 ServiceWorkerManager::RemoveRegistration(ServiceWorkerRegistrationInfo* aRegistration)
 {
   RemoveRegistrationInternal(aRegistration);
-  MOZ_ASSERT(mServiceWorkerRegistrationInfos.Contains(aRegistration->mScope));
-  mServiceWorkerRegistrationInfos.Remove(aRegistration->mScope);
+  MOZ_ASSERT(HasScope(aRegistration->mPrincipal, aRegistration->mScope));
+  RemoveScopeAndRegistration(aRegistration);
 }
 
 namespace {
 /**
  * See browser/components/sessionstore/Utils.jsm function hasRootDomain().
  *
  * Returns true if the |url| passed in is part of the given root |domain|.
  * For example, if |url| is "www.mozilla.org", and we pass in |domain| as
@@ -3361,45 +3839,73 @@ HasRootDomain(nsIURI* aURI, const nsACSt
     // Equals failed so this is fine.
     return false;
   }
 
   char prevChar = *(--start);
   return prevChar == '.';
 }
 
+struct UnregisterIfMatchesHostData
+{
+  UnregisterIfMatchesHostData(
+    ServiceWorkerManager::RegistrationDataPerPrincipal* aRegistrationData,
+    void* aUserData)
+    : mRegistrationData(aRegistrationData)
+    , mUserData(aUserData)
+  {}
+
+  ServiceWorkerManager::RegistrationDataPerPrincipal* mRegistrationData;
+  void *mUserData;
+};
+
 // If host/aData is null, unconditionally unregisters.
 PLDHashOperator
 UnregisterIfMatchesHost(const nsACString& aScope,
                         ServiceWorkerRegistrationInfo* aReg,
-                        void* aData)
+                        void* aPtr)
 {
+  UnregisterIfMatchesHostData* data =
+    static_cast<UnregisterIfMatchesHostData*>(aPtr);
+
   // We avoid setting toRemove = aReg by default since there is a possibility
-  // of failure when aData is passed, in which case we don't want to remove the
-  // registration.
+  // of failure when data->mUserData is passed, in which case we don't want to
+  // remove the registration.
   ServiceWorkerRegistrationInfo* toRemove = nullptr;
-  if (aData) {
-    const nsACString& domain = *static_cast<nsACString*>(aData);
+  if (data->mUserData) {
+    const nsACString& domain = *static_cast<nsACString*>(data->mUserData);
     nsCOMPtr<nsIURI> scopeURI;
     nsresult rv = NS_NewURI(getter_AddRefs(scopeURI), aScope, nullptr, nullptr);
     // This way subdomains are also cleared.
     if (NS_SUCCEEDED(rv) && HasRootDomain(scopeURI, domain)) {
       toRemove = aReg;
     }
   } else {
     toRemove = aReg;
   }
 
   if (toRemove) {
     nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
-    swm->ForceUnregister(toRemove);
+    swm->ForceUnregister(data->mRegistrationData, toRemove);
   }
 
   return PL_DHASH_NEXT;
 }
+
+// If host/aData is null, unconditionally unregisters.
+PLDHashOperator
+UnregisterIfMatchesHostPerPrincipal(const nsACString& aKey,
+                                    ServiceWorkerManager::RegistrationDataPerPrincipal* aData,
+                                    void* aUserData)
+{
+  UnregisterIfMatchesHostData data(aData, aUserData);
+  aData->mInfos.EnumerateRead(UnregisterIfMatchesHost, &data);
+  return PL_DHASH_NEXT;
+}
+
 } // anonymous namespace
 NS_IMPL_ISUPPORTS(ServiceWorkerDataInfo, nsIServiceWorkerInfo)
 
 /* static */ already_AddRefed<ServiceWorkerDataInfo>
 ServiceWorkerDataInfo::Create(const ServiceWorkerRegistrationData& aData)
 {
   AssertIsOnMainThread();
 
@@ -3493,64 +3999,74 @@ ServiceWorkerManager::GetAllRegistration
   }
 
   array.forget(aResult);
   return NS_OK;
 }
 
 // MUST ONLY BE CALLED FROM UnregisterIfMatchesHost!
 void
-ServiceWorkerManager::ForceUnregister(ServiceWorkerRegistrationInfo* aRegistration)
+ServiceWorkerManager::ForceUnregister(RegistrationDataPerPrincipal* aRegistrationData,
+                                      ServiceWorkerRegistrationInfo* aRegistration)
 {
+  MOZ_ASSERT(aRegistrationData);
   MOZ_ASSERT(aRegistration);
 
-  ServiceWorkerJobQueue* mQueue;
-  mJobQueues.Get(aRegistration->mScope, &mQueue);
-  if (mQueue) {
-    mQueue->CancelJobs();
+  ServiceWorkerJobQueue* queue;
+  aRegistrationData->mJobQueues.Get(aRegistration->mScope, &queue);
+  if (queue) {
+    queue->CancelJobs();
   }
 
   // Since Unregister is async, it is ok to call it in an enumeration.
   Unregister(aRegistration->mPrincipal, nullptr, NS_ConvertUTF8toUTF16(aRegistration->mScope));
 }
 
 NS_IMETHODIMP
 ServiceWorkerManager::Remove(const nsACString& aHost)
 {
   AssertIsOnMainThread();
-  mServiceWorkerRegistrationInfos.EnumerateRead(UnregisterIfMatchesHost, &const_cast<nsACString&>(aHost));
+  mRegistrationInfos.EnumerateRead(UnregisterIfMatchesHostPerPrincipal,
+                                   &const_cast<nsACString&>(aHost));
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerManager::RemoveAll()
 {
   AssertIsOnMainThread();
-  mServiceWorkerRegistrationInfos.EnumerateRead(UnregisterIfMatchesHost, nullptr);
+  mRegistrationInfos.EnumerateRead(UnregisterIfMatchesHostPerPrincipal, nullptr);
   return NS_OK;
 }
 
 static PLDHashOperator
 UpdateEachRegistration(const nsACString& aKey,
                        ServiceWorkerRegistrationInfo* aInfo,
                        void* aUserArg) {
   auto This = static_cast<ServiceWorkerManager*>(aUserArg);
   MOZ_ASSERT(!aInfo->mScope.IsEmpty());
-  nsresult res = This->SoftUpdate(NS_ConvertUTF8toUTF16(aInfo->mScope));
-  unused << NS_WARN_IF(NS_FAILED(res));
-
+
+  This->SoftUpdate(aInfo->mPrincipal, aInfo->mScope);
+  return PL_DHASH_NEXT;
+}
+
+static PLDHashOperator
+UpdateEachRegistrationPerPrincipal(const nsACString& aKey,
+                                   ServiceWorkerManager::RegistrationDataPerPrincipal* aData,
+                                   void* aUserArg) {
+  aData->mInfos.EnumerateRead(UpdateEachRegistration, aUserArg);
   return PL_DHASH_NEXT;
 }
 
 NS_IMETHODIMP
 ServiceWorkerManager::UpdateAllRegistrations()
 {
   AssertIsOnMainThread();
 
-  mServiceWorkerRegistrationInfos.EnumerateRead(UpdateEachRegistration, this);
+  mRegistrationInfos.EnumerateRead(UpdateEachRegistrationPerPrincipal, this);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerManager::Observe(nsISupports* aSubject,
                               const char* aTopic,
                               const char16_t* aData)
diff --git a/dom/workers/ServiceWorkerManager.h b/dom/workers/ServiceWorkerManager.h
--- a/dom/workers/ServiceWorkerManager.h
+++ b/dom/workers/ServiceWorkerManager.h
@@ -28,128 +28,34 @@
 #include "nsClassHashtable.h"
 #include "nsDataHashtable.h"
 #include "nsRefPtrHashtable.h"
 #include "nsTArrayForwardDeclare.h"
 #include "nsTObserverArray.h"
 
 namespace mozilla {
 
+class OriginAttributes;
+
 namespace ipc {
 class BackgroundChild;
 }
 
 namespace dom {
 
 class ServiceWorkerRegistrationListener;
 
 namespace workers {
 
 class ServiceWorker;
 class ServiceWorkerClientInfo;
 class ServiceWorkerInfo;
-
+class ServiceWorkerJob;
 class ServiceWorkerJobQueue;
 
-class ServiceWorkerJob : public nsISupports
-{
-protected:
-  // The queue keeps the jobs alive, so they can hold a rawptr back to the
-  // queue.
-  ServiceWorkerJobQueue* mQueue;
-
-public:
-  NS_DECL_ISUPPORTS
-
-  virtual void Start() = 0;
-
-  virtual bool
-  IsRegisterJob() const { return false; }
-
-protected:
-  explicit ServiceWorkerJob(ServiceWorkerJobQueue* aQueue)
-    : mQueue(aQueue)
-  {
-  }
-
-  virtual ~ServiceWorkerJob()
-  { }
-
-  void
-  Done(nsresult aStatus);
-};
-
-class ServiceWorkerJobQueue final
-{
-  friend class ServiceWorkerJob;
-
-  nsTArray<nsRefPtr<ServiceWorkerJob>> mJobs;
-  bool mPopping;
-
-public:
-  explicit ServiceWorkerJobQueue()
-    : mPopping(false)
-  {}
-
-  ~ServiceWorkerJobQueue()
-  {
-    if (!mJobs.IsEmpty()) {
-      NS_WARNING("Pending/running jobs still around on shutdown!");
-    }
-  }
-
-  void
-  Append(ServiceWorkerJob* aJob)
-  {
-    MOZ_ASSERT(aJob);
-    MOZ_ASSERT(!mJobs.Contains(aJob));
-    bool wasEmpty = mJobs.IsEmpty();
-    mJobs.AppendElement(aJob);
-    if (wasEmpty) {
-      aJob->Start();
-    }
-  }
-
-  void
-  CancelJobs();
-
-  // Only used by HandleError, keep it that way!
-  ServiceWorkerJob*
-  Peek()
-  {
-    if (mJobs.IsEmpty()) {
-      return nullptr;
-    }
-    return mJobs[0];
-  }
-
-private:
-  void
-  Pop()
-  {
-    MOZ_ASSERT(!mPopping,
-               "Pop() called recursively, did you write a job which calls Done() synchronously from Start()?");
-    AutoRestore<bool> savePopping(mPopping);
-    mPopping = true;
-    MOZ_ASSERT(!mJobs.IsEmpty());
-    mJobs.RemoveElementAt(0);
-    if (!mJobs.IsEmpty()) {
-      mJobs[0]->Start();
-    }
-  }
-
-  void
-  Done(ServiceWorkerJob* aJob)
-  {
-    MOZ_ASSERT(!mJobs.IsEmpty());
-    MOZ_ASSERT(mJobs[0] == aJob);
-    Pop();
-  }
-};
-
 // Needs to inherit from nsISupports because NS_ProxyRelease() does not support
 // non-ISupports classes.
 class ServiceWorkerRegistrationInfo final : public nsISupports
 {
   uint32_t mControlledDocumentsCounter;
 
   virtual ~ServiceWorkerRegistrationInfo();
 
@@ -167,18 +73,18 @@ public:
   nsRefPtr<ServiceWorkerInfo> mWaitingWorker;
   nsRefPtr<ServiceWorkerInfo> mInstallingWorker;
 
   // When unregister() is called on a registration, it is not immediately
   // removed since documents may be controlled. It is marked as
   // pendingUninstall and when all controlling documents go away, removed.
   bool mPendingUninstall;
 
-  explicit ServiceWorkerRegistrationInfo(const nsACString& aScope,
-                                         nsIPrincipal* aPrincipal);
+  ServiceWorkerRegistrationInfo(const nsACString& aScope,
+                                nsIPrincipal* aPrincipal);
 
   already_AddRefed<ServiceWorkerInfo>
   Newest()
   {
     nsRefPtr<ServiceWorkerInfo> newest;
     if (mInstallingWorker) {
       newest = mInstallingWorker;
     } else if (mWaitingWorker) {
@@ -339,16 +245,17 @@ public:
 class ServiceWorkerManager final
   : public nsIServiceWorkerManager
   , public nsIIPCBackgroundChildCreateCallback
   , public nsIObserver
 {
   friend class GetReadyPromiseRunnable;
   friend class GetRegistrationsRunnable;
   friend class GetRegistrationRunnable;
+  friend class ServiceWorkerJobQueue;
   friend class ServiceWorkerRegisterJob;
   friend class ServiceWorkerRegistrationInfo;
   friend class ServiceWorkerUnregisterJob;
 
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSISERVICEWORKERMANAGER
   NS_DECL_NSIIPCBACKGROUNDCHILDCREATECALLBACK
@@ -359,113 +266,120 @@ public:
   {
     AssertIsOnMainThread();
 
     ServiceWorkerManager* res = new ServiceWorkerManager;
     NS_ADDREF(res);
     return res;
   }
 
-  // Ordered list of scopes for glob matching.
-  // Each entry is an absolute URL representing the scope.
-  //
-  // An array is used for now since the number of controlled scopes per
-  // domain is expected to be relatively low. If that assumption was proved
-  // wrong this should be replaced with a better structure to avoid the
-  // memmoves associated with inserting stuff in the middle of the array.
-  nsTArray<nsCString> mOrderedScopes;
-
-  // Scope to registration.
-  // The scope should be a fully qualified valid URL.
-  nsRefPtrHashtable<nsCStringHashKey, ServiceWorkerRegistrationInfo> mServiceWorkerRegistrationInfos;
+  struct RegistrationDataPerPrincipal;
+  nsClassHashtable<nsCStringHashKey, RegistrationDataPerPrincipal> mRegistrationInfos;
 
   nsTObserverArray<ServiceWorkerRegistrationListener*> mServiceWorkerRegistrationListeners;
 
   nsRefPtrHashtable<nsISupportsHashKey, ServiceWorkerRegistrationInfo> mControlledDocuments;
 
   // Set of all documents that may be controlled by a service worker.
   nsTHashtable<nsISupportsHashKey> mAllDocuments;
 
-  // Maps scopes to job queues.
-  nsClassHashtable<nsCStringHashKey, ServiceWorkerJobQueue> mJobQueues;
+  bool
+  IsAvailableForURI(const OriginAttributes& aOriginAttributes, nsIURI* aURI);
 
-  nsDataHashtable<nsCStringHashKey, bool> mSetOfScopesBeingUpdated;
+  bool
+  IsControlled(nsIDocument* aDocument, ErrorResult& aRv);
+
+  void
+  DispatchFetchEvent(const OriginAttributes& aOriginAttributes,
+                     nsIDocument* aDoc,
+                     nsIInterceptedChannel* aChannel,
+                     bool aIsReload,
+                     ErrorResult& aRv);
+
+  void
+  SoftUpdate(nsIPrincipal* aPrincipal, const nsACString& aScope);
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
-  GetRegistration(const nsCString& aScope) const
-  {
-    nsRefPtr<ServiceWorkerRegistrationInfo> reg;
-    mServiceWorkerRegistrationInfos.Get(aScope, getter_AddRefs(reg));
-    return reg.forget();
-  }
+  GetRegistration(nsIPrincipal* aPrincipal, const nsACString& aScope) const;
 
   ServiceWorkerRegistrationInfo*
   CreateNewRegistration(const nsCString& aScope, nsIPrincipal* aPrincipal);
 
   void
   RemoveRegistration(ServiceWorkerRegistrationInfo* aRegistration);
 
-  ServiceWorkerJobQueue*
-  GetOrCreateJobQueue(const nsCString& aScope)
-  {
-    return mJobQueues.LookupOrAdd(aScope);
-  }
-
   void StoreRegistration(nsIPrincipal* aPrincipal,
                          ServiceWorkerRegistrationInfo* aRegistration);
 
   void
   FinishFetch(ServiceWorkerRegistrationInfo* aRegistration);
 
   // Returns true if the error was handled, false if normal worker error
   // handling should continue.
   bool
   HandleError(JSContext* aCx,
+              nsIPrincipal* aPrincipal,
               const nsCString& aScope,
               const nsString& aWorkerURL,
               nsString aMessage,
               nsString aFilename,
               nsString aLine,
               uint32_t aLineNumber,
               uint32_t aColumnNumber,
               uint32_t aFlags);
 
   void
-  GetAllClients(const nsCString& aScope,
+  GetAllClients(nsIPrincipal* aPrincipal,
+                const nsCString& aScope,
                 nsTArray<ServiceWorkerClientInfo>& aControlledDocuments);
 
   void
   MaybeClaimClient(nsIDocument* aDocument,
                    ServiceWorkerRegistrationInfo* aWorkerRegistration);
 
   nsresult
-  ClaimClients(const nsCString& aScope, uint64_t aId);
+  ClaimClients(nsIPrincipal* aPrincipal, const nsCString& aScope, uint64_t aId);
 
   static already_AddRefed<ServiceWorkerManager>
   GetInstance();
 
  void LoadRegistrations(
                  const nsTArray<ServiceWorkerRegistrationData>& aRegistrations);
 
   // Used by remove() and removeAll() when clearing history.
   // MUST ONLY BE CALLED FROM UnregisterIfMatchesHost!
   void
-  ForceUnregister(ServiceWorkerRegistrationInfo* aRegistration);
+  ForceUnregister(RegistrationDataPerPrincipal* aRegistrationData,
+                  ServiceWorkerRegistrationInfo* aRegistration);
 
   NS_IMETHOD
   AddRegistrationEventListener(const nsAString& aScope,
                                ServiceWorkerRegistrationListener* aListener);
 
   NS_IMETHOD
   RemoveRegistrationEventListener(const nsAString& aScope,
                                   ServiceWorkerRegistrationListener* aListener);
 private:
   ServiceWorkerManager();
   ~ServiceWorkerManager();
 
+  ServiceWorkerJobQueue*
+  GetOrCreateJobQueue(const nsACString& aOriginSuffix,
+                      const nsACString& aScope);
+
+  void
+  MaybeRemoveRegistrationInfo(const nsACString& aOriginAttributesSuffix);
+
+  void
+  SoftUpdate(const nsACString& aOriginAttributesSuffix, const nsACString& aScope);
+
+  already_AddRefed<ServiceWorkerRegistrationInfo>
+  GetRegistration(const nsACString& aOriginAttributesSuffix,
+                  const nsACString& aScope) const;
+
   void
   AbortCurrentUpdate(ServiceWorkerRegistrationInfo* aRegistration);
 
   nsresult
   Update(ServiceWorkerRegistrationInfo* aRegistration);
 
   nsresult
   GetDocumentRegistration(nsIDocument* aDoc, ServiceWorkerRegistrationInfo** aRegistrationInfo);
@@ -482,17 +396,18 @@ private:
 
   NS_IMETHODIMP
   GetServiceWorkerForScope(nsIDOMWindow* aWindow,
                            const nsAString& aScope,
                            WhichServiceWorker aWhichWorker,
                            nsISupports** aServiceWorker);
 
   already_AddRefed<ServiceWorker>
-  CreateServiceWorkerForScope(const nsACString& aScope);
+  CreateServiceWorkerForScope(const OriginAttributes& aOriginAttributes,
+                              const nsACString& aScope);
 
   void
   InvalidateServiceWorkerRegistrationWorker(ServiceWorkerRegistrationInfo* aRegistration,
                                             WhichServiceWorker aWhichOnes);
 
   void
   StartControllingADocument(ServiceWorkerRegistrationInfo* aRegistration,
                             nsIDocument* aDoc);
@@ -502,26 +417,48 @@ private:
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
   GetServiceWorkerRegistrationInfo(nsPIDOMWindow* aWindow);
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
   GetServiceWorkerRegistrationInfo(nsIDocument* aDoc);
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
-  GetServiceWorkerRegistrationInfo(nsIURI* aURI);
+  GetServiceWorkerRegistrationInfo(nsIPrincipal* aPrincipal, nsIURI* aURI);
+
+  already_AddRefed<ServiceWorkerRegistrationInfo>
+  GetServiceWorkerRegistrationInfo(const OriginAttributes& aOriginAttributes,
+                                   nsIURI* aURI);
+
+  already_AddRefed<ServiceWorkerRegistrationInfo>
+  GetServiceWorkerRegistrationInfo(const nsACString& aOriginAttributesSuffix,
+                                   nsIURI* aURI);
+
+  // This method generates a key using appId and isInElementBrowser from the
+  // principal. We don't use the origin because it can simple change during the
+  // loading.
+  static nsresult
+  PrincipalToScopeKey(nsIPrincipal* aPrincipal, nsACString& aKey);
 
   static void
-  AddScope(nsTArray<nsCString>& aList, const nsACString& aScope);
+  AddScopeAndRegistration(const nsACString& aScope,
+                          ServiceWorkerRegistrationInfo* aRegistation);
 
-  static nsCString
-  FindScopeForPath(nsTArray<nsCString>& aList, const nsACString& aPath);
+  static bool
+  FindScopeForPath(const nsACString& aOriginAttributesSuffix,
+                   const nsACString& aPath,
+                   RegistrationDataPerPrincipal** aData, nsACString& aMatch);
+
+#ifdef DEBUG
+  static bool
+  HasScope(nsIPrincipal* aPrincipal, const nsACString& aScope);
+#endif
 
   static void
-  RemoveScope(nsTArray<nsCString>& aList, const nsACString& aScope);
+  RemoveScopeAndRegistration(ServiceWorkerRegistrationInfo* aRegistration);
 
   void
   QueueFireEventOnServiceWorkerRegistrations(ServiceWorkerRegistrationInfo* aRegistration,
                                              const nsAString& aName);
 
   void
   FireUpdateFoundOnServiceWorkerRegistrations(ServiceWorkerRegistrationInfo* aRegistration);
 
diff --git a/dom/workers/ServiceWorkerRegistration.cpp b/dom/workers/ServiceWorkerRegistration.cpp
--- a/dom/workers/ServiceWorkerRegistration.cpp
+++ b/dom/workers/ServiceWorkerRegistration.cpp
@@ -228,45 +228,110 @@ ServiceWorkerRegistrationMainThread::Inv
   if (aWhichOnes & WhichServiceWorker::ACTIVE_WORKER) {
     mActiveWorker = nullptr;
   }
 }
 
 namespace {
 
 void
-UpdateInternal(const nsAString& aScope)
+UpdateInternal(nsIPrincipal* aPrincipal, const nsAString& aScope)
 {
   AssertIsOnMainThread();
-  nsCOMPtr<nsIServiceWorkerManager> swm =
-    mozilla::services::GetServiceWorkerManager();
+  MOZ_ASSERT(aPrincipal);
+
+  nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   MOZ_ASSERT(swm);
+
   // The spec defines ServiceWorkerRegistration.update() exactly as Soft Update.
-  swm->SoftUpdate(aScope);
+  swm->SoftUpdate(aPrincipal, NS_ConvertUTF16toUTF8(aScope));
 }
 
+// This Runnable needs to have a valid WorkerPrivate. For this reason it is also
+// a WorkerFeature that is registered before dispatching itself to the
+// main-thread and it's removed with ReleaseRunnable when the operation is
+// completed. This will keep the worker alive as long as necessary.
 class UpdateRunnable final : public nsRunnable
+                           , public WorkerFeature
 {
 public:
-  explicit UpdateRunnable(const nsAString& aScope)
-    : mScope(aScope)
+  UpdateRunnable(WorkerPrivate* aWorkerPrivate, const nsAString& aScope)
+    : mWorkerPrivate(aWorkerPrivate)
+    , mScope(aScope)
   {}
 
   NS_IMETHOD
   Run() override
   {
     AssertIsOnMainThread();
-    UpdateInternal(mScope);
+    UpdateInternal(mWorkerPrivate->GetPrincipal(), mScope);
+
+    class ReleaseRunnable final : public MainThreadWorkerControlRunnable
+    {
+      nsRefPtr<UpdateRunnable> mRunnable;
+
+    public:
+      ReleaseRunnable(WorkerPrivate* aWorkerPrivate,
+                      UpdateRunnable* aRunnable)
+        : MainThreadWorkerControlRunnable(aWorkerPrivate)
+        , mRunnable(aRunnable)
+      {
+        MOZ_ASSERT(aRunnable);
+      }
+
+      virtual bool
+      WorkerRun(JSContext* aCx,
+                workers::WorkerPrivate* aWorkerPrivate) override
+      {
+        MOZ_ASSERT(aWorkerPrivate);
+        aWorkerPrivate->AssertIsOnWorkerThread();
+
+        aWorkerPrivate->RemoveFeature(aCx, mRunnable);
+        return true;
+      }
+
+    private:
+      ~ReleaseRunnable()
+      {}
+    };
+
+    nsRefPtr<WorkerControlRunnable> runnable =
+      new ReleaseRunnable(mWorkerPrivate, this);
+    runnable->Dispatch(nullptr);
+
     return NS_OK;
   }
 
+  virtual bool Notify(JSContext* aCx, workers::Status aStatus) override
+  {
+    // We don't care about the notification. We just want to keep the
+    // mWorkerPrivate alive.
+    return true;
+  }
+
+  bool
+  Dispatch()
+  {
+    mWorkerPrivate->AssertIsOnWorkerThread();
+
+    JSContext* cx = mWorkerPrivate->GetJSContext();
+
+    if (NS_WARN_IF(!mWorkerPrivate->AddFeature(cx, this))) {
+      return false;
+    }
+
+    NS_SUCCEEDED(NS_DispatchToMainThread(this));
+    return true;
+  }
+
 private:
   ~UpdateRunnable()
   {}
 
+  WorkerPrivate* mWorkerPrivate;
   const nsString mScope;
 };
 
 class UnregisterCallback final : public nsIServiceWorkerUnregisterCallback
 {
   nsRefPtr<Promise> mPromise;
 
 public:
@@ -449,17 +514,23 @@ public:
     return NS_OK;
   }
 };
 } // anonymous namespace
 
 void
 ServiceWorkerRegistrationMainThread::Update()
 {
-  UpdateInternal(mScope);
+  nsCOMPtr<nsIDocument> doc = GetOwner()->GetExtantDoc();
+  MOZ_ASSERT(doc);
+
+  nsCOMPtr<nsIPrincipal> principal = doc->NodePrincipal();
+  MOZ_ASSERT(principal);
+
+  UpdateInternal(principal, mScope);
 }
 
 already_AddRefed<Promise>
 ServiceWorkerRegistrationMainThread::Unregister(ErrorResult& aRv)
 {
   AssertIsOnMainThread();
   nsCOMPtr<nsIGlobalObject> go = do_QueryInterface(GetOwner());
   if (!go) {
@@ -731,23 +802,22 @@ ServiceWorkerRegistrationWorkerThread::G
 {
   // FIXME(nsm): Will be implemented after Bug 1113522.
   return nullptr;
 }
 
 void
 ServiceWorkerRegistrationWorkerThread::Update()
 {
-#ifdef DEBUG
   WorkerPrivate* worker = GetCurrentThreadWorkerPrivate();
   MOZ_ASSERT(worker);
   worker->AssertIsOnWorkerThread();
-#endif
-  nsCOMPtr<nsIRunnable> r = new UpdateRunnable(mScope);
-  MOZ_ALWAYS_TRUE(NS_SUCCEEDED(NS_DispatchToMainThread(r)));
+
+  nsRefPtr<UpdateRunnable> r = new UpdateRunnable(worker, mScope);
+  r->Dispatch();
 }
 
 already_AddRefed<Promise>
 ServiceWorkerRegistrationWorkerThread::Unregister(ErrorResult& aRv)
 {
   WorkerPrivate* worker = GetCurrentThreadWorkerPrivate();
   MOZ_ASSERT(worker);
   worker->AssertIsOnWorkerThread();
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -1596,17 +1596,18 @@ private:
         aWorkerPrivate->QueueRunnable(this);
         return true;
       }
 
       if (aWorkerPrivate->IsServiceWorker() || aWorkerPrivate->IsSharedWorker()) {
         if (aWorkerPrivate->IsServiceWorker()) {
           nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
           MOZ_ASSERT(swm);
-          bool handled = swm->HandleError(aCx, aWorkerPrivate->SharedWorkerName(),
+          bool handled = swm->HandleError(aCx, aWorkerPrivate->GetPrincipal(),
+                                          aWorkerPrivate->SharedWorkerName(),
                                           aWorkerPrivate->ScriptURL(),
                                           mMessage,
                                           mFilename, mLine, mLineNumber,
                                           mColumnNumber, mFlags);
           if (handled) {
             return true;
           }
         }
diff --git a/toolkit/content/aboutServiceWorkers.js b/toolkit/content/aboutServiceWorkers.js
--- a/toolkit/content/aboutServiceWorkers.js
+++ b/toolkit/content/aboutServiceWorkers.js
@@ -127,17 +127,18 @@ function display(info) {
     error => {
       dump("about:serviceworkers - push registration failed\n");
     }
   );
 
   let updateButton = document.createElement("button");
   updateButton.appendChild(document.createTextNode(bundle.GetStringFromName('update')));
   updateButton.onclick = function() {
-    gSWM.softUpdate(info.scope);
+    gSWM.softUpdate(info.principal.appId, info.principal.isInBrowserElement,
+                    info.scope);
   };
   div.appendChild(updateButton);
 
   let unregisterButton = document.createElement("button");
   unregisterButton.appendChild(document.createTextNode(bundle.GetStringFromName('unregister')));
   div.appendChild(unregisterButton);
 
   let loadingMessage = document.createElement('span');
